I n t e r n a t i o n a l   T e l e c o m m u n i c a t i o n   U n i o n




ITU-T                                                           X.680
TELECOMMUNICATION                                                (02/2021)
STANDARDIZATION SECTOR
OF ITU




SERIES X: DATA NETWORKS, OPEN SYSTEM
COMMUNICATIONS AND SECURITY
OSI networking and system aspects – Abstract Syntax
Notation One (ASN.1)


Information technology – Abstract Syntax
Notation One (ASN.1): Specification of basic
notation




Recommendation ITU-T X.680
                                           ITU-T X-SERIES RECOMMENDATIONS
                   DATA NETWORKS, OPEN SYSTEM COMMUNICATIONS AND SECURITY

   PUBLIC DATA NETWORKS
     Services and facilities                                                X.1–X.19
     Interfaces                                                             X.20–X.49
     Transmission, signalling and switching                                 X.50–X.89
     Network aspects                                                        X.90–X.149
     Maintenance                                                            X.150–X.179
     Administrative arrangements                                            X.180–X.199
   OPEN SYSTEMS INTERCONNECTION
     Model and notation                                                     X.200–X.209
     Service definitions                                                    X.210–X.219
     Connection-mode protocol specifications                                X.220–X.229
     Connectionless-mode protocol specifications                            X.230–X.239
     PICS proformas                                                         X.240–X.259
     Protocol Identification                                                X.260–X.269
     Security Protocols                                                     X.270–X.279
     Layer Managed Objects                                                  X.280–X.289
     Conformance testing                                                    X.290–X.299
   INTERWORKING BETWEEN NETWORKS
     General                                                                X.300–X.349
     Satellite data transmission systems                                    X.350–X.369
     IP-based networks                                                      X.370–X.379
   MESSAGE HANDLING SYSTEMS                                                 X.400–X.499
   DIRECTORY                                                                X.500–X.599
   OSI NETWORKING AND SYSTEM ASPECTS
     Networking                                                             X.600–X.629
     Efficiency                                                             X.630–X.639
     Quality of service                                                     X.640–X.649
     Naming, Addressing and Registration                                    X.650–X.679
     Abstract Syntax Notation One (ASN.1)                                   X.680–X.699
   OSI MANAGEMENT
     Systems management framework and architecture                          X.700–X.709
     Management communication service and protocol                          X.710–X.719
     Structure of management information                                    X.720–X.729
     Management functions and ODMA functions                                X.730–X.799
   SECURITY                                                                 X.800–X.849
   OSI APPLICATIONS
     Commitment, concurrency and recovery                                   X.850–X.859
     Transaction processing                                                 X.860–X.879
     Remote operations                                                      X.880–X.889
     Generic applications of ASN.1                                          X.890–X.899
   OPEN DISTRIBUTED PROCESSING                                              X.900–X.999
   INFORMATION AND NETWORK SECURITY                                         X.1000–X.1099
   SECURE APPLICATIONS AND SERVICES (1)                                     X.1100–X.1199
   CYBERSPACE SECURITY                                                      X.1200–X.1299
   SECURE APPLICATIONS AND SERVICES (2)                                     X.1300–X.1499
   CYBERSECURITY INFORMATION EXCHANGE                                       X.1500–X.1599
   CLOUD COMPUTING SECURITY                                                 X.1600–X.1699
   QUANTUM COMMUNICATION                                                    X.1700–X.1729
   DATA SECURITY                                                            X.1750–X.1799
   5G SECURITY                                                              X.1800–X.1819


For further details, please refer to the list of ITU-T Recommendations.
INTERNATIONAL STANDARD ISO/IEC 8824-1
RECOMMENDATION ITU-T X.680

                      Information technology – Abstract Syntax Notation One (ASN.1):
                                       Specification of basic notation
Summary
Recommendation ITU-T X.680 | ISO/IEC 8824-1 provides a notation called Abstract Syntax Notation One (ASN.1) for
defining the syntax of information data. It defines a number of simple data types and specifies a notation for referencing
these types and for specifying values of these types.
The ASN.1 notations can be applied whenever it is necessary to define the abstract syntax of information without
constraining in any way how the information is encoded for transmission.


History
    Edition   Recommendation                                  Approval    Study Group        Unique ID*
     1.0      ITU-T X.680                                    1994-07-01        7        11.1002/1000/3040
     1.1         ITU-T X.680 (1994) Amd. 1                   1995-04-10        7        11.1002/1000/3041
     1.2         ITU-T X.680 (1994) Technical Cor. 1         1995-11-21        7        11.1002/1000/3282
     1.3         ITU-T X.680 (1994) Technical Cor. 2         1997-12-12        7        11.1002/1000/4180
     1.4         ITU-T X.680 (1994) Amd. 1/Technical Cor.1   1997-12-12        7        11.1002/1000/4179
     1.5         ITU-T X.680 (1994) Amd. 2                   1997-12-12        7        11.1002/1000/4181
     2.0      ITU-T X.680                                    1997-12-12        7        11.1002/1000/4449
     2.1         ITU-T X.680 (1997) Technical Cor. 1         1999-06-18        7        11.1002/1000/4700
     2.2         ITU-T X.680 (1997) Amd. 1                   1999-06-18        7        11.1002/1000/4698
      2.3        ITU-T X.680 (1997) Amd. 2                   1999-06-18       7         11.1002/1000/4699
      2.4        ITU-T X.680 (1997) Technical Cor. 2         2000-03-31       7         11.1002/1000/5046
      2.5        ITU-T X.680 (1997) Technical Cor. 3         2001-02-02       7         11.1002/1000/5331
      2.6        ITU-T X.680 (1997) Technical Cor. 4         2001-03-15       7         11.1002/1000/5332
      2.7        ITU-T X.680 (1997) Amd. 3                   2001-10-29       7         11.1002/1000/5562
      2.8        ITU-T X.680 (1997) Amd. 4                   2001-10-29       7         11.1002/1000/5563
      3.0     ITU-T X.680                                    2002-07-14       17        11.1002/1000/6085
      3.1        ITU-T X.680 (2002) Amd. 1                   2003-10-29       17        11.1002/1000/7019
      3.2        ITU-T X.680 (2002) Amd. 2                   2004-08-29       17        11.1002/1000/7291
      3.3        ITU-T X.680 (2002) Technical Cor. 1         2005-05-14       17        11.1002/1000/8512
      3.4        ITU-T X.680 (2002) Amd. 3                   2006-06-13       17        11.1002/1000/8836
      3.5        ITU-T X.680 (2002) Amd. 4                   2007-05-29       17        11.1002/1000/9105
      4.0     ITU-T X.680                                    2008-11-13       17        11.1002/1000/9604
      4.1        ITU-T X.680 (2008) Cor. 1                   2011-10-14       17        11.1002/1000/11376
      4.2        ITU-T X.680 (2008) Cor. 2                   2014-03-01       17        11.1002/1000/12144
      5.0     ITU-T X.680                                    2015-08-13       17        11.1002/1000/12479
      5.1        ITU-T X.680 (2015) Cor. 1                   2017-05-14       17        11.1002/1000/13257
      5.2        ITU-T X.680 (2015) Cor. 2                   2017-10-14       17        11.1002/1000/13361
      5.3        ITU-T X.680 (2015) Cor. 3                   2018-05-14       17        11.1002/1000/13598
      5.4        ITU-T X.680 (2015) Amd. 1                   2018-05-14       17        11.1002/1000/13597
      6.0     ITU-T X.680                                    2021-02-13       17        11.1002/1000/14468




*  To access the Recommendation, type the URL http://handle.itu.int/ in the address field of your web browser, followed by the
Recommendation's unique ID. For example, http://handle.itu.int/11.1002/1000/11830-en.


                                                                                Rec. ITU-T X.680 (02/2021)                  i
                                               FOREWORD
The International Telecommunication Union (ITU) is the United Nations specialized agency in the field of
telecommunications, information and communication technologies (ICTs). The ITU Telecommunication
Standardization Sector (ITU-T) is a permanent organ of ITU. ITU-T is responsible for studying technical,
operating and tariff questions and issuing Recommendations on them with a view to standardizing
telecommunications on a worldwide basis.
The World Telecommunication Standardization Assembly (WTSA), which meets every four years,
establishes the topics for study by the ITU-T study groups which, in turn, produce Recommendations on
these topics.
The approval of ITU-T Recommendations is covered by the procedure laid down in WTSA Resolution 1.
In some areas of information technology which fall within ITU-T's purview, the necessary standards are
prepared on a collaborative basis with ISO and IEC.




                                                  NOTE
In this Recommendation, the expression "Administration" is used for conciseness to indicate both a
telecommunication administration and a recognized operating agency.
Compliance with this Recommendation is voluntary. However, the Recommendation may contain certain
mandatory provisions (to ensure, e.g., interoperability or applicability) and compliance with the
Recommendation is achieved when all of these mandatory provisions are met. The words "shall" or some
other obligatory language such as "must" and the negative equivalents are used to express requirements. The
use of such words does not suggest that compliance with the Recommendation is required of any party.




                                 INTELLECTUAL PROPERTY RIGHTS
ITU draws attention to the possibility that the practice or implementation of this Recommendation may
involve the use of a claimed Intellectual Property Right. ITU takes no position concerning the evidence,
validity or applicability of claimed Intellectual Property Rights, whether asserted by ITU members or others
outside of the Recommendation development process.
As of the date of approval of this Recommendation, ITU had not received notice of intellectual property,
protected by patents/software copyrights, which may be required to implement this Recommendation.
However, implementers are cautioned that this may not represent the latest information and are therefore
strongly urged to consult the appropriate ITU-T databases available via the ITU-T website at
http://www.itu.int/ITU-T/ipr/.




                                               © ITU 2021
All rights reserved. No part of this publication may be reproduced, by any means whatsoever, without the
prior written permission of ITU.




ii        Rec. ITU-T X.680 (02/2021)
                                                                               CONTENTS
                                                                                                                                                                                  Page
Introduction ...............................................................................................................................................................        viii
1         Scope ..............................................................................................................................................................        1
2         Normative references .....................................................................................................................................                  1
          2.1  Identical Recommendations | International Standards ........................................................................                                           1
          2.2  Additional references ..........................................................................................................................                       2
3         Definitions ......................................................................................................................................................          2
          3.1    International Object Identifier tree specification .................................................................................                                 2
          3.2    Information object specification..........................................................................................................                           2
          3.3    Constraint specification .......................................................................................................................                     3
          3.4    Parameterization of ASN.1 specification ............................................................................................                                 3
          3.5    Structure for identification of organizations........................................................................................                                3
          3.6    Universal Multiple-Octet Coded Character Set (UCS) .......................................................................                                           3
          3.7    Representation of dates and times .......................................................................................................                            3
          3.8    Additional definitions..........................................................................................................................                     4
4         Abbreviations .................................................................................................................................................             9
5         Notation ..........................................................................................................................................................         9
          5.1    General ................................................................................................................................................             9
          5.2    Productions..........................................................................................................................................               10
          5.3    The alternative collections ..................................................................................................................                      10
          5.4    Non-spacing indicator .........................................................................................................................                     10
          5.5    Example of a production .....................................................................................................................                       10
          5.6    Layout .................................................................................................................................................            10
          5.7    Recursion ............................................................................................................................................              11
          5.8    References to permitted sequences of lexical items ............................................................................                                     11
          5.9    References to a lexical item ................................................................................................................                       11
          5.10 Short-hand notations ...........................................................................................................................                      11
          5.11 Value references and the typing of values ...........................................................................................                                 12
6         The ASN.1 model of type extension ..............................................................................................................                           12
7         Extensibility requirements on encoding rules.................................................................................................                              12
8         Tags ................................................................................................................................................................      13
9         Encoding instructions .....................................................................................................................................                14
10        Use of the ASN.1 notation..............................................................................................................................                    15
11        The ASN.1 character set .................................................................................................................................                  15
12        ASN.1 lexical items ........................................................................................................................................               16
          12.1 General rules .......................................................................................................................................                 16
          12.2 Type references ...................................................................................................................................                   17
          12.3 Identifiers ............................................................................................................................................              17
          12.4 Value references ..................................................................................................................................                   17
          12.5 Module references ...............................................................................................................................                     17
          12.6 Comments ...........................................................................................................................................                  17
          12.7 Empty lexical item ..............................................................................................................................                     18
          12.8 Numbers ..............................................................................................................................................                18
          12.9 Real numbers.......................................................................................................................................                   18
          12.10 Binary strings ......................................................................................................................................                18
          12.11 XML binary string item ......................................................................................................................                        18
          12.12 Hexadecimal strings ............................................................................................................................                     18
          12.13 XML hexadecimal string item.............................................................................................................                             19
          12.14 Character strings..................................................................................................................................                  19
          12.15 XML character string item ..................................................................................................................                         20
          12.16 The simple character string lexical item..............................................................................................                               22


                                                                                                                       Rec. ITU-T X.680 (02/2021)                                   iii
     12.17 Time value character strings ...............................................................................................................                22
     12.18 XML time value character string item ................................................................................................                       22
     12.19 The property and setting names lexical item .......................................................................................                         22
     12.20 Assignment lexical item ......................................................................................................................              22
     12.21 Range separator ...................................................................................................................................         22
     12.22 Ellipsis.................................................................................................................................................   22
     12.23 Left version brackets ...........................................................................................................................           23
     12.24 Right version brackets .........................................................................................................................            23
     12.25 Encoding references ............................................................................................................................            23
     12.26 Integer-valued Unicode labels .............................................................................................................                 23
     12.27 Non-integer Unicode labels .................................................................................................................                23
     12.28 XML end tag start item .......................................................................................................................              23
     12.29 XML single tag end item.....................................................................................................................                23
     12.30 XML boolean true item .......................................................................................................................               23
     12.31 XML boolean extended-true item .......................................................................................................                      24
     12.32 XML boolean false item......................................................................................................................                24
     12.33 XML boolean extended-false item ......................................................................................................                      24
     12.34 XML real not-a-number item ..............................................................................................................                   24
     12.35 XML real infinity item ........................................................................................................................             24
     12.36 XML tag names for ASN.1 types ........................................................................................................                      25
     12.37 Single character lexical items ..............................................................................................................               26
     12.38 Reserved words ...................................................................................................................................          26
13   Module definition ...........................................................................................................................................     27
14   Referencing type and value definitions ..........................................................................................................                 31
15   Notation to support references to ASN.1 components ...................................................................................                            32
16   Assigning types and values ............................................................................................................................           33
17   Definition of types and values ........................................................................................................................           35
18   Notation for the boolean type .........................................................................................................................           38
19   Notation for the integer type...........................................................................................................................          38
20   Notation for the enumerated type ...................................................................................................................              39
21   Notation for the real type................................................................................................................................        41
22   Notation for the bitstring type ........................................................................................................................          42
23   Notation for the octetstring type .....................................................................................................................           44
24   Notation for the null type ...............................................................................................................................        44
25   Notation for sequence types ...........................................................................................................................           45
26   Notation for sequence-of types .......................................................................................................................            48
27   Notation for set types .....................................................................................................................................      50
28   Notation for set-of types .................................................................................................................................       51
29   Notation for choice types................................................................................................................................         52
30   Notation for selection types ............................................................................................................................         54
31   Notation for prefixed types .............................................................................................................................         54
     31.1 General ................................................................................................................................................     54
     31.2 The tagged type ...................................................................................................................................          55
     31.3 The encoding prefixed type .................................................................................................................                 55
32   Notation for the object identifier type ............................................................................................................              56
33   Notation for the relative object identifier type ...............................................................................................                  58
34   Notation for the OID internationalized resource identifier type .....................................................................                             59
35   Notation for the relative OID internationalized resource identifier type ........................................................                                 60
36   Notation for the embedded-pdv type ..............................................................................................................                 60
37   Notation for the external type .........................................................................................................................          62


iv         Rec. ITU-T X.680 (02/2021)
38   The time type ..................................................................................................................................................   63
     38.1 General ................................................................................................................................................      63
     38.2 Time properties and settings of time abstract values ...........................................................................                              63
     38.3 Basic value notation and XML value notation for time abstract values with specified property
            settings ................................................................................................................................................   67
     38.4 Useful time types.................................................................................................................................            71
39   The character string types ...............................................................................................................................         72
40   Notation for character string types .................................................................................................................              73
41   Definition of restricted character string types ................................................................................................                   73
42   Naming characters, collections and property category sets ............................................................................                             77
43   Canonical order of characters .........................................................................................................................            81
44   Definition of unrestricted character string types ............................................................................................                     82
45   Notation for types defined in clauses 46 to 48 ...............................................................................................                     83
46   Generalized time.............................................................................................................................................      83
47   Universal time ................................................................................................................................................    84
48   The object descriptor type ..............................................................................................................................          85
49   Constrained types ...........................................................................................................................................      86
50   Element set specification ................................................................................................................................         87
51   Subtype elements ............................................................................................................................................      89
     51.1 General ................................................................................................................................................      89
     51.2 Single value .........................................................................................................................................        90
     51.3 Contained subtype ...............................................................................................................................             90
     51.4 Value range .........................................................................................................................................         90
     51.5 Size constraint .....................................................................................................................................         91
     51.6 Type constraint ....................................................................................................................................          91
     51.7 Permitted alphabet...............................................................................................................................             91
     51.8 Inner subtyping....................................................................................................................................           92
     51.9 Pattern constraint.................................................................................................................................           93
     51.10 Property settings ..................................................................................................................................         93
     51.11 Duration range.....................................................................................................................................          94
     51.12 Time point range .................................................................................................................................           95
     51.13 Recurrence range.................................................................................................................................            95
52   The extension marker .....................................................................................................................................         95
53   The exception identifier ..................................................................................................................................        97
54   Encoding control sections...............................................................................................................................            98
     A.1 Definition ............................................................................................................................................         99
     A.2 Metacharacters ....................................................................................................................................             99
     B.1 General ................................................................................................................................................       103
     B.2 The ASN.1 defined time types module ...............................................................................................                            103
     C.1 The need for the value mapping concept (tutorial introduction) .........................................................                                       108
     C.2 Value mappings...................................................................................................................................              110
     C.3 Identical type definitions .....................................................................................................................               111
     C.4 Specification of value mappings .........................................................................................................                      113
     C.5 Additional value mappings defined for the character string types ......................................................                                        113
     C.6 Specific type and value compatibility requirements............................................................................                                 114
     C.7 Examples .............................................................................................................................................         115
           C.7.2       Example 1 .........................................................................................................................              115
           C.7.3       Example 2 .........................................................................................................................              115
           C.7.4       Example 3 .........................................................................................................................              115
           C.7.5       Example 4 .........................................................................................................................              115
           C.7.6       Example 5 .........................................................................................................................              115
           C.7.7       Example 6 .........................................................................................................................              116



                                                                                                               Rec. ITU-T X.680 (02/2021)                                v
     D.1     Values assigned in this Recommendation | International Standard .....................................................                                         117
     D.2     Object identifiers in the ASN.1 and encoding rules standards ............................................................                                     117
     F.1     General ................................................................................................................................................      120
     F.2     Use of the International Object Identifier tree by the object identifier (OBJECT IDENTIFIER)
             type ......................................................................................................................................................   120
     F.3     Use of the International Object Identifier tree by the OID internationalized resource identifier
             (OID-IRI) type ..................................................................................................................................             120
     G.1     Example of a personnel record ............................................................................................................                    121
             G.1.1           Informal description of Personnel Record.........................................................................                             121
             G.1.2           ASN.1 description of the record structure .........................................................................                           121
             G.1.3           ASN.1 description of a record value .................................................................................                         122
     G.2     Guidelines for use of the notation .......................................................................................................                    122
             G.2.1           Boolean .............................................................................................................................         123
             G.2.2           Integer ...............................................................................................................................       123
             G.2.3           Enumerated .......................................................................................................................            123
             G.2.4           Real ...................................................................................................................................      124
             G.2.5           Bit string............................................................................................................................        124
             G.2.6           Octet string ........................................................................................................................         126
             G.2.7           UniversalString, BMPString and UTF8String ..................................................................                                  126
             G.2.8           CHARACTER STRING ...................................................................................................                          127
             G.2.9           Null ...................................................................................................................................      128
             G.2.10          Sequence and sequence-of ................................................................................................                     128
             G.2.11          Set and set-of .....................................................................................................................          130
             G.2.12          Tagged...............................................................................................................................         132
             G.2.13          Choice ...............................................................................................................................        133
             G.2.14          Selection type ....................................................................................................................           135
             G.2.16          Embedded-pdv ..................................................................................................................               136
             G.2.17          External .............................................................................................................................        136
             G.2.18          Instance-of .........................................................................................................................         136
             G.2.19          Object identifier ................................................................................................................            137
             G.2.20          OID internationalized resource identifier ..........................................................................                          137
             G.2.21          Relative object identifier ...................................................................................................                137
     G.3     Value notation and property settings (TIME type and useful time types) ...........................................                                            137
             G.3.1           Date ...................................................................................................................................      137
             G.3.2           Time of day .......................................................................................................................           138
             G.3.3           Date and time of day .........................................................................................................                138
             G.3.4           Time interval .....................................................................................................................           139
             G.3.5           Recurring interval..............................................................................................................              140
     G.4     Identifying abstract syntaxes ...............................................................................................................                 140
     G.5     Subtypes ..............................................................................................................................................       141
     H.1     Character string support in ASN.1 ......................................................................................................                      145
     H.2     The UniversalString, UTF8String and BMPString types ....................................................................                                      145
     H.3     On ISO/IEC 10646 conformance requirements ..................................................................................                                  146
     H.4     Recommendations for ASN.1 users on ISO/IEC 10646 conformance ................................................                                                 146
     H.5     Adopted subsets as parameters of the abstract syntax .........................................................................                                147
     H.6     The CHARACTER STRING type ......................................................................................................                              147
     I.1     Overview .............................................................................................................................................        148
     I.2     Meaning of version numbers ...............................................................................................................                    149
     I.3     Requirements on encoding rules .........................................................................................................                      150
     I.4     Combination of (possibly extensible) constraints ...............................................................................                              150
             I.4.1           Model ................................................................................................................................        150
             I.4.2           Serial application of constraints ........................................................................................                    150
             I.4.3           Use of set arithmetic..........................................................................................................               151
             I.4.4           Use of the Contained Subtype notation .............................................................................                           152
     J.1     The collections of ASN.1 types for times and dates............................................................................                                153
     J.2     ISO 8601 key concepts........................................................................................................................                 153
     J.3     Abstract values of the TIME type........................................................................................................                      154
     J.4     Time properties of the time abstract values.........................................................................................                          155
     J.5     Value notation .....................................................................................................................................          155


vi         Rec. ITU-T X.680 (02/2021)
J.6   Use of the ASN.1 subtype notation .....................................................................................................                    156
J.7   The property settings subtype notation ...............................................................................................                     156
K.1   General ................................................................................................................................................   158
K.2   Analyzing the full string......................................................................................................................            158
K.3   Analysis of a string containing an interval ..........................................................................................                     159
K.4   Analysis of a string containing a date .................................................................................................                   159
K.5   Analysis of a string containing a year .................................................................................................                   160
K.6   Analysis of a string containing a century ............................................................................................                     160
K.7   Analysis of a string containing a time .................................................................................................                   160
K.8   Analysis of a string containing a simple time .....................................................................................                        161




                                                                                                       Rec. ITU-T X.680 (02/2021)                                vii
Introduction
This Recommendation | International Standard presents a standard notation for the definition of data types and values.
A data type (or type for short) is a category of information (for example, numeric, textual, still image or video
information). A data value (or value for short) is an instance of such a type. This Recommendation | International
Standard defines several basic types and their corresponding values, and rules for combining them into more complex
types and values.
In some protocol architectures, each message is specified as the binary value of a sequence of octets. However,
standards-writers need to define quite complex data types to carry their messages, without concern for their binary
representation. In order to specify these data types, they require a notation that does not necessarily determine the
representation of each value. ASN.1 is such a notation. This notation is supplemented by the specification of one or
more algorithms called encoding rules that determine the value of the octets that carry the application semantics (called
the transfer syntax). Rec. ITU-T X.690 | ISO/IEC 8825-1, Rec. ITU-T X.691 | ISO/IEC 8825-2 and Rec. ITU-T X.693 |
ISO/IEC 8825-4 specify three families of standardized encoding rules, called Basic Encoding Rules (BER), Packed
Encoding Rules (PER), and XML Encoding Rules (XER).
Some users wish to redefine their legacy protocols using ASN.1, but cannot use standardized encoding rules because
they need to retain their existing binary representations. Other users wish to have more complete control over the exact
layout of the bits on the wire (the transfer syntax). These requirements are addressed by Rec. ITU-T X.692 |
ISO/IEC 8825-3 which specifies an Encoding Control Notation (ECN) for ASN.1. ECN enables designers to formally
specify the abstract syntax of a protocol using ASN.1, but to then (if they so wish) take complete or partial control of
the bits on the wire by writing an accompanying ECN specification (which may reference standardized Encoding Rules
for some parts of the encoding).
A very general technique for defining a complicated type at the abstract level is to define a small number of simple
types by defining all possible values of the simple types, then combining these simple types in various ways. Some of
the ways of defining new types are as follows:
          a)   given an (ordered) list of existing types, a value can be formed as an (ordered) sequence of values, one
               from each of the existing types; the collection of all possible values obtained in this way is a new type (if
               the existing types in the list are all distinct, this mechanism can be extended to allow omission of some
               values from the list);
          b)   given an unordered set of (distinct) existing types, a value can be formed as an (unordered) set of values,
               one from each of the existing types; the collection of all possible unordered sets of values obtained in this
               way is a new type (the mechanism can again be extended to allow omission of some values);
          c)   given a single existing type, a value can be formed as an (ordered) list or (unordered) set of zero, one or
               more values of the existing type; the collection of all possible lists or sets of values obtained in this way
               is a new type;
          d)   given a list of (distinct) types, a value can be chosen from any one of them; the set of all possible values
               obtained in this way is a new type;
          e)   given a type, a new type can be formed as a subset of it by using some structure or order relationship
               among the values.
An important aspect of combining types in this way is that encoding rules should recognize the combining constructs,
providing unambiguous encodings of the collection of values of the basic types. Thus, every basic type defined using
the notation specified in this Recommendation | International Standard is assigned a tag to aid in the unambiguous
encoding of values.
Tags are mainly intended for machine use, and are not essential for the human notation defined in this Recommendation
| International Standard. Where, however, it is necessary to require that certain types be distinct, this is expressed by
requiring that they have distinct tags. The allocation of tags is therefore an important part of the use of this notation, but
(since 1994) it is possible to specify the automatic allocation of tags.
   NOTE 1 – Within this Recommendation | International Standard, tag values are assigned to all simple types and construction
   mechanisms. The restrictions placed on the use of the notation ensure that tags can be used in transfer for unambiguous
   identification of values.

It is also possible to assign encoding instructions to a type in order to affect the encoding of that type. This can be done
either by a type prefix placed before a type definition or use of a type reference, or by an encoding control section
placed at the end of an ASN.1 module. The generic syntax of type prefixes and encoding control sections is specified in
this Recommendation | International Standard, and includes an encoding reference to identify the encoding rules that are
modified by the encoding instruction. The semantics and detailed syntax of encoding instructions are specified in the
encoding rules Recommendation | International Standard identified by the encoding reference.


viii       Rec. ITU-T X.680 (02/2021)
An ASN.1 specification will initially be produced with a set of fully defined ASN.1 types. At a later stage, however, it
may be necessary to change those types (usually by the addition of extra components in a sequence or set type). If this is
to be possible in such a way that implementations using the old type definitions can interwork with implementations
using the new type definitions in a defined way, encoding rules need to provide appropriate support. The ASN.1
notation supports the inclusion of an extension marker on a number of types. This signals to encoding rules the intention
of the designer that this type is one of a series of related types (i.e., versions of the same initial type) called an extension
series, and that the encoding rules are required to enable information transfer between implementations using different
types that are related by being part of the same extension series.
Clauses 11 to 33 (inclusive) define the simple types supported by ASN.1, and specify the notation to be used for
referencing simple types and for defining new types using them. Clauses 11 to 33 also specify notations to be used for
specifying values of types defined using ASN.1. Two value notations are provided. The first is called the basic ASN.1
value notation, and has been part of the ASN.1 notation since its first introduction. The second is called the XML
ASN.1 Value Notation, and provides a value notation using Extensible Markup Language (XML).
   NOTE 2 – The XML Value Notation provides a means of representing ASN.1 values using XML. Thus, an ASN.1 type
   definition also specifies the structure and content of an XML element. This makes ASN.1 a simple schema language for XML.

Clauses 36 to 37 (inclusive) define the types supported by ASN.1 for carrying within them the complete encoding
of ASN.1 types.
Clause 38 and Annex B define the types that provide support for ISO 8601.
Clauses 39 to 44 (inclusive) define the character string types.
Clauses 45 to 48 (inclusive) define certain types which are considered to be of general utility, but which require no
additional encoding rules.
Clauses 49 to 51 (inclusive) define a notation which enables subtypes to be defined from the values of a parent type.
Clause 52 defines a notation which allows ASN.1 types specified in a "version 1" specification to be identified as likely
to be extended in "version 2", and for additions made in subsequent versions to be separately listed and identified with
their version number.
Clause 53 defines a notation which allows ASN.1 type definitions to contain an indication of the intended error
handling if encodings are received for values which lie outside those specified in the current standardized definition.
Annex A forms an integral part of this Recommendation | International Standard, and specifies ASN.1 regular
expressions.
Annex B forms an integral part of this Recommendation | International Standard, and defines an ASN.1 module
containing the definition of a set of time types providing the full functionality of ISO 8601. These types can be imported
from this ASN.1 module by an application designer if the useful time types specified in clause 38 are not adequate for
the application.
Annex C forms an integral part of this Recommendation | International Standard, and specifies rules for type and value
compatibility.
Annex D forms an integral part of this Recommendation | International Standard, and records object identifier and
object descriptor values assigned in the ASN.1 series of Recommendations | International Standards.
Annex E forms an integral part of this Recommendation | International Standard and specifies the currently defined
encoding references and the Recommendation | International Standard that defines the semantics and detailed syntax of
encoding instructions with those encoding references.
Annex F does not form an integral part of this Recommendation | International Standard, and references the
specification of the top-level arcs of the International Object Identifier tree and the use of that tree to form an OID
internationalized resource identifier which can be used as an IRI or URI registered as the "oid" scheme with IANA.
Annex G does not form an integral part of this Recommendation | International Standard, and provides examples and
hints on the use of the ASN.1 notation.
Annex H does not form an integral part of this Recommendation | International Standard, and provides a tutorial
on ASN.1 character strings.
Annex I does not form an integral part of this Recommendation | International Standard, and provides a tutorial on
the ASN.1 model of type extension.
Annex J does not form an integral part of this Recommendation | International Standard and provides a tutorial
introduction to ISO 8601 and to the TIME type. It is recommended that this be read before the normative text.



                                                                                  Rec. ITU-T X.680 (02/2021)                 ix
Annex K does not form an integral part of this Recommendation | International Standard and provides information on
how to identify the time properties of an abstract value from an instance of value notation.
Annex L does not form an integral part of this Recommendation | International Standard, and provides a summary
of ASN.1 using the notation of clause 5.




x         Rec. ITU-T X.680 (02/2021)
                                                                                                ISO/IEC 8824-1:2021 (E)

INTERNATIONAL STANDARD
ITU-T RECOMMENDATION

                                           Information technology –
                                     Abstract Syntax Notation One (ASN.1):
                                         Specification of basic notation


1           Scope
This Recommendation | International Standard provides a standard notation called Abstract Syntax Notation One
(ASN.1) that is used for the definition of data types, values, and constraints on data types.
This Recommendation | International Standard:
            –    defines a number of simple types, with their tags, and specifies a notation for referencing these types and
                 for specifying values of these types;
            –    defines mechanisms for constructing new types from more basic types, and specifies a notation for
                 defining such types and assigning them tags, and for specifying values of these types;
            –    defines character sets (by reference to other Recommendations and/or International Standards) for use
                 within ASN.1.
The ASN.1 notation can be applied whenever it is necessary to define the abstract syntax of information.
The ASN.1 notation is referenced by other standards which define encoding rules for the ASN.1 types.


2           Normative references
The following Recommendations and International Standards contain provisions which, through reference in this text,
constitute provisions of this Recommendation | International Standard. At the time of publication, the editions indicated
were valid. All Recommendations and Standards are subject to revision, and parties to agreements based on this
Recommendation | International Standard are encouraged to investigate the possibility of applying the most recent
edition of the Recommendations and Standards listed below. Members of IEC and ISO maintain registers of currently
valid International Standards. The Telecommunication Standardization Bureau of the ITU maintains a list of currently
valid ITU-T Recommendations.
      NOTE – This Recommendation | International Standard is based on ISO/IEC 10646:2003 and the Unicode standard version
      3.2.0:2002. It cannot be applied using later versions of these two standards.


2.1         Identical Recommendations | International Standards
            –    Recommendation ITU-T X.660 (2011) | ISO/IEC 9834-1:2012, Information technology – Open Systems
                 Interconnection – Procedures for the operation of OSI Registration Authorities: General procedures and
                 top arcs of the ASN.1 International Object Identifier tree.
            –    Recommendation ITU-T X.681 (2021) | ISO/IEC 8824-2:2021, Information technology – Abstract
                 Syntax Notation One (ASN.1): Information object specification.
            –    Recommendation ITU-T X.682 (2021) | ISO/IEC 8824-3:2021, Information technology – Abstract
                 Syntax Notation One (ASN.1): Constraint specification.
            –    Recommendation ITU-T X.683 (2021) | ISO/IEC 8824-4:2021, Information technology – Abstract
                 Syntax Notation One (ASN.1): Parameterization of ASN.1 specifications.
            –    Recommendation ITU-T X.690 (2021) | ISO/IEC 8825-1:2021, Information technology – ASN.1
                 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and
                 Distinguished Encoding Rules (DER).
            –    Recommendation ITU-T X.691 (2021) | ISO/IEC 8825-2:2021, Information technology – ASN.1
                 encoding rules: Specification of Packed Encoding Rules (PER).
            –    Recommendation ITU-T X.692 (2021) | ISO/IEC 8825-3:2021, Information technology – ASN.1
                 encoding rules: Specification of Encoding Control Notation (ECN).
            –    Recommendation ITU-T X.693 (2021) | ISO/IEC 8825-4:2021, Information technology – ASN.1
                 encoding rules: XML Encoding Rules (XER).




                                                                                Rec. ITU-T X.680 (02/2021)                1
ISO/IEC 8824-1:2021 (E)

            –     Recommendation ITU-T X.695 (2021) | ISO/IEC 8825-6:2021, Information technology – ASN.1
                  encoding rules: Registration and application of PER encoding instructions.
      NOTE – The references above shall be interpreted as references to the identified Recommendations | International Standards
      together with all their published amendments and technical corrigenda.


2.2         Additional references
            –     Recommendation ITU-R TF.460-6 (2002), Standard-frequency and time-signal emissions.
            –     CCITT Recommendation T.100 (1988), International information exchange for interactive Videotex.
            –     Recommendation ITU-T T.101 (1994), International interworking for Videotex services.
            –     ISO International Register of Coded Character Sets to be used with Escape Sequences.
            –     ISO/IEC 646:1991, Information technology – ISO 7-bit coded character set for information interchange.
            –     ISO/IEC 2022:1994, Information technology – Character code structure and extension techniques.
            –     ISO/IEC 6523:1998, Data interchange – Structures for the identification of organizations and
                  organization parts.
            –     ISO/IEC 7350:1991, Information technology – Registration of repertoires of graphic characters from
                  ISO/IEC 10367.
            –     ISO 8601:2019, Date and time – Representations for information interchange.
            –     ISO/IEC 10646:2003, Information technology – Universal Multiple-Octet Coded Character Set (UCS).
            –     The Unicode Standard, Version 3.2.0:2002. The Unicode Consortium. (Reading, MA, Addison-Wesley)
                     NOTE 1 – The above reference is included because it provides names for control characters and specifies
                     categories of characters.
            –     W3C XML 1.0:2008, Extensible Markup Language (XML) 1.0 (Fifth Edition), W3C Recommendation,
                  Copyright ©2008 W3C, (MIT, ERCIM, Keio), http://www.w3.org/TR/2008/REC-xml-20081126/.
      NOTE – The reference to a document within this Recommendation | International Standard does not give it, as a stand-alone
      document, the status of a Recommendation or International Standard.



3           Definitions
For the purposes of this Recommendation | International Standard, the following definitions apply.

3.1         International Object Identifier tree specification
This Recommendation | International Standard uses the following terms defined in Rec. ITU-T X.660 |
ISO/IEC 9834-1:
            a)    integer-valued Unicode label;
            b)    international object identifier tree;
            c)    OID internationalized resource identifier;
            d)    long arc;
            e)    object identifier;
            f)    primary integer value;
            g)    secondary identifier;
            h)    Unicode label.

3.2         Information object specification
This Recommendation | International Standard uses the following terms defined in Rec. ITU-T X.681 |
ISO/IEC 8824-2:
            a)    information object;
            b)    information object class;
            c)    information object set;
            d)    instance-of type;
            e)    object class field type.


2               Rec. ITU-T X.680 (02/2021)
                                                                                         ISO/IEC 8824-1:2021 (E)

3.3      Constraint specification
This Recommendation | International Standard uses the following terms defined in Rec. ITU-T X.682 |
ISO/IEC 8824-3:
         a)   component relation constraint;
         b)   table constraint.

3.4      Parameterization of ASN.1 specification
This Recommendation | International Standard uses the following terms defined in Rec. ITU-T X.683 |
ISO/IEC 8824-4:
         a)   parameterized type;
         b)   parameterized value.

3.5      Structure for identification of organizations
This Recommendation | International Standard uses the following terms defined in ISO/IEC 6523:
         a)   issuing organization;
         b)   organization code;
         c)   International Code Designator.

3.6      Universal Multiple-Octet Coded Character Set (UCS)
This Recommendation | International Standard uses the following terms defined in ISO/IEC 10646:
         a)   Basic Multilingual Plane (BMP);
         b)   cell;
         c)   combining character;
         d)   graphic symbol;
         e)   group;
         f)   limited subset;
         g)   plane;
         h)   row;
         i)   selected subset.

3.7      Representation of dates and times
This Recommendation | International Standard uses the following terms defined in ISO 8601:
         a)   basic format;
         b)   calendar date;
         c)   common year;
         d)   duration;
         e)   extended format;
         f)   Gregorian calendar;
         g)   instant;
         h)   leap second;
         i)   leap year;
         j)   local time of day;
         k)   ordinal date;
         l)   recurring time interval
         m) time axis;
         n)   time interval;
         o)   time;
         p)   time-scale;
         q)   UTC;


                                                                          Rec. ITU-T X.680 (02/2021)          3
ISO/IEC 8824-1:2021 (E)

            r)    week date.

3.8         Additional definitions
3.8.1       abstract character: An abstract value which is used for the organization, control or representation of textual
data.
      NOTE – Annex H provides a more complete description of the term abstract character.

3.8.2    abstract value: A value whose definition is based only on the type used to carry some semantics,
independently of how it is represented in any encoding.
      NOTE – Examples of abstract values are the values of the integer type, the boolean type, a character string type, or of a type
      which is a sequence (or a choice) of an integer and a boolean.

3.8.3     additional time type: A type defined as a subtype of the time type (see 3.8.83) by applying the property
setting subtype notation to the time type or to a useful or defined time type.
3.8.4       ASN.1 character set: The set of characters, specified in clause 11, used in the ASN.1 notation.
3.8.5       ASN.1 specification: A collection of one or more ASN.1 modules.
3.8.6       associated type: A type which is used only for defining the value and subtype notation for a type.
      NOTE – Associated types are defined in this Recommendation | International Standard when it is necessary to make it clear that
      there may be a significant difference between how the type is defined in ASN.1 and how it is encoded. Associated types do not
      appear in user specifications.

3.8.7       bitstring type: A simple type whose distinguished values are an ordered sequence of zero, one or more bits.
      NOTE – Where there is a need to carry embedded encodings of an abstract value, the use of a bitstring (or an octetstring) type
      without a contents constraint (see Rec. ITU-T X.682 | ISO/IEC 8824-3, clause 11) is deprecated. Otherwise, the use of the
      embedded-pdv type (see clause 36) provides a more flexible mechanism, allowing the announcement of the abstract syntax and
      of the encoding of the abstract value that is embedded.

3.8.8       boolean type: A simple type with two distinguished values.
3.8.9       character property: The set of information associated with a cell in a table defining a character repertoire.
      NOTE – The information will normally include some or all of the following items:
              a) a graphic symbol;
              b) a character name;
              c) the definition of functions associated with the character when used in particular environments;
              d) whether it represents a digit;
              e) an associated character differing only in (upper/lower) case.

3.8.10 character abstract syntax: Any abstract syntax whose values are specified as the set of character strings of
zero, one or more characters from some specified collection of characters.
3.8.11 character repertoire: The characters in a character set without any implication on how such characters are
encoded.
3.8.12      character string types: Simple types whose values are strings of characters from some defined character set.
3.8.13      character transfer syntax: Any transfer syntax for a character abstract syntax.
3.8.14 choice types: Types defined by referencing a list of distinct types; each value of the choice type is derived
from the value of one of the component types.
3.8.15      component type: One of the types referenced when defining a CHOICE, SET, SEQUENCE, SET OF, or
SEQUENCE OF.

3.8.16      constraint: A notation which can be used in association with a type, to define a subtype of that type.
3.8.17 contents constraint: A constraint on a bit string or octet string type that specifies either that the contents are
to be an encoding of a specified ASN.1 type, or that specified procedures are to be used to produce and process the
contents.
3.8.18 control characters: Characters appearing in some character repertoires that have been given a name (and
perhaps a defined function in relation to certain environments) but which have not been assigned a graphic symbol, and
which are not spacing characters.
      NOTE – HORIZONTAL TABULATION (9) and LINE FEED (10) are examples of control characters that have been assigned a
      formatting function in a printing environment. DATA LINK ESCAPE (16) is an example of a control character that has been
      assigned a function in a communication environment.



4             Rec. ITU-T X.680 (02/2021)
                                                                                                        ISO/IEC 8824-1:2021 (E)

3.8.19 Coordinated Universal Time (UTC): The time scale maintained by the Bureau International de l'Heure
(International Time Bureau) that forms the basis of a coordinated dissemination of standard frequencies and time
signals.
   NOTE 1 – The source of this definition is Rec. ITU-R TF.460-5. ITU-R has also defined the acronym for Coordinated Universal
   Time as UTC.
   NOTE 2 – UTC and Greenwich Mean Time (GMT) are two alternative time standards which for most practical purposes
   determine the same time.

3.8.20 default encoding reference (for a module): An encoding reference that is specified in the module header and
is assumed in all type prefixes which do not contain an encoding reference.
   NOTE – If a default encoding reference is not specified in the module header, then all type prefixes which do not contain an
   encoding reference are assigning tags.

3.8.21 defined time type: A type defined in Annex B as a subtype of the time type (see 3.8.83) that is intended for
importation by application designers when needed for their application.
3.8.22 element: A value of a governing type or an information object of a governing information object class,
distinguable from all other values of the same type or information objects of the same class, respectively.
3.8.23 element set: A set of elements, all of which are values of a governing type, or information objects of a
governing class.
   NOTE – Governing class is defined in Rec. ITU-T X.681 | ISO/IEC 8824-2, 3.4.7.

3.8.24 embedded-pdv type: A type whose set of values is formally the union of the sets of values in all possible
abstract syntaxes. This type can be used in an ASN.1 specification that wishes to carry in its protocol an abstract value
whose type may be defined externally to that ASN.1 specification. It carries an identification of the abstract syntax
(the type) of the abstract value being carried, as well as an identification of the encoding rules used to encode that
abstract value.
3.8.25    encoding: The bit-pattern resulting from the application of a set of encoding rules to an abstract value.
3.8.26 encoding control section: Part of an ASN.1 module that enables encoding instructions to be assigned to types
defined or used within that ASN.1 module.
3.8.27 encoding instruction: Information which can be associated with a type using a type prefix or an encoding
control section, and which affects the encoding of that type by one or more ASN.1 encoding rules.
   NOTE – An encoding instruction does not affect the abstract values of a type, and is not expected to be visible to an application.

3.8.28 encoding reference: A name (see Annex E) that identifies which encoding rules are affected by an encoding
instruction in a type prefix or an encoding control section.
   NOTE – The encoding reference TAG can be used to specify that a type prefix is assigning a tag rather than an encoding
   instruction (see 31.2).

3.8.29 (ASN.1) encoding rules: Rules which specify the representation during transfer of the values of ASN.1
types. Encoding rules also enable the values to be recovered from the representation, given knowledge of the type.
   NOTE – For the purpose of specifying encoding rules, the various referenced type (and value) notations, which can provide
   alternative notations for built-in types (and values), are not relevant.

3.8.30    enumerated types: Simple types whose values are given distinct identifiers as part of the type notation.
3.8.31 extension addition: One of the added notations in an extension series. For set, sequence and choice types, each
extension addition is the addition of either a single extension addition group or a single component type. For enumerated
types it is the addition of a single further enumeration. For a constraint it is the addition of (only) one subtype element.
   NOTE – Extension additions are both textually ordered (following the extension marker) and logically ordered (having
   increasing enumeration values, and, in the case of CHOICE alternatives, increasing tags).
3.8.32 extension addition group: One or more components of a set, sequence or choice type grouped within version
brackets. An extension addition group is used to clearly identify the components of a set, sequence or choice type that were
added in a particular version of an ASN.1 module, and can identify that version with a simple integer.
3.8.33 extension addition type: A type contained within an extension addition group or a single component type that
is itself an extension addition (in such a case it is not contained within an extension addition group).
3.8.34 extensible constraint: A subtype constraint with an extension marker at the outer level, or that is extensible
through the use of set arithmetic with extensible sets of values.
3.8.35 extension insertion point (or insertion point): The location within a type definition where extension additions
are inserted. This location is the end of the type notation of the immediately preceding type in the extension series if there
is a single ellipsis in the type definition, or immediately before the second ellipsis if there is an extension marker pair in the
definition of the type.



                                                                                      Rec. ITU-T X.680 (02/2021)                        5
ISO/IEC 8824-1:2021 (E)

    NOTE – There can be at most one insertion point within the components of any choice, sequence, or set type.

3.8.36     extension marker: A syntactic flag (an ellipsis) that is included in all types that form part of an extension
series.
3.8.37     extension marker pair: A pair of extension markers between which extension additions are inserted.
3.8.38 extension-related: Two types that have the same extension root, where one was created by adding zero or
more extension additions to the other.
3.8.39 extension root: An extensible type that is the first type in an extension series. It carries either the extension
marker with no additional notation other than comments and white-space between the extension marker and the matching
"}" or ")", or an extension marker pair with no additional notation other than a single comma, comments and white-space
between the extension markers.
    NOTE – Only an extension root can be the first type in an extension series.
3.8.40 extension series: A series of ASN.1 types which can be ordered in such a way that each successive type in the
series is formed by the addition of text at the extension insertion point.
3.8.41     extensible type: A type with an extension marker, or to which an extensible constraint has been applied.
    NOTE – An extension marker can be textually present or can be inserted by an EXTENSIBILITY-IMPLIED (see 13.4).

3.8.42 external reference: A type reference, value reference, information object class reference, information object
reference, or information object set reference (which may be parameterized), that is defined in some other module than
the one in which it is being referenced, and which is being referred to by prefixing the module name to the referenced
item.
           EXAMPLE – ModuleName.TypeReference
3.8.43 external type: A type which is a part of an ASN.1 specification that carries a value whose type may be
defined externally to that ASN.1 specification. It also carries an identification of the type of the value being carried.
3.8.44     false: One of the distinguished values of the boolean type (see also "true").
3.8.45 governing (type); governor: A type definition or reference which affects the interpretation of a part of the
ASN.1 syntax, requiring that part of the ASN.1 syntax to reference values in the governing type.
3.8.46 identical type definitions: Two instances of the ASN.1 "Type" production (see clause 17) are defined as
identical type definitions if, after performing the transformations specified in Annex C, they are identical ordered lists
of identical lexical items (see clause 12).
3.8.47     OID internationalized resource identifier type: The set of all OID internationalized resource identifiers.
    NOTE 1 – This is a simple type whose values are a sequence of Unicode labels that identify a series of arcs leading from the root
    to a node of the International Object Identifier tree, as specified by the Rec. ITU-T X.660 | ISO/IEC 9834-series.
    NOTE 2 – The rules of Rec. ITU-T X.660 | ISO/IEC 9834-1 permit a wide range of authorities to independently associate
    Unicode labels with an arc of the tree.

3.8.48 integer type: A simple type with distinguished values which are the positive and negative whole numbers,
including zero (as a single value).
    NOTE – When particular encoding rules limit the range of an integer, such limitations are chosen so as not to affect any user
    of ASN.1.

3.8.49 lexical item: A named sequence of characters from the ASN.1 character set, specified in clause 12, which is
used in forming the ASN.1 notation.
3.8.50 module: One or more instances of the use of the ASN.1 notation for type, value, value set, information
object class, information object, and information object set (as well as the parameterized variant of those), encapsulated
using the ASN.1 module notation (see clause 13).
    NOTE – The terms information object class (etc.) are specified in Rec. ITU-T X.681 | ISO/IEC 8824-2, and parameterization is
    specified in Rec. ITU-T X.683 | ISO/IEC 8824-4.

3.8.51     null type: A simple type consisting of a single value, also called null.
3.8.52 object: A well-defined piece of information, definition, or specification which requires a name in order to
identify its use in an instance of communication.
    NOTE – Such an object may be an information object as defined in Rec. ITU-T X.681 | ISO/IEC 8824-2.

3.8.53 object descriptor type: A type whose distinguished values are human-readable text providing a brief
description of an object (see 3.8.52).
    NOTE – An object descriptor value is usually associated with a single object. Only an object identifier value unambiguously
    identifies an object.



6           Rec. ITU-T X.680 (02/2021)
                                                                                                          ISO/IEC 8824-1:2021 (E)

3.8.54 object identifier type: A simple type whose values are a sequence of primary integer values that identify a
series of arcs leading from the root to a node of the International Object Identifier tree, as specified by the Rec. ITU-T
X.660 | ISO/IEC 9834 series.
   NOTE 1 – The rules of Rec. ITU-T X.660 | ISO/IEC 9834-1 permit a wide range of authorities to independently associate a
   primary integer value with an arc of the tree.
   NOTE 2 – In the value notation for the object identifier type (and in XML encodings of that type) it is possible to include
   secondary identifiers for arcs.

3.8.55 octetstring type: A simple type whose distinguished values are an ordered sequence of zero, one or more
octets, each octet being an ordered sequence of eight bits.
3.8.56 open systems interconnection: An architecture for computer communication which provides a number of
terms which are used in this Recommendation | International Standard preceded by the abbreviation "OSI".
   NOTE – The meaning of such terms can be obtained from the Rec. ITU-T X.200 series and equivalent ISO/IEC Standards if
   needed. The terms are only applicable if ASN.1 is used in an OSI environment.

3.8.57    open type notation: An ASN.1 notation used to denote a set of values from more than one ASN.1 type.
   NOTE 1 – The term "open type" is used synonymously with "open type notation" in the body of this Recommendation |
   International Standard.
   NOTE 2 – All ASN.1 encoding rules provide unambiguous encodings for the values of a single ASN.1 type. They do not
   necessarily provide unambiguous encodings for "open type notation", which carries values from ASN.1 types that are not
   normally determined at specification time. Knowledge of the type of the value being encoded in the "open type notation" is
   needed before the abstract value for that field can be unambiguously determined.
   NOTE 3 – The only notation in this Recommendation | International Standard which is an open type notation is the
   "ObjectClassFieldType" specified in Rec. ITU-T X.681 | ISO/IEC 8824-2, clause 14, where the "FieldName" denotes either a
   type field or a variable-type value field.

3.8.58 parent type (of a subtype): The type that is being constrained when defining a subtype, and which governs
the subtype notation.
   NOTE – The parent type may itself be a subtype of some other type.

3.8.59 production: A part of the formal notation (also called grammar or Backus-Naur Form, BNF) used to specify
ASN.1.
3.8.60 real type: A simple type whose distinguished values (specified in clause 21) include the set of real numbers
(numerical real numbers) together with special values such as NOT-A-NUMBER.
3.8.61 recursive definition (of a type): A set of ASN.1 definitions which cannot be reordered so that all types used
in a construction are defined before the definition of the construction.
   NOTE – Recursive definitions are allowed in ASN.1: the user of the notation has the responsibility for ensuring that those values
   (of the resulting types) which are used have a finite representation and that the value set associated with the type contains at least
   one value.

3.8.62 relative OID internationalized resource identifier type: A value which identifies an object by its position
relative to some known OID internationalized resource identifier.
3.8.63 relative object identifier: A value which identifies an object by its position relative to some known object
identifier.
3.8.64 relative object identifier type: A simple type whose values are the set of all possible relative object
identifiers.
3.8.65 restricted character string type: A character string type whose characters are taken from a fixed character
repertoire identified in the type specification.
3.8.66 selection types: Types defined by reference to a component type of a choice type, and whose values are
precisely the values of that component type.
3.8.67 sequence types: Types defined by referencing a fixed, ordered list of types (some of which may be declared
to be optional); each value of the sequence type is an ordered list of values, one from each component type.
   NOTE – Where a component type is declared to be optional, a value of the sequence type need not contain a value of that
   component type.

3.8.68 sequence-of types: Types defined by referencing a single component type; each value in the sequence-of
type is an ordered list of zero, one or more values of the component type.
3.8.69 serial application (of constraints): The application of a constraint to a parent type which is already
constrained.



                                                                                       Rec. ITU-T X.680 (02/2021)                      7
ISO/IEC 8824-1:2021 (E)

3.8.70 set arithmetic: The formation of new sets of values or information objects using the operations of union,
intersection and set difference (use of EXCEPT) as specified in 50.2.
    NOTE – The result of serial application of constraints is not covered by the term "set arithmetic".

3.8.71 setting (of a time property): One of a number of values that can be associated with a given time property
(see 3.8.82 and the note in J.4.2).
    NOTE – Any time property that applies to a particular time abstract value has only a single setting (see Table 6).

3.8.72 set types: Types defined by referencing a fixed, unordered, list of types (some of which may be declared to
be optional); each value in the set type is an unordered list of values, one from each component type.
    NOTE – Where a component type is declared to be optional, a value of the set type need not contain a value of that component
    type.

3.8.73 set-of types: Types defined by referencing a single component type; each value in the set-of type is an
unordered list of zero, one or more values of the component type.
3.8.74     simple types: Types defined by directly specifying the set of their values.
3.8.75 spacing character: A character in a character repertoire which is intended for inclusion with graphic
characters in the printing of a character string but which is represented in the physical rendition by empty space; it is not
normally considered to be a control character (see 3.8.18).
    NOTE – There may be a single spacing character in the character repertoire, or there may be multiple spacing characters with
    varying widths.

3.8.76 subtype (of a parent type): A type whose values are a subset (or the complete set) of the values of some
other type (the parent type).
3.8.77 tag: Additional information, separate from the abstract values of the type, which is associated with every
ASN.1 type and which can be changed or augmented by a type prefix.
    NOTE – Tag information is used in some encoding rules to ensure that encodings are not ambiguous. Tag information differs
    from encoding instructions because tag information is associated with all ASN.1 types, even if they do not have a type prefix.

3.8.78 tagged types: A type defined by referencing a single existing type and a tag; the new type is isomorphic to
the existing type, but is distinct from it.
3.8.79     tagging: Assigning a new tag to a type, replacing or adding to the existing (possibly the default) tag.
3.8.80     time abstract value: An abstract value of the time type.
3.8.81     time component: Part of the definition of a time abstract value that specifies a part of that abstract value.
    NOTE – Examples of time components are a date component (that would have a year component), a time-of-day component, or a
    time difference component.

3.8.82 time property (of a time abstract value): One of a number of terms used to describe a time abstract value
(see 3.8.80).
    NOTE – The time properties that can be used to describe a time abstract value often depend on the setting of some other time
    property of that abstract value. The time properties are listed in Table 6, column 1.

3.8.83     time type: The TIME type that supports all the abstract values implicitly defined by ISO 8601.
3.8.84 transfer syntax: The set of bit strings used to exchange the abstract values in an abstract syntax, usually
obtained by application of encoding rules to an abstract syntax.
    NOTE – The term "transfer syntax" is synonymous with "encoding".

3.8.85     true: One of the distinguished values of the boolean type (see also "false").
3.8.86     type: A named set of values.
3.8.87     type prefix: Part of the ASN.1 notation that can be used to assign an encoding instruction or a tag to a type.
3.8.88     type reference name: A name associated uniquely with a type within some context.
    NOTE – Reference names are assigned to the types defined in this Recommendation | International Standard; these are
    universally available within ASN.1. Other reference names are defined in other Recommendations | International Standards, and
    are applicable only in the context of that Recommendation | International Standard.

3.8.89 unrestricted character string type: A type whose abstract values are values from a character abstract
syntax, together with an identification of the character abstract syntax and of the character transfer syntax to be used in
its encoding.
3.8.90 useful time type: A built-in type defined as a subtype of the time type (see 3.8.83) that is intended for direct
use by application designers.


8           Rec. ITU-T X.680 (02/2021)
                                                                                                   ISO/IEC 8824-1:2021 (E)

3.8.91 user (of ASN.1): The individual or organization that defines the abstract syntax of a particular piece of
information using ASN.1.
3.8.92 value mapping: A 1-1 relationship between values in two types that enables a reference to one of those
values to be used as a reference to the other value. This can, for example, be used in specifying subtypes and default
values (see Annex C).
3.8.93      value reference name: A name associated uniquely with a value within some context.
3.8.94      value set: A collection of values of a type. Semantically equivalent to a subtype.
3.8.95 version brackets: A pair of adjacent left and right brackets ("[[" or "]]") used to delineate the start and end of
an extension addition group. The pair of left brackets can optionally be followed by a number giving a version number for
the extension addition group.
3.8.96      version number: A number which can be associated with a version bracket (see I.1.8).
      NOTE – A version number cannot be added to an extension addition which is not part of an extension addition group, nor to
      extension additions to any type other than choice, sequence, or set.

3.8.97      white-space: Any formatting action that yields a space on a printed page, such as spaces or tabs.


4           Abbreviations
For the purposes of this Recommendation | International Standard, the following abbreviations apply:
            ASN.1     Abstract Syntax Notation One
            BER       Basic Encoding Rules of ASN.1
            BMP       Basic Multilingual Plane
            DCC       Data Country Code
            DNIC      Data Network Identification Code
            ECN       Encoding Control Notation of ASN.1
            ICD       International Code Designator
            IRI       Internationalized Resource Identifier
            OID       Object Identifier
            OSI       Open Systems Interconnection
            PER       Packed Encoding Rules of ASN.1
            ROA       Recognized Operating Agency
            UCS       Universal Multiple-Octet Coded Character Set
            URI       Universal Resource Identifier
            UTC       Coordinated Universal Time
            XML       Extensible Markup Language


5           Notation

5.1         General
5.1.1       The ASN.1 notation consists of a sequence of characters from the ASN.1 character set specified in clause 11.
5.1.2    Each use of the ASN.1 notation contains characters from the ASN.1 character set grouped into lexical items.
Clause 12 specifies all the sequences of characters forming lexical items, and names each item.
5.1.3    The ASN.1 notation is specified in clause 13 (and following clauses) by specifying and naming those
sequences of lexical items which form valid instances of the ASN.1 notation, and by specifying the ASN.1 semantics of
each sequence.
5.1.4     In order to specify the permitted sequences of lexical items, this Recommendation | International Standard
uses a formal notation defined in the following subclauses.




                                                                                  Rec. ITU-T X.680 (02/2021)                 9
ISO/IEC 8824-1:2021 (E)

5.2         Productions
5.2.1       All lexical items are named (see clause 12), and permitted sequences of lexical items are named.
5.2.2      A new (more complex) permitted sequence of lexical items is defined by means of a production. This uses
the names of lexical items and of permitted sequences of lexical items and forms a new named permitted sequence of
lexical items.
5.2.3       Each production consists of the following parts, on one or several lines, in order:
            a)    a name for the new permitted sequence of lexical items;
            b)    the characters
                               ::=
            c)    one or more alternative sequences of lexical items, as defined in 5.3, separated by the character
                               |
5.2.4     A sequence of lexical items is present in the new permitted sequence of lexical items if it is present in one or
more of the alternatives. The new permitted sequence of lexical items is referenced in this Recommendation |
International Standard by the name in 5.2.3 a) above.
      NOTE – If the same sequence of lexical items appears in more than one alternative, any semantic ambiguity in the resulting
      notation is resolved by associated text.


5.3         The alternative collections
5.3.1      Each alternative in a production (see 5.2.3.c) is specified by a list of names. Each name is either the name of a
lexical item, or is the name of a permitted sequence of lexical items defined and named by some other production.
5.3.2      The permitted sequence of lexical items defined by each alternative consists of all sequences obtained by
taking any one of the sequences (or the lexical item) associated with the first name, in combination with (and followed
by) any one of the sequences (or lexical item) associated with the second name, in combination with (and followed by)
any one of the sequences (or lexical item) associated with the third name, and so on up to and including the last name
(or lexical item) in the alternative.

5.4         Non-spacing indicator
If the non-spacing indicator "&" (AMPERSAND) is inserted between these items in production sequences, then the
lexical item that precedes it and the lexical item that follows it shall not be separated by white-space.
      NOTE – This indicator is only used in productions that describe the XML value notation. For example, it is used to specify that
      the lexical item "<" is to be immediately followed by an XML tag name.


5.5         Example of a production
5.5.1       The production:
                  ExampleProduction         ::=
                     bstring
                  |  hstring
                  |  "{" IdentifierList "}"
associates the name "ExampleProduction" with the following sequences of lexical items:
            a)    any "bstring" (a lexical item); or
            b)    any "hstring" (a lexical item); or
            c)    any sequence of lexical items associated with "IdentifierList", preceded by a "{" and followed by a "}".
                      NOTE – "{" and "}" are the names of lexical items containing the single characters { and } (see 12.37).

5.5.2    In this example, "IdentifierList" would be defined by a further production, either before or after the
production defining "ExampleProduction".

5.6         Layout
Each production used in this Recommendation | International Standard is preceded and followed by an empty line.
Empty lines do not appear within productions. The production may be on a single line, or may be spread over several
lines. Layout is not significant.


10            Rec. ITU-T X.680 (02/2021)
                                                                                                       ISO/IEC 8824-1:2021 (E)

5.7         Recursion
The productions in this Recommendation | International Standard are frequently recursive. In this case the productions
are to be continuously reapplied until no new sequences are generated.
      NOTE – In many cases, such reapplication results in an infinite set of permitted sequences of lexical items. Some or all of the
      sequences in the set may themselves contain an unbounded number of lexical items. This is not an error.


5.8         References to permitted sequences of lexical items
This Recommendation | International Standard references a permitted sequence of lexical items (part of the ASN.1
notation) by referencing the name that appears before the "::=" in a production; the name is surrounded by the
QUOTATION MARK (34) character (") to distinguish it from natural language text, unless it appears as part of a
production.

5.9         References to a lexical item
This Recommendation | International Standard references a lexical item by using the name of the lexical item; when the
name appears in natural language text, and could be confused with such text, then it is surrounded by the QUOTATION
MARK (34) character (").

5.10        Short-hand notations
In order to make productions more concise and more readable, the following short-hand notations are used in the
definition of permitted sequences of lexical items in this Recommendation | International Standard and also in Rec.
ITU-T X.681 | ISO/IEC 8824-2, Rec. ITU-T X.682 | ISO/IEC 8824-3 and Rec. ITU-T X.683 | ISO/IEC 8824-4:
            a)    An asterisk (*) following two names, "A" and "B", denotes the "empty" lexical item (see 12.7), or one of
                  the permitted sequences of lexical items associated with "A", or an alternating series of one of the
                  sequences of lexical items associated with "A" and one of the sequences of lexical items associated with
                  "B", both starting and finishing with one associated with "A". Thus:
                       C ::= A B *
                  is equivalent to:
                       C ::= D | empty
                       D ::= A | A B D
                  "D" being an auxiliary name not appearing elsewhere in the productions.
                  EXAMPLE – "C ::= A B *" is the shorthand notation for the following alternatives of C:
                       empty
                       A
                       ABA
                       ABABA
                       ABABABA
                       ...
            b)    A plus sign (+) is similar to the asterisk in a), except that the "empty" lexical item is excluded. Thus:
                       E ::= A B +
                  is equivalent to:
                       E ::= A | A B E
                  EXAMPLE – "E ::= A B +" is the shorthand notation for the following alternatives of E:
                       A
                       ABA
                       ABABA
                       ABABABA
                       ...
            c)    A question mark (?) following a name denotes either the "empty" lexical item (see 12.7) or a permitted
                  sequence of lexical items associated with "A". Thus:
                       F ::= A ?




                                                                                      Rec. ITU-T X.680 (02/2021)                  11
ISO/IEC 8824-1:2021 (E)

                 is equivalent to:
                      F ::= empty | A
     NOTE – These short-hand notations take precedence over the juxtaposition of lexical items in production sequences (see 5.2.2).


5.11       Value references and the typing of values
5.11.1 The ASN.1 value assignment notation enables a name to be given to a value of a specified type. This name
can be used wherever a reference to that value is needed. Annex C describes and specifies the value mapping
mechanism that allows a value reference name for a value of one type to identify a value of a second (similar) type.
Thus, a reference to the first value can be used wherever a reference to a value in the second type is required.
5.11.2 In the body of the ASN.1 standards normal English text is used to specify legality (or otherwise) of constructs
where more than one type is involved. These legality specifications generally require that two or more types be
"compatible". For example, the type used in defining a value reference is required to be "compatible with" the
governing type when the value reference is used. The normative Annex C uses the value mapping concept to give a
precise statement about whether any given ASN.1 construct is legal or not.


6          The ASN.1 model of type extension
When decoding an extensible type, a decoder may detect:
           a)    the absence of expected extension additions in a sequence or set type; or
           b)    the presence of arbitrary unexpected extension additions above those defined (if any) in a sequence or set
                 type, or of an unknown alternative in a choice type, or an unknown enumeration in an enumerated type,
                 or of an unexpected length or value of a type whose constraint is extensible.
In formal terms, an abstract syntax defined by the extensible type X contains not only the values of type X, but also the
values of all types that are extension-related to X. Thus, the decoding process never signals an error when either of the
above situations (a or b) is detected. The action that is taken in each situation is determined by the ASN.1 specifier.
     NOTE – Frequently the action will be to ignore the presence of unexpected additional extensions, and to use a default value or a
     "missing" indicator for expected extension additions that are absent.

Unexpected extension additions detected by a decoder in an extensible type can later be included in a subsequent
encoding of that type (for transmission back to the sender, or to some third party), provided that the same transfer
syntax is used on the subsequent transmission.


7          Extensibility requirements on encoding rules
     NOTE – These requirements apply to standardized encoding rules. They do not apply to encoding rules defined using ECN (see
     Rec. ITU-T X.692 | ISO/IEC 8825-3).

7.1       All ASN.1 encoding rules shall allow the encoding of values of an extensible type X in such a way that they
can be decoded using an extensible type Y that is extension-related to X. Further, the encoding rules shall allow the
values that were decoded using Y to be re-encoded (using Y) and decoded using a third extensible type Z that is
extension related to Y (and hence X also).
     NOTE – Types X, Y and Z may appear in any order in the extension series.

If a value of an extensible type X is encoded and then relayed (directly or through a relaying application using
extension-related type Z) to another application that decodes the value using extensible type Y that is extension-related
to X, then the decoder using type Y obtains an abstract value composed of:
           a)    an abstract value of the extension root type;
           b)    an abstract value of each extension addition that is present in both X and Y;
           c)    delimited encoding for each extension addition (if any) that is in X but not in Y.
The encodings in c) shall be capable of being included in a later encoding of a value of Y, if so required by the
application. That encoding shall be a valid encoding of a value of X.
Tutorial example: If system A is using an extensible root type (type X) that is a sequence type or a set type with an
extension addition of an optional integer type, while system B is using an extension-related type (type Y) that has two
extension additions where each is an optional integer type, then transmission by B of a value of Y which omits the
integer value of the first extension addition and includes the second must not be confused by A with the presence of the
first (only) extension addition of X that it knows about. Moreover, A must be able to re-encode the value of X with a


12           Rec. ITU-T X.680 (02/2021)
                                                                                                           ISO/IEC 8824-1:2021 (E)

value present for the first integer type, followed by the second integer value received from B, if so required by the
application protocol.
7.2        All ASN.1 encoding rules shall specify the encoding and decoding of the value of an enumerated type and a
choice type in such a way that if a transmitted value is in the set of extension additions held in common by the encoder
and the decoder, then it is successfully decoded; otherwise, it shall be possible for the decoder to delimit the encoding
of it and to identify it as a value of an (unknown) extension addition.
7.3         All ASN.1 encoding rules shall specify the encoding and decoding of types with extensible constraints in such
a way that if a transmitted value is in the set of extension additions held in common by the encoder and the decoder,
then it is successfully decoded, otherwise it shall be possible for the decoder to delimit the encoding of and to identify it
as a value of an (unknown) extension addition.
In all cases, the presence of extension additions shall not affect the ability to recognize later material when a type with
an extension marker is nested inside some other type.
      NOTE 1 – All variants of the Basic Encoding Rules of ASN.1 and the Packed Encoding Rules of ASN.1 satisfy all these
      requirements. Encoding rules defined using ECN do not necessarily satisfy all these requirements, but may do so.
      NOTE 2 – PER and BER do not identify the version number in the encoding of an extension addition. Encodings specified using
      ECN may or may not provide such identification.



8            Tags
8.1       A tag is specified (either within the text of this Recommendation | International Standard or by using a type
prefix) by giving a class and a number within the class. The class is one of:
             –    universal;
             –    application;
             –    private;
             –    context-specific.
8.2          The number is a non-negative integer, specified in decimal notation.
8.3          Restrictions on tags assigned by the user of ASN.1 are specified in 31.2.
      NOTE – Subclause 31.2 includes the restriction that users of this notation are not allowed to explicitly specify universal class
      tags in their ASN.1 specifications. There is no formal difference between use of tags from the other three classes. Where
      application class tags are employed, a private or context-specific class tag could generally be applied instead, as a matter of user
      choice and style. The presence of the three classes is largely for historical reasons, but guidance is given in G.2.12 on the way in
      which the classes are usually employed.

8.4        Table 1 summarizes the assignment of tags in the universal class which are specified in this Recommendation
| International Standard.
8.5       Some encoding rules require a canonical order for tags. To provide uniformity, a canonical order for tags is
defined in 8.6.
8.6          The canonical order for tags is based on the outermost tag of each type and is defined as follows:
             a)   those elements or alternatives with universal class tags shall appear first, followed by those with
                  application class tags, followed by those with context-specific tags, followed by those with private class
                  tags;
             b)   within each class of tags, the elements or alternatives shall appear in ascending order of their tag
                  numbers.




                                                                                         Rec. ITU-T X.680 (02/2021)                   13
ISO/IEC 8824-1:2021 (E)


                                     Table 1 – Universal class tag assignments
     UNIVERSAL 0                        Reserved for use by the encoding rules
     UNIVERSAL 1                        Boolean type
     UNIVERSAL 2                        Integer type
     UNIVERSAL 3                        Bitstring type
     UNIVERSAL 4                        Octetstring type
     UNIVERSAL 5                        Null type
     UNIVERSAL 6                        Object identifier type
     UNIVERSAL 7                        Object descriptor type
     UNIVERSAL 8                        External type and Instance-of type
     UNIVERSAL 9                        Real type
     UNIVERSAL 10                       Enumerated type
     UNIVERSAL 11                       Embedded-pdv type
     UNIVERSAL 12                       UTF8String type
     UNIVERSAL 13                       Relative object identifier type
     UNIVERSAL 14                       The time type
     UNIVERSAL 15                       Reserved for future editions of this Recommendation | International Standard
     UNIVERSAL 16                       Sequence and Sequence-of types
     UNIVERSAL 17                       Set and Set-of types
     UNIVERSAL 18-22, 25-30             Character string types
     UNIVERSAL 23-24                    UTCTime and GeneralizedTime
     UNIVERSAL 31-34                    DATE, TIME-OF-DAY, DATE-TIME and DURATION respectively
     UNIVERSAL 35                       OID internationalized resource identifier type
     UNIVERSAL 36                       Relative OID internationalized resource identifier type
     UNIVERSAL 37-...                   Reserved for addenda to this Recommendation | International Standard



9        Encoding instructions
9.1       An encoding instruction is assigned to a type using either a type prefix (see 31.3) or an encoding control
section (see clause 54).
9.2       A type prefix may contain an encoding reference. If it does not, the encoding reference is determined by the
default encoding reference for the module (see 13.5).
9.3       An encoding control section always contains an encoding reference. There may be multiple encoding control
sections, but each encoding control section shall have a distinct encoding reference.
9.4       An encoding instruction consists of a sequence of lexical items specified in the Recommendation |
International Standard determined by the encoding reference (see Annex E).
9.5        Multiple encoding instructions with the same or with different encoding references may be assigned to a type
(using either or both of type prefixes and an encoding control section). Encoding instructions assigned with a given
encoding reference are independent from those assigned with a different encoding reference, and from any use of a type
prefix to perform tagging.
9.6       The effect of assigning several encoding instructions with the same encoding reference (using either or both
of type prefixes and an encoding control section) is specified in the Recommendation | International Standard
determined by the encoding reference (see Annex E), and is not specified in this Recommendation | International
Standard.
9.7       If an encoding instruction is assigned to the "Type" in a "TypeAssignment", it becomes associated with the
type, and is applied wherever the "typereference" of the "TypeAssignment" is used. This includes use in other modules
through the export and import statements.




14         Rec. ITU-T X.680 (02/2021)
                                                                                                           ISO/IEC 8824-1:2021 (E)

10          Use of the ASN.1 notation
10.1        The ASN.1 notation for a type definition shall be "Type" (see 17.1).
10.2        The ASN.1 notation for a value of a type shall be "Value" (see 17.7).
     NOTE – It is not in general possible to interpret the value notation without knowledge of the type.

10.3      The ASN.1 notation for assigning a type to a type reference name shall be either "TypeAssignment" (see
16.1), "ValueSetTypeAssignment" (see 16.6), "ParameterizedTypeAssignment" (see Rec. ITU-T X.683 | ISO/IEC
8824-4, 8.2), or "ParameterizedValueSetTypeAssignment" (see Rec. ITU-T X.683 | ISO/IEC 8824-4, 8.2).
10.4      The ASN.1 notation for assigning a value to a value reference name shall be either "ValueAssignment"
(see 16.2) or "ParameterizedValueAssignment" (see Rec. ITU-T X.683 | ISO/IEC 8824-4, 8.2).
10.5    The production alternatives of the notation "Assignment" shall only be used within the notation
"ModuleDefinition" (except as specified in NOTE 2 of 13.1).


11          The ASN.1 character set
11.1      A lexical item shall consist of a sequence of the characters listed in Table 2 except as specified in 11.2, 11.3
and 11.4. In Table 2, characters are identified by the names they are given in ISO/IEC 10646.

                                                    Table 2 – ASN.1 characters
                A to Z          (LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z)
                a to z          (LATIN SMALL LETTER A to LATIN SMALL LETTER Z)
                0 to 9          (DIGIT ZERO to DIGIT 9)
                !               (EXCLAMATION MARK)
                "               (QUOTATION MARK)
                &               (AMPERSAND)
                '               (APOSTROPHE)
                (               (LEFT PARENTHESIS)
                  )             (RIGHT PARENTHESIS)
                *               (ASTERISK)
                ,               (COMMA)
                -               (HYPHEN-MINUS)
                .               (FULL STOP)
                /               (SOLIDUS)
                :               (COLON)
                ;               (SEMICOLON)
                <               (LESS-THAN SIGN)
                =               (EQUALS SIGN)
                >               (GREATER-THAN SIGN)
                @               (COMMERCIAL AT)
                [               (LEFT SQUARE BRACKET)
                ]               (RIGHT SQUARE BRACKET)
                ^               (CIRCUMFLEX ACCENT)
                _               (LOW LINE)
                {               (LEFT CURLY BRACKET)
                |               (VERTICAL LINE)
                }               (RIGHT CURLY BRACKET)
                –               (NON-BREAKING HYPHEN)

     NOTE – Where equivalent derivative standards are developed by national standards bodies, additional characters may appear in
     the following lexical items:
            –    typereference (see 12.2);
            –    identifier (see 12.3);
            –    valuereference (see 12.4);
            –    modulereference (see 12.5).




                                                                                       Rec. ITU-T X.680 (02/2021)              15
ISO/IEC 8824-1:2021 (E)

     When additional characters are introduced to accommodate a language in which the distinction between upper-case and lower-
     case letters is without meaning, the syntactic distinction achieved by dictating the case of the first character of certain of the
     above lexical items has to be achieved in some other way. This is to allow valid ASN.1 specifications to be written in various
     languages.

11.2      Where the notation is used to specify the value of a character string type, all characters for the defined
character set can appear in the ASN.1 notation, surrounded by the QUOTATION MARK (34) characters (") (see 12.14).
11.3        Additional (arbitrary) graphic symbols may appear in the "comment" lexical item (see 12.6).
11.4     Where the notation is used to specify the value of a Unicode label, all characters allowed in a Unicode label
can appear in ASN.1 notation.
11.5      There shall be no significance placed on the typographical style, size, colour, intensity, or other display
characteristics.
11.6        The upper-case and lower-case letters shall be regarded as distinct.
11.7        ASN.1 definitions can also contain white-space characters (see 12.1.6) between lexical items.
11.8      The NON-BREAKING HYPHEN and the HYPHEN-MINUS should be treated as identical in all names
(including reserved words).
     NOTE – A name such as My-Type is the same name whether it contains a HYPHEN-MINUS or a
     NON-BREAKING HYPHEN.



12          ASN.1 lexical items

12.1        General rules
12.1.1 The following subclauses specify the characters in lexical items. In each case the name of the lexical item is
given, together with the definition of the character sequences which form the lexical item.
12.1.2 The lexical items specified in the subclauses of this clause 12 (except multiple-line "comment", "bstring",
"xmlbstring", "hstring", "xmlhstring", "cstring", "xmlcstring" and "simplestring") shall not contain white-space
(see 12.6, 12.10, 12.11, 12.12, 12.13, 12.14, 12.15 and 12.16). A single-line "comment" shall not contain "new-line"
characters. The "non-integerUnicodeLabel" lexical item may include the NON-BREAKING-SPACE character.
12.1.3      The length of a line is not restricted.
12.1.4 Lexical items may be separated by one or more occurrences of white-space (see 12.1.6) or comments (see
12.6) except when the non-spacing indicator "&" (see 5.4) is used. Within an "XMLTypedValue" production (see
16.2), white-space may appear between lexical items, but the "comment" lexical item shall not be present.
     NOTE – This is to avoid ambiguity resulting from the presence of adjacent hyphens or asterisk and solidus within an
     "xmlcstring" lexical item. Such characters never indicate the start of a "comment" lexical item when they appear within an
     "XMLTypedValue" production.

12.1.5 A lexical item shall be separated from a following lexical item by one or more instances of white-space or
comment if the initial character (or characters) of the following lexical item is a permitted character (or characters) for
inclusion at the end of the characters in the earlier lexical item.
12.1.6 This Recommendation | International Standard uses the terms "newline", and "white-space". In representing
white-space and newline (end of line) in machine-readable specifications, any one or more of the following characters
may be used in any combination (for each character, the character name and character code specified in The Unicode
Standard are given):
For white-space:
            HORIZONTAL TABULATION (9)
            LINE FEED (10)
            VERTICAL TABULATION (11)
            FORM FEED (12)
            CARRIAGE RETURN (13)
            SPACE (32)
            NO-BREAK SPACE ({0,0,0,160})



16           Rec. ITU-T X.680 (02/2021)
                                                                                                     ISO/IEC 8824-1:2021 (E)

For newline:
          LINE FEED (10)
          VERTICAL TABULATION (11)
          FORM FEED (12)
          CARRIAGE RETURN (13)
   NOTE – Any character or character sequence that is a valid newline is also a valid white-space.


12.2      Type references
Name of lexical item – typereference
12.2.1 A "typereference" shall consist of an arbitrary number (one or more) of letters, digits, and hyphens. The initial
character shall be an upper-case letter. A hyphen shall not be the last character. A hyphen shall not be immediately
followed by another hyphen.
   NOTE – The rules concerning hyphen are designed to avoid ambiguity with (possibly following) comment.

12.2.2    A "typereference" shall not be one of the reserved character sequences listed in 12.38.

12.3      Identifiers
Name of lexical item – identifier
An "identifier" shall consist of an arbitrary number (one or more) of letters, digits, and hyphens. The initial character
shall be a lower-case letter. A hyphen shall not be the last character. A hyphen shall not be immediately followed by
another hyphen.
   NOTE – The rules concerning hyphen are designed to avoid ambiguity with (possibly following) comment.


12.4      Value references
Name of lexical item – valuereference
A "valuereference" shall consist of the sequence of characters specified for an "identifier" in 12.3. In analyzing an
instance of use of this notation, a "valuereference" is distinguished from an "identifier" by the context in which it
appears.

12.5      Module references
Name of lexical item – modulereference
A "modulereference" shall consist of the sequence of characters specified for a "typereference" in 12.2. In analyzing an
instance of use of this notation, a "modulereference" is distinguished from a "typereference" by the context in which it
appears.

12.6      Comments
Name of lexical item – comment
12.6.1 A "comment" is not referenced in the definition of the ASN.1 notation. It may, however, appear at any time
between other lexical items, and has no syntactic significance.
   NOTE – Nonetheless, in the context of a Recommendation | International Standard that uses ASN.1, an ASN.1 comment may
   contain normative text related to the application semantics, or constraints on the syntax.

12.6.2    The lexical item "comment" can have two forms:
          a)   One-line comments which begin with "--" as defined in 12.6.3;
          b)   Multiple-line comments which begin with "/*" as defined in 12.6.4.
12.6.3 Whenever a "comment" begins with a pair of adjacent hyphens, it shall end with the next pair of adjacent
hyphens or at the end of the line, whichever occurs first. A comment shall not contain a pair of adjacent hyphens other
than the pair which starts it and the pair, if any, which ends it. If a comment beginning with "--" includes the adjacent
characters "/*" or "*/", these have no special meaning and are considered part of the comment. The comment may
include graphic symbols which are not in the character set specified in 11.1 (see 11.3).




                                                                                    Rec. ITU-T X.680 (02/2021)           17
ISO/IEC 8824-1:2021 (E)

12.6.4 Whenever a "comment" begins with "/*", it shall end with a corresponding "*/", whether this "*/" is on the
same line or not. If another "/*" is found before a "*/", then the comment terminates when a matching "*/" has been
found for each "/*". If a comment beginning with "/*" includes two adjacent hyphens "--", these hyphens have no
special meaning and are considered part of the comment. The comment may include graphic symbols which are not in
the character set specified in 11.1 (see 11.3).
     NOTE – This allows the user to comment parts of an ASN.1 module that already contain comments (whether they begin with "--
     " or "/*") by simply inserting "/*" at the beginning of the part to be commented and "*/" at its end, provided there are no
     character string values within the part to be commented out that contain "/*" or "*/".


12.7       Empty lexical item
Name of lexical item – empty
The "empty" item contains no characters. It is used in the notation of clause 5 when alternative sets of production
sequences are specified, to indicate that absence of all alternatives is possible.

12.8       Numbers
Name of lexical item – number
A "number" shall consist of one or more digits. The first digit shall not be zero unless the "number" is a single digit.
     NOTE – The "number" lexical item is always mapped to an integer value by interpreting it as decimal notation.


12.9       Real numbers
Name of lexical item – realnumber
A "realnumber" shall consist of an integer part that is a series of one or more digits, and optionally a decimal point (.).
The decimal point can optionally be followed by a fractional part which is one or more digits. The integer part, decimal
point or fractional part (whichever is last present) can optionally be followed by an e or E and an optionally-signed
exponent which is one or more digits. The leading digit of the "realnumber" shall not be zero unless it is either the only
digit or is immediately followed by a decimal point followed by a fractional part of which at least one digit is not zero.
A "number" is also a valid instance of "realnumber". In analyzing an instance of use of this notation, a "realnumber" is
distinguished from a "number" by the context in which it appears.

12.10      Binary strings
Name of lexical item – bstring
A "bstring" shall consist of an arbitrary number (possibly zero) of the characters:
           0 1

possibly intermixed with white-space, preceded by an APOSTROPHE (39) character (') and followed by the pair of
characters:
           'B
           EXAMPLE – '01101100'B
Occurrences of white-space within a binary string lexical item have no significance.

12.11      XML binary string item
Name of item – xmlbstring
An "xmlbstring" shall consist of an arbitrary number (possibly zero) of zeros, ones or white-space. Any white-space
characters that appear within a binary string item have no significance.
           EXAMPLE – 01101100
This sequence of characters is also a valid instance of "xmlhstring" and "xmlcstring". In analyzing an instance of use of
this notation, an "xmlbstring" is distinguished from an "xmlhstring" or "xmlcstring" by the context in which it appears.

12.12      Hexadecimal strings
Name of lexical item – hstring


18           Rec. ITU-T X.680 (02/2021)
                                                                                                       ISO/IEC 8824-1:2021 (E)

12.12.1 An "hstring" shall consist of an arbitrary number (possibly zero) of the characters:
          A B C D E F 0 1 2 3 4 5 6 7 8 9

possibly intermixed with white-space, preceded by an APOSTROPHE (39) character (') and followed by the pair of
characters:
          'H
          EXAMPLE – 'AB0196'H
Occurrences of white-space within a hexadecimal string lexical item have no significance.
12.12.2 Each character is used to denote the value of a semi-octet using a hexadecimal representation.

12.13     XML hexadecimal string item
Name of item – xmlhstring
12.13.1 An "xmlhstring" shall consist of an arbitrary number (possibly zero) of the characters:
          0123456789ABCDEFabcdef
or white-space. Any white-space characters that appear within a hexadecimal string item have no significance.
          EXAMPLE – Ab0196
12.13.2 Each character is used to denote the value of a semi-octet using a hexadecimal representation.
12.13.3 All instances of "xmlhstring" are also valid instances of "xmlcstring", and some instances are also valid
instances of "xmlbstring". In analyzing an instance of use of this notation, an "xmlhstring" is distinguished from an
"xmlbstring" or "xmlcstring" by the context in which it appears.

12.14     Character strings
Name of lexical item – cstring
12.14.1 A "cstring" shall consist of an arbitrary number (possibly zero) of graphic symbols and spacing characters
from the character set referenced by the character string type, preceded and followed by a QUOTATION MARK (34)
character ("). If the character set includes a QUOTATION MARK (34) character, this character (if present in the
character string being represented by the "cstring") shall be represented in the "cstring" by a pair of QUOTATION
MARK (34) characters on the same line with no intervening spacing character. The "cstring" may span more than one
line of text, in which case the character string being represented shall not include spacing characters in the position prior
to or following the end of line in the "cstring". Any spacing characters that appear immediately prior to or following the
end of line in the "cstring" have no significance.
   NOTE 1 – The "cstring" can only be used to unambiguously represent (on a printed page) character strings for which every
   character in the string being represented has either been assigned a graphic symbol, or is a spacing character. Where a character
   string containing control characters needs to be denoted in a printed representation, alternative ASN.1 syntax is available (see
   clause 39).
   NOTE 2 – The character string represented by a "cstring" consists of the characters associated with the graphic symbols and
   spacing characters. Spacing characters immediately preceding or following any end of line in the "cstring" are not part of the
   character string being represented (they are ignored). Where spacing characters are included in the "cstring", or where the graphic
   symbols in the character repertoire are not unambiguous in a printed representation, the character string denoted by "cstring" may
   be ambiguous in that printed representation.

EXAMPLE 1 – "                    "

EXAMPLE 2 – The "cstring":
                "ABCDE        FGH
                IJK""XYZ"

can be used to represent a character string value of type IA5String. The value represented consists of the characters:
               ABCDE       FGHIJK"XYZ

where the precise number of spaces intended between E and F can be ambiguous in a printed representation if a
proportional spacing font (such as is used above) is used in the printed specification, or if the character repertoire
contains multiple spacing characters of different widths.




                                                                                     Rec. ITU-T X.680 (02/2021)                   19
ISO/IEC 8824-1:2021 (E)

12.14.2 When a character is a combining character (see Annex H) it shall be denoted in a printed representation of the
"cstring" as an individual character. It shall not be overprinted with the characters with which it combines. (This ensures
that the order of combining characters in the string value is unambiguously defined in the printed version.)
EXAMPLE – Lower-case "e" and the accent combining character are two characters in ISO/IEC 10646, and thus a
corresponding "cstring" should be printed as two characters and not as the single character é.

12.15      XML character string item
Name of item – xmlcstring
12.15.1 An "xmlcstring" shall consist of an arbitrary number (possibly zero) of the following ISO/IEC 10646
characters:
           a)    HORIZONTAL TABULATION (9);
           b)    LINE FEED (10);
           c)    CARRIAGE RETURN (13);
           d)    any character whose ISO/IEC 10646 character code is in the range 32 (20 hex) to 55295 (D7FF hex),
                 inclusive;
           e)    any character whose ISO/IEC 10646 character code is in the range 57344 (E000 hex) to 65533 (FFFD
                 hex), inclusive;
           f)    any character whose ISO/IEC 10646 character code is in the range 65536 (10000 hex) to 1114111
                 (10FFFF hex), inclusive.
     NOTE – Additional restrictions are imposed by the requirement that the "xmlcstring", in an instance of use, shall contain only
     characters permitted by the governing character string type.

12.15.2 The characters "&" (AMPERSAND), "<" (LESS-THAN SIGN) or ">" (GREATER-THAN SIGN) shall
appear only as part of one of the character sequences specified in 12.15.4 or 12.15.5.
12.15.3 An "xmlcstring" is used to represent the value of a restricted character string (see 41.9), and can be used to
represent all combinations of ISO/IEC 10646 characters, either directly, or by using the escape sequences specified
below.
     NOTE 1 – An "xmlcstring" cannot be used to represent characters that are not present in ISO/IEC 10646, such as some of the
     control characters which can appear in GeneralString, nor can it represent characters which might be defined with ISO/IEC
     10646 character codes above 10FFFF hex.
     NOTE 2 – The characters LINE FEED (10) and CARRIAGE RETURN (13) and the pair CARRIAGE RETURN + LINE FEED
     are not distinguished when processed by conforming XML processors.

12.15.4 If the characters "&" (AMPERSAND), "<" (LESS-THAN SIGN) or ">" (GREATER-THAN SIGN) are
present in an abstract character string value being represented by "xmlcstring" (see 41.9), they shall be represented in
the "xmlcstring" by either
           a)    the escape sequences specified in 12.15.8; or
           b)    the escape sequences "&amp;", "&lt;" or "&gt;" respectively. These escape sequences shall not contain
                 white-space (see 12.1.6).
12.15.5 If a character with an ISO/IEC 10646 character code in column 1 of Table 3 is present in the abstract
character string value being represented by the "xmlcstring" (see 41.9), it shall be represented by the character sequence
in column 2 of Table 3. These character sequences shall not contain white-space (see 12.1.6).
     NOTE – This does not include characters with decimal character codes 9, 10, and 13, and all the letters in these character
     sequences are lower-case.




20           Rec. ITU-T X.680 (02/2021)
                                                                                                  ISO/IEC 8824-1:2021 (E)

                         Table 3 – Escape sequences for control characters in an "xmlcstring"

        ISO/IEC 10646                      "xmlcstring"                ISO/IEC 10646                   "xmlcstring"
        character code                    representation               character code                 representation
   0 (0 hex)                      <nul/>                          17 (11 hex)                    <dc1/>
   1 (1 hex)                      <soh/>                          18 (12 hex)                    <dc2/>
   2 (2 hex)                      <stx/>                          19 (13 hex)                    <dc3/>
   3 (3 hex)                      <etx/>                          20 (14 hex)                    <dc4/>
   4 (4 hex)                      <eot/>                          21 (15 hex)                    <nak/>
   5 (5 hex)                      <enq/>                          22 (16 hex)                    <syn/>
   6 (6 hex)                      <ack/>                          23 (17 hex)                    <etb/>
   7 (7 hex)                      <bel/>                          24 (18 hex)                    <can/>
   8 (8 hex)                      <bs/>                           25 (19 hex)                    <em/>
   11 (B hex)                     <vt/>                           26 (1A hex)                    <sub/>
   12 (C hex)                     <ff/>                           27 (1B hex)                    <esc/>
   14 (E hex)                     <so/>                           28 (1C hex)                    <is4/>
   15 (F hex)                     <si/>                           29 (1D hex)                    <is3/>
   16 (10 hex)                    <dle/>                          30 (1E hex)                    <is2/>
                                                                  31 (1F hex)                    <is1/>

12.15.6 When "xmlcstring" is used within an "XMLTypedValue" (see 16.2) forming part of an XER encoding (see
Rec. ITU-T X.693 | ISO/IEC 8825-4), it may contain adjacent HYPHEN-MINUS (45) characters. When used within an
instance of XML value notation in an ASN.1 module, it shall not contain two adjacent HYPHEN-MINUS characters. If
this character sequence is present in an abstract character string value being represented by the "xmlcstring" in an
ASN.1 module, then at least one of the adjacent HYPHEN-MINUS characters shall be represented by the escape
sequences specified in 12.15.8.
12.15.7 When "xmlcstring" is used within an "XMLTypedValue" forming part of an XER encoding (see Rec. ITU-T
X.693 | ISO/IEC 8825-4), it may contain adjacent ASTERISK (42) and SOLIDUS (47) characters in any order. When
used within an instance of XML value notation in an ASN.1 module, it shall not contain adjacent ASTERISK and
SOLIDUS characters (in any order). If this character sequence is present in an abstract character string value being
represented by the "xmlcstring", then at least one of the adjacent ASTERISK and SOLIDUS characters shall be
represented by the escape sequences specified in 12.15.8.
12.15.8 Any character that can appear directly in an "xmlcstring" can also be represented in the "xmlcstring" by an
escape sequence of the form "&#n;" (where n is the ISO/IEC 10646 character code in decimal notation) or of the form
"&#xn;" (where n is the ISO/IEC 10646 character code in hexadecimal notation). These escape sequences shall not
contain white-space (see 12.1.6).
   NOTE 1 – Leading zeros are permitted in the decimal and hexadecimal values of "n" and both lower-case and upper-case letters
   "A"-"F" can be used in the hexadecimal value.
   NOTE 2 – If the escape sequences "&#n" and "&#xn" are used for ISO/IEC 10646 characters which are not in the Basic
   Multilingual Plane (BMP), the value of "n" will be greater than 65535 (FFFF hex).

EXAMPLE – The "xmlcstring":
          ABCD&#233; FGH&#xEE;JK&amp;XYZ
can be used to represent a character string value of type UTF8String. The value represented consists of the characters:
          ABCDé FGHîJK&XYZ
where the precise space characters between é and F can be ambiguous in print media if a proportional spacing font (such
as above) is used in the specification.




                                                                                 Rec. ITU-T X.680 (02/2021)                 21
ISO/IEC 8824-1:2021 (E)

12.16       The simple character string lexical item
Name of item – simplestring
A "simplestring" shall consist of one or more ISO/IEC 10646 characters whose character code is in the range 32 to 126,
preceded and followed by a QUOTATION MARK (34) character ("). It shall not contain a QUOTATION MARK (34)
character ("). The "simplestring" may span more than one line of text, in which case any characters representing end-of-
line shall be treated as spacing characters. In analyzing an instance of use of this notation, a "simplestring" is
distinguished from a "cstring" by the context in which it appears.
     NOTE – The "simplestring" lexical item is only used in the subtype notation of the time type.


12.17       Time value character strings
Name of item – tstring
A "tstring" shall consist of one or more of the characters:
            0 1 2 3 4 5 6 7 8 9 + - : . , / C D H M R P S T W Y Z

preceded and followed by a QUOTATION MARK (34) character (").
     NOTE – The "tstring" lexical item is only used in the value notation for the time type.


12.18       XML time value character string item
Name of item – xmltstring
An "xmltstring" shall consist of one or more of the characters:
            0 1 2 3 4 5 6 7 8 9 + - : . , / C D H M R P S T W Y Z
     NOTE – The "xmltstring" lexical item is only used in the XML value notation of the time type.


12.19       The property and setting names lexical item
Name of item – psname
A "psname" shall consist of an arbitrary number (one or more) of letters, digits and hyphens. The initial character shall
be an upper-case letter. A hyphen shall not be the last character. A hyphen shall not be immediately followed by another
hyphen.
     NOTE – The "psname" lexical item is only used in the contents of the "simplestring" used in the subtype notation for the time
     type.


12.20       Assignment lexical item
Name of lexical item – "::="
This lexical item shall consist of the sequence of characters:
            ::=
     NOTE – This sequence does not contain white-space (see 12.1.2).


12.21       Range separator
Name of lexical item – ".."
This lexical item shall consist of the sequence of characters:
            ..
     NOTE – This sequence does not contain white-space (see 12.1.2).


12.22       Ellipsis
Name of lexical item – "..."
This lexical item shall consist of the sequence of characters:
            ...
     NOTE – This sequence does not contain white-space (see 12.1.2).




22           Rec. ITU-T X.680 (02/2021)
                                                                                                     ISO/IEC 8824-1:2021 (E)

12.23     Left version brackets
Name of lexical item – "[["
This lexical item shall consist of the sequence of characters:
          [[
   NOTE – This sequence does not contain white-space (see 12.1.2).


12.24     Right version brackets
Name of lexical item – "]]"
This lexical item shall consist of the sequence of characters:
          ]]
   NOTE – This sequence does not contain white-space (see 12.1.2).


12.25     Encoding references
Name of item – encodingreference
An "encodingreference" shall consist of a sequence of characters as specified for a "typereference" in 12.2, except that
no lower-case letters shall be included.
   NOTE – Currently defined encoding references are listed in Annex E with the Recommendation | International Standard that
   specifies the syntax and semantics of the corresponding encoding instructions. The "encodingreference" shall consist only of the
   sequences listed in Annex E in this or in future versions of this Recommendation | International Standard.


12.26     Integer-valued Unicode labels
Name of lexical item – integerUnicodeLabel
This lexical item shall consist of an arbitrarily long sequence of ISO/IEC 10646 characters in the range 0 (DIGIT
ZERO) to 9 (DIGIT NINE) that identify an arc of the International Object Identifier tree. It shall not commence with a
0 (DIGIT ZERO) character unless it has only a single character and the primary integer value of the associated arc of
the International Object Identifier tree is zero.

12.27     Non-integer Unicode labels
Name of lexical item – non-integerUnicodeLabel
This lexical item shall consist of an arbitrarily long sequence of ISO/IEC 10646 characters that satisfies the constraints
specified in Rec. ITU-T X.660 | ISO 9834-1, 7.5 and identifies an arc of the International Object Identifier tree. For
lexical parsing purposes, it shall not consist only of characters that would enable it to be identified as an
"integerUnicodeLabel".

12.28     XML end tag start item
Name of item – "</"
This item shall consist of the sequence of characters:
          </
   NOTE – This sequence does not contain any white-space characters (see 12.1.2).


12.29     XML single tag end item
Name of item – "/>"
This item shall consist of the sequence of characters:
          />
   NOTE – This sequence does not contain any white-space characters (see 12.1.2).


12.30     XML boolean true item
Name of item – "true"



                                                                                    Rec. ITU-T X.680 (02/2021)                 23
ISO/IEC 8824-1:2021 (E)

12.30.1 This item shall consist of the sequence of characters:
           true
12.30.2 In analyzing an instance of use of this notation, a "true" is distinguished from a "valuereference" or an
"identifier" or an instance of XML boolean "extended-true" by the context in which it appears.
     NOTE – This sequence does not contain any white-space characters (see 12.1.2).


12.31      XML boolean extended-true item
Name of item – extended-true
12.31.1 This item shall consist of either the sequence of characters:
           true
or of the single character:
           1       (DIGIT ONE)
12.31.2 In analyzing an instance of use of this notation, an "extended-true" is distinguished from a "valuereference" or
an "identifier" or an instance of XML boolean "true" by the context in which it appears.
     NOTE – This sequence does not contain any white-space characters (see 12.1.2).


12.32      XML boolean false item
Name of item – "false"
12.32.1 This item shall consist of the sequence of characters:
           false
12.32.2 In analyzing an instance of use of this notation, a "false" is distinguished from a "valuereference" or an
"identifier" or an instance of XML boolean "extended-false" by the context in which it appears.
     NOTE – This sequence does not contain any white-space characters (see 12.1.2).


12.33      XML boolean extended-false item
Name of item – extended-false
12.33.1 This item shall consist of either the sequence of characters:
           false
or of the single character:
           0       (DIGIT ZERO)
12.33.2 In analyzing an instance of use of this notation, a "false" is distinguished from a "valuereference" or an
"identifier" or an instance of XML boolean "false" by the context in which it appears.
     NOTE – This sequence does not contain any white-space characters (see 12.1.2).


12.34      XML real not-a-number item
Name of item – "NaN"
12.34.1 This item shall consist of the sequence of characters:
           NaN
12.34.2 In analyzing an instance of use of this notation, a "NaN" is distinguished from any other lexical item
commencing with an upper-case letter by the context in which it appears.
     NOTE – This sequence does not contain any white-space characters (see 12.1.2).


12.35      XML real infinity item
Name of item – "INF"
12.35.1 This item shall consist of the sequence of characters:
           INF



24             Rec. ITU-T X.680 (02/2021)
                                                                                                  ISO/IEC 8824-1:2021 (E)

12.35.2 In analyzing an instance of use of this notation, an "INF" is distinguished from any other lexical item
commencing with an upper-case letter by the context in which it appears.
   NOTE – This sequence does not contain any white-space characters (see 12.1.2).


12.36    XML tag names for ASN.1 types
Name of item – xmlasn1typename
12.36.1 This Recommendation | International Standard uses the item "xmlasn1typename" when ASN.1 built-in types are
to be used as XML tag names.
12.36.2 Table 4 lists the character sequences that are to form the "xmlasn1typename" for each of the ASN.1 built-in
types listed in 17.2. The ASN.1 built-in type is identified in column 1 of Table 4 by its production name. The character
sequence which shall be used for "xmlasn1typename" is identified in column 2 of Table 4, with no white-space before
or after these character sequences.
12.36.3 The "xmlasn1typename" for the "UsefulType"s (see 45.1) shall be the "typereference" used in their definition.
12.36.4 The character sequence in the "xmlasn1typename" item for the "ObjectClassFieldType" and for the
"InstanceOfType" are specified in Rec. ITU-T X.681 | ISO/IEC 8824-2, 14.1 and Annex C.
12.36.5 If the ASN.1 built-in type is a "PrefixedType" then the type which determines the "xmlasn1typename" shall be
"Type" in the "PrefixedType" (see 31.1.5). If this is itself a "PrefixedType", then this subclause 12.36.5 shall be
recursively applied.
   NOTE – The subclauses of 26.10 specify the "Type" to be used for a "SelectionType" and a "ConstrainedType".

                                       Table 4 – Characters in xmlasn1typename

                ASN.1 type production name                               Characters in xmlasn1typename
     BitStringType                                        BIT_STRING
     BooleanType                                          BOOLEAN
     ChoiceType                                           CHOICE
     DateType                                             DATE
     DateTimeType                                         DATE_TIME
     DurationType                                         DURATION
     EmbeddedPDVType                                      SEQUENCE
     EnumeratedType                                       ENUMERATED
     ExternalType                                         SEQUENCE
     InstanceOfType                                       SEQUENCE
     IntegerType                                          INTEGER
     IRIType                                              OID_IRI
     NullType                                             NULL
     ObjectClassFieldType                                 See Rec. ITU-T X.681 | ISO/IEC 8824-2, 14.10 and 14.11
     ObjectIdentifierType                                 OBJECT_IDENTIFIER
     OctetStringType                                      OCTET_STRING
     PrefixedType                                         See 12.36.5
     RealType                                             REAL
     RelativeIRIType                                      RELATIVE_OID_IRI
     RelativeOIDType                                      RELATIVE_OID
     RestrictedCharacterStringType                        The type name (e.g. IA5String)
     SequenceType                                         SEQUENCE
     SequenceOfType                                       SEQUENCE_OF
     SetType                                              SET
     SetOfType                                            SET_OF
     TimeType                                             TIME
     TimeOfDayType                                        TIME_OF_DAY
     UnrestrictedCharacterStringType                      SEQUENCE




                                                                                    Rec. ITU-T X.680 (02/2021)        25
ISO/IEC 8824-1:2021 (E)

12.37     Single character lexical items
Names of lexical items –
          "{"
          "}"
          "<"
          ">"
          ","
          "."
          "/"
          "("
          ")"
          "["
          "]"
          "-" (HYPHEN-MINUS)
          ":"
          "="
          """ (QUOTATION MARK)
          "'" (APOSTROPHE)
          ";"
          "@"
          "|"
          "!"
          "^"
A lexical item with any of the names listed above shall consist of the single character without the quotation marks.

12.38     Reserved words
Names of reserved words –
ABSENT                      ENCODED                      INTERSECTION                 SEQUENCE
ABSTRACT-SYNTAX             ENCODING-CONTROL             ISO646String                 SET
ALL                         END                          MAX                          SETTINGS
APPLICATION                 ENUMERATED                   MIN                          SIZE
AUTOMATIC                   EXCEPT                       MINUS-INFINITY               STRING
BEGIN                       EXPLICIT                     NOT-A-NUMBER                 SYNTAX
BIT                         EXPORTS                      NULL                         T61String
BMPString                   EXTENSIBILITY                NumericString                TAGS
BOOLEAN                     EXTERNAL                     OBJECT                       TeletexString
BY                          FALSE                        ObjectDescriptor             TIME
CHARACTER                   FROM                         OCTET                        TIME-OF-DAY
CHOICE                      GeneralizedTime              OF                           TRUE
CLASS                       GeneralString                OID-IRI                      TYPE-IDENTIFIER
COMPONENT                   GraphicString                OPTIONAL                     UNION
COMPONENTS                  IA5String                    PATTERN                      UNIQUE
CONSTRAINED                 IDENTIFIER                   PDV                          UNIVERSAL
CONTAINING                  IMPLICIT                     PLUS-INFINITY                UniversalString
DATE                        IMPLIED                      PRESENT                      UTCTime
DATE-TIME                   IMPORTS                      PrintableString              UTF8String
DEFAULT                     INCLUDES                     PRIVATE                      VideotexString
DEFINITIONS                 INSTANCE                     REAL                         VisibleString
DURATION                    INSTRUCTIONS                 RELATIVE-OID                 WITH
EMBEDDED                    INTEGER                      RELATIVE-OID-IRI




26         Rec. ITU-T X.680 (02/2021)
                                                                                           ISO/IEC 8824-1:2021 (E)

Lexical items with the above names shall consist of the sequence of characters in the name, and are reserved character
sequences.
     NOTE 1 – White-space does not occur in these sequences.
     NOTE 2 – The keywords CLASS, CONSTRAINED, CONTAINING, ENCODED, INSTANCE, SYNTAX and UNIQUE are not used in this
     Recommendation | International Standard; they are used in Rec. ITU-T X.681 | ISO/IEC 8824-2, Rec. ITU-T X.682 |
     ISO/IEC 8824-3 and Rec. ITU-T X.683 | ISO/IEC 8824-4.



13         Module definition
13.1       A "ModuleDefinition" is specified by the following productions:
               ModuleDefinition ::=
                  ModuleIdentifier
                    DEFINITIONS
                    EncodingReferenceDefault
                    TagDefault
                    ExtensionDefault
                    "::="
                    BEGIN
                    ModuleBody
                    EncodingControlSections
                    END

               ModuleIdentifier ::=
                  modulereference
                  DefinitiveIdentification
               DefinitiveIdentification ::=
                   DefinitiveOID
               |   DefinitiveOIDandIRI
               |   empty
               DefinitiveOID ::=
                   "{" DefinitiveObjIdComponentList "}"
               DefinitiveOIDandIRI ::=
                         DefinitiveOID
                   IRIValue
               DefinitiveObjIdComponentList ::=
                   DefinitiveObjIdComponent
               |   DefinitiveObjIdComponent DefinitiveObjIdComponentList
               DefinitiveObjIdComponent ::=
                   NameForm
               |   DefinitiveNumberForm
               |   DefinitiveNameAndNumberForm
               DefinitiveNumberForm        ::= number
               DefinitiveNameAndNumberForm ::= identifier "(" DefinitiveNumberForm ")"
               EncodingReferenceDefault ::=
                       encodingreference INSTRUCTIONS
                   |   empty
               TagDefault ::=
                    EXPLICIT TAGS
               |    IMPLICIT TAGS
               |    AUTOMATIC TAGS
               |    empty
               ExtensionDefault ::=
                    EXTENSIBILITY IMPLIED
               |    empty
               ModuleBody ::=
                  Exports Imports AssignmentList

                                                                             Rec. ITU-T X.680 (02/2021)            27
ISO/IEC 8824-1:2021 (E)

            |   empty
            Exports ::=
                EXPORTS SymbolsExported ";"
            |   EXPORTS ALL ";"
            |   empty
            SymbolsExported ::=
               SymbolList
            |  empty
            Imports ::=
                IMPORTS SymbolsImported ";"
            |   empty
            SymbolsImported ::=
               SymbolsFromModuleList
            |  empty
            SymbolsFromModuleList ::=
               SymbolsFromModule
            |  SymbolsFromModuleList SymbolsFromModule
            SymbolsFromModule ::=
               SymbolList FROM GlobalModuleReference SelectionOption
            SelectionOption ::=
                 empty
            |    WITH "SUCCESSORS"
            |    WITH "DESCENDANTS"

            GlobalModuleReference ::=
                modulereference AssignedIdentifier
            AssignedIdentifier ::=
                ObjectIdentifierValue
            |   DefinedValue
            |   empty
            SymbolList ::=
               Symbol
            |  SymbolList "," Symbol
            Symbol ::=
               Reference
            |  ParameterizedReference
            Reference ::=
                typereference
            |   valuereference
            |   objectclassreference
            |   objectreference
            |   objectsetreference
            AssignmentList ::=
                Assignment
            |   AssignmentList Assignment
            Assignment ::=
                TypeAssignment
            |   ValueAssignment
            |   XMLValueAssignment
            |   ValueSetTypeAssignment
            |   ObjectClassAssignment
            |   ObjectAssignment
            |   ObjectSetAssignment
            |   ParameterizedAssignment



28       Rec. ITU-T X.680 (02/2021)
                                                                                                     ISO/IEC 8824-1:2021 (E)

   NOTE 1 – The use of a "ParameterizedReference" in the "Exports" and "Imports" lists is specified in Rec. ITU-T X.683 |
   ISO/IEC 8824-4.
   NOTE 2 – For examples (and for the definition in this Recommendation | International Standard of types with universal class
   tags), the "ModuleBody" can be used outside of a "ModuleDefinition".
   NOTE 3 – "TypeAssignment", "ValueAssignment", "XMLValueAssignment" and "ValueSetTypeAssignment" productions are
   specified in clause 16.
   NOTE 4 – The value of "TagDefault" for the module definition affects only those types defined explicitly in the module. It does
   not affect the interpretation of imported types.
   NOTE 5 – The character semicolon does not appear in the assignment list specification or any of its subordinate productions, and
   is reserved for use by ASN.1 tool developers.

13.2      The "TagDefault" is taken as EXPLICIT TAGS if it is "empty".
   NOTE – Subclause 31.2 gives the meaning of EXPLICIT TAGS, IMPLICIT TAGS, and AUTOMATIC TAGS.

13.3      When the AUTOMATIC TAGS alternative of "TagDefault" is selected, automatic tagging is said to be selected
for the module, otherwise it is said to be not selected. Automatic tagging is a syntactical transformation which is applied
(with additional conditions) to the "ComponentTypeLists" and "AlternativeTypeLists" productions occurring within the
definition of the module. This transformation is formally specified by 25.8 to 25.10, 27.3 and 29.2 to 29.5 regarding the
notations for sequence types, set types and choice types, respectively.
13.4       The EXTENSIBILITY IMPLIED option is equivalent to the textual insertion of an extension marker ("...") in
the definition of each type in the module for which it is permitted. The location of the implied extension marker is the
last position in the type where an explicitly specified extension marker is allowed. The absence of EXTENSIBILITY
IMPLIED means that extensibility is only provided for those types within the module where an extension marker is
explicitly present.
   NOTE – EXTENSIBILITY IMPLIED affects only types. It has no effect on object sets and subtype constraints.

13.5     The "EncodingReferenceDefault" specifies that the "encodingreference" is the default encoding reference for
the module. If the "EncodingReferenceDefault" is "empty", then the default encoding reference for the module is TAG.
   NOTE – Annex E contains a list of allowed encoding references, together with the Recommendation | International Standard
   which specifies the form and meaning of the corresponding encoding instructions.

13.6      The "modulereference" appearing in the "ModuleIdentifier" production is called the module name.
   NOTE – The possibility of defining a single ASN.1 module by the use of several occurrences of "ModuleBody" assigned the
   same "modulereference" was (arguably) permitted in earlier specifications. It is not permitted by this Recommendation |
   International Standard.

13.7      Module names shall be used only once (except as specified in 13.10) within the sphere of interest of the
definition of the module.
13.8     If the "DefinitiveIdentification" is not empty, the denoted object identifier, and any optional "IRIValue", value
unambiguously and uniquely identify the same node of the OID tree that identifies the module being defined. No
defined value may be used in defining the object identifier value. The "IRIValue" production is specified in 34.3.
   NOTE 1 – It is strongly recommended that at least an object identifier value (and preferably an object identifier value plus an
   OID internationalized resource identifier value) be assigned to the module so that others can unambiguously refer to the module.
   NOTE 2 – The question of what changes to a module require a new "DefinitiveIdentification" is not addressed in this
   Recommendation | International Standard.

13.9      If the "AssignedIdentifier" is not empty, the "ObjectIdentifierValue" and the "DefinedValue" alternatives
unambiguously and uniquely identify the module from which reference names are being imported. When the
"DefinedValue" alternative of "AssignedIdentifier" is used, it shall be a value of type object identifier. Each
"valuereference" which textually appears within an "AssignedIdentifier" shall satisfy one of the following rules:
          a)   It is defined in the "AssignmentList" of the module being defined, and all "valuereference"s which
               textually appear on the right side of the assignment statement also satisfy this rule (rule "a") or the next
               rule (rule "b").
          b)   It appears as a "Symbol" in a "SymbolsFromModule" whose "AssignedIdentifier" does not textually
               contain any "valuereference"s.
   NOTE 1 – It is recommended that an object identifier be assigned so that others can unambiguously refer to the module.
   NOTE 2 – This syntax does not provide for the inclusion of an OID internationalized resource reference (if assigned) to the
   referenced module, but it is recommended that this be included in an ASN.1 comment.

13.10     The "GlobalModuleReference" in a "SymbolsFromModule" shall appear in the "ModuleDefinition" of
another module, except that if it includes a non-empty "DefinitiveIdentification", the "modulereference" may differ in
the two cases.




                                                                                   Rec. ITU-T X.680 (02/2021)                   29
ISO/IEC 8824-1:2021 (E)

     NOTE – A different "modulereference" from that used in the other module should only be used when symbols are to be imported
     from two modules with the same name (the modules being named in disregard of 13.7). The use of alternative distinct names
     makes these names available for use in the body of the module (see 13.16).

13.11      When both a "modulereference" and a non-empty "AssignedIdentifier" are used in referencing a module, the
latter shall be considered definitive.
13.12     When the referenced module has a non-empty "DefinitiveIdentification", the "GlobalModuleReference"
referencing that module shall not have an empty "AssignedIdentifier".
13.13      When the "SymbolsExported" alternative of "Exports" is selected:
           a)    each "Symbol" in "SymbolsExported" shall satisfy one and only one of the following conditions:
                 i)     is only defined in the module being constructed; or
                 ii)    appears exactly once in the "SymbolsImported" alternative of "Imports";
           b)    every "Symbol" to which reference from outside the module is appropriate shall be included in the
                 "SymbolsExported" and only these "Symbol"s may be referenced from outside the module (subject to the
                 relaxation specified in 13.14); and
           c)    if there are no such "Symbol"s, then the empty alternative of "SymbolsExported" (not of "Exports") shall
                 be selected.
13.14      When either the "empty" alternative or the EXPORTS ALL alternative of "Exports" is selected, every
"Symbol" defined in the module or imported by the module may be referenced from other modules subject to the
restriction specified in 13.13 a).
     NOTE – The "empty" alternative of "Exports" is included for backwards compatibility.

13.15     Identifiers that appear in a "NamedNumberList", "Enumeration" or "NamedBitList" are implicitly exported if
the typereference that defines them is exported or appears as a component (or subcomponent) within an exported type.
13.16      When the "SymbolsImported" alternative of "Imports" is selected:
           a)    Each "Symbol" in "SymbolsFromModule" shall either be defined in the module body, or be present in
                 the "Imports" clause, of the module denoted by the "GlobalModuleReference" in
                 "SymbolsFromModule". Importing a "Symbol" present in the "Imports" clause of the referenced module
                 is only allowed if there is only one occurrence of the "Symbol" in that clause, and the "Symbol" is not
                 defined in the referenced module.
                       NOTE 1 – This does not prohibit the same symbol name defined in two different modules from being imported
                       into another module. However, if the same "Symbol" name appears more than once in the "Imports" clause of
                       module A, that "Symbol" name cannot be exported from A for import to another module B.
           b)    If the "SymbolsExported" alternative of "Exports" is selected in the definition of the module denoted by
                 the "GlobalModuleReference" in "SymbolsFromModule" the "Symbol" shall appear in its
                 "SymbolsExported".
           c)    Only those "Symbol"s that appear amongst the "SymbolList" of a "SymbolsFromModule" may appear as
                 the symbol in any "External<X>Reference" which has the "modulereference" denoted by the
                 "GlobalModuleReference" of that "SymbolsFromModule" (where <X> is "Value", "Type", "Object",
                 "Objectclass", or "Objectset").
           d)    If there are no such "Symbol"s, then the "empty" alternative of "SymbolsImported" shall be selected.
                       NOTE 2 – An effect of c) and d) is that the statement IMPORTS; implies that the module cannot contain an
                       "External<X>Reference".
           e)    All the "SymbolsFromModule" in the "SymbolsFromModuleList" shall include occurrences of
                 "GlobalModuleReference" such that:
                 i)     the "modulereference" in them are all different from each other and from the "modulereference"
                        associated with the referencing module; and
                 ii)    the "AssignedIdentifier", when non-empty, denotes object identifier values which are all different
                        from each other and from the object identifier value (if any) associated with the referencing module.
           f)    If the "SymbolsFromModule" has a non-empty "SelectionOption", the "AssignedIdentifier" in the
                 "GlobalModuleReference" shall not be empty, and the referenced module shall be determined as follows:
                 i)     If the "SelectionOption" is WITH            SUCCESSORS, the module denoted by the
                        "GlobalModuleReference" is the one that has a DefinitiveIdentification with an object identifier
                        whose last node may be incremented zero or more times. If multiple modules meet this criterion, the
                        denoted module is the one whose object identifier has the last node with the greatest number of
                        increments.


30           Rec. ITU-T X.680 (02/2021)
                                                                                                  ISO/IEC 8824-1:2021 (E)

                 ii)   If the "SelectionOption" is WITH DESCENDANTS, the module denoted by the
                       "GlobalModuleReference" is the one that has a DefinitiveIdentification that identifies the node
                       identified by the "GlobalModuleReference" or one of its subordinates. If multiple modules meet this
                       criterion, the denoted module is the one with the largest object identifier. For this comparison, the
                       arcs are compared successively until one arc is different (selecting the largest arc) or the end of one
                       object identifier is reached (selecting the longer object identifier).
13.17    When the "empty" alternative of "Imports" is selected, the module may still reference "Symbols" defined in
other modules by means of an "External<X>Reference".
     NOTE – The "empty" alternative of "Imports" is included for backwards compatibility.

13.18     Identifiers that appear in a "NamedNumberList", "Enumeration" or "NamedBitList" are implicitly imported if
the typereference that defines them is imported or appears as a component (or subcomponent) within an imported type.
13.19    A "Symbol" in a "SymbolsFromModule" may appear in "ModuleBody" as a "Reference". The
meaning associated with the "Symbol" is that which it has in the module denoted by the corresponding
"GlobalModuleReference".
13.20      Where the "Symbol" also appears in an "AssignmentList" (deprecated), or appears in one or more other
instances of "SymbolsFromModule", it shall only be used in an "External<X>Reference". Where it does not so appear,
it shall be used directly as a "Reference".
13.21     The various alternatives for "Assignment" are defined in the following clauses in this Recommendation |
International Standard, except as noted otherwise:
                 Assignment alternative                Defining subclause

                 "TypeAssignment"                      16.1
                 "ValueAssignment"                     16.2
                 "XMLValueAssignment"                  16.2
                 "ValueSetTypeAssignment"              16.6
                 "ObjectClassAssignment"               Rec. ITU-T X.681 | ISO/IEC 8824-2, 9.1
                 "ObjectAssignment"                    Rec. ITU-T X.681 | ISO/IEC 8824-2, 11.1
                 "ObjectSetAssignment"                 Rec. ITU-T X.681 | ISO/IEC 8824-2, 12.1
                 "ParameterizedAssignment"             Rec. ITU-T X.683 | ISO/IEC 8824-4, 8.1
The first symbol of every "Assignment" is one of the alternatives of "Reference", denoting the reference name being
defined. In no two assignments within an "AssignmentList" shall the reference names be the same.
13.22      "EncodingControlSections" is specified in clause 54.


14         Referencing type and value definitions
14.1       The defined type and value productions:
                 DefinedType ::=
                     ExternalTypeReference
                 |   typereference
                 |   ParameterizedType
                 |   ParameterizedValueSetType
                 DefinedValue ::=
                     ExternalValueReference
                 |   valuereference
                 |   ParameterizedValue
specify the sequences which shall be used to reference type and value definitions. The type identified by a
"ParameterizedType" and "ParameterizedValueSetType", and the value identified by a "ParameterizedValue" are
specified in Rec. ITU-T X.683 | ISO/IEC 8824-4.
14.2       The "NonParameterizedTypeName" production:
                 NonParameterizedTypeName ::=
                    ExternalTypeReference
                 |  typereference

                                                                                    Rec. ITU-T X.680 (02/2021)             31
ISO/IEC 8824-1:2021 (E)

                |     xmlasn1typename
is used when an XML tag name is needed to represent an ASN.1 type. If the resulting XML tag name begins with the
letters "XML", then a LOW LINE (95) shall be pre-pended to form the "NonParameterizedTypeName".
14.3    The third alternative shall not be used as the "NonParameterizedTypeName" in the "XMLTypedValue" of
"XMLValueAssignment" (see 16.2) or of "XMLOpenTypeFieldVal" (see Rec. ITU-T X.681 | ISO/IEC 8824-2, 14.6)
when the XML value notation is used in an ASN.1 module if the "xmlasn1typename" is "CHOICE",
"ENUMERATED", "SEQUENCE", "SEQUENCE_OF", "SET" or "SET_OF".
     NOTE – This restriction is imposed in XML value notation used in an ASN.1 module because these "xmlasn1typename"s do not
     define an ASN.1 type. The restriction is not present for use of this notation in encoding rules (such as XER, see Rec. ITU-
     T X.693 | ISO/IEC 8825-4) because XML tag names formed from "xmlasn1typename"s are not used to determine the types that
     are being encoded.

14.4     Except as specified in 13.19, the "typereference", "valuereference", "ParameterizedType",
"ParameterizedValueSetType" or "ParameterizedValue" alternatives shall not be used unless the reference is within the
"ModuleBody" in which a type or value is assigned (see 16.1 and 16.2) to the "typereference" or "valuereference".
14.5      The "ExternalTypeReference" and "ExternalValueReference" shall not be used unless the corresponding
"typereference" or "valuereference":
           a)   has been assigned a type or value respectively (see 16.1 and 16.2); or
           b)   are present in the "Imports" clause,
within the "ModuleBody" used to define the corresponding "modulereference". Referencing a name in the "Imports"
clause of another module shall only be allowed if there is no more than one occurrence of the "Symbol" in that clause.
     NOTE – This does not prohibit the same "Symbol" defined in two different modules from being imported into another module.
     However, if the same "Symbol" appears more than once in the IMPORTS clause of a module A, then that "Symbol" cannot be
     referenced using module A in an external reference.

14.6      An external reference shall be used in a module only to refer to a reference name which is defined in a
different module, and is specified by the following productions:
                ExternalTypeReference ::=
                    modulereference
                    "."
                    typereference
                ExternalValueReference ::=
                    modulereference
                    "."
                    valuereference
     NOTE – Additional     external    reference productions ("ExternalClassReference",        "ExternalObjectReference"    and
     "ExternalObjectSetReference") are specified in Rec. ITU-T X.681 | ISO/IEC 8824-2.

14.7      When the referencing module is defined using the "SymbolsImported" alternative of "Imports", the
"modulereference" in the external reference shall appear in the "GlobalModuleReference" of exactly one of the
"SymbolsFromModule" in the "SymbolsImported". When the referencing module is defined using the "empty"
alternative of "Imports", the "modulereference" in the external reference shall appear in the "ModuleDefinition" of the
module (different from the referencing module) where the "Reference" is defined.
14.8    Where a "DefinedType" is used as part of notation governed by a "Type" (for example, in a
"SubtypeConstraint") then the "DefinedType" shall be compatible with the governing "Type" as specified in clause
C.6.2.
14.9      Every occurrence within an ASN.1 specification of a "DefinedValue" is governed by a "Type", and that
"DefinedValue" shall reference a value of a type that is compatible with the governing "Type" as specified in
clause C.6.2.


15         Notation to support references to ASN.1 components
15.1      There is a requirement for formal reference to components of ASN.1 types, values, etc. for many purposes.
One such instance is the need to write text to identify a specific type within some ASN.1 module. This clause defines a
notation which can be used to provide such references.
15.2      The notation enables any component of a set or sequence type (which is either mandatorily or optionally
present in the type) to be identified.


32           Rec. ITU-T X.680 (02/2021)
                                                                                                         ISO/IEC 8824-1:2021 (E)

15.3       Any part of any ASN.1 type definition can be referenced by use of the "AbsoluteReference" syntactic
construct:
                 AbsoluteReference ::=
                      "@" ModuleIdentifier
                     "."
                     ItemSpec
                 ItemSpec ::=
                     typereference
                 |   ItemId "." ComponentId
                 ItemId ::= ItemSpec
                 ComponentId ::=
                    identifier
                 |  number
                 |  "*"
     NOTE – The AbsoluteReference production is not used elsewhere in this Recommendation | International Standard. It is provided
     for the purposes stated in 15.1.

15.4        The "ModuleIdentifier" identifies an ASN.1 module (see 13.1).
15.5      When the first or second alternative of "DefinitiveIdentification" is used as part of the "ModuleIdentifier", the
"DefinitiveIdentification" unambiguously and uniquely identifies the module from which a name is being referenced.
15.6        The "typereference" references any ASN.1 type defined in the module identified by "ModuleIdentifier".
15.7      The "ComponentId" in each "ItemSpec" identifies a component of the type which has been identified by the
"ItemId". It shall be the last "ComponentId" if the component it identifies is not a set, sequence, set-of, sequence-of, or
choice type.
15.8      The "identifier" form of "ComponentId" can be used if the parent "ItemId" is a set or sequence type, and is
required to be one of the "identifier"s of the "NamedType" in the "ComponentTypeLists" of that set or sequence. It can
also be used if the "ItemId" identifies a choice type, and is then required to be one of the "identifier"s of a
"NamedType" in the "AlternativeTypeLists" of that choice type. It cannot be used in any other circumstance.
15.9       The number form of "ComponentId" can be used only if the "ItemId" is a sequence-of or set-of type. The
value of the number identifies the instance of the type in the sequence-of or set-of, with the value "1" identifying the
first instance of the type. The value zero identifies a conceptual integer type component (not explicitly present in
transfer) that contains a count of the number of instances of the type in the sequence-of or set-of that are present in the
value of the enclosing type.
15.10     The "*" form of "ComponentId" can be used only if the "ItemId" is a sequence-of or set-of. Any semantics
associated with the use of the "*" form of "ComponentId" apply to all components of the sequence-of and set-of.
     NOTE – In the following example:
            M DEFINITIONS ::= BEGIN
            T ::= SEQUENCE {
                 a   BOOLEAN,
                 b   SET OF INTEGER
            }
END
  the components of "T" could be referenced by text outside an ASN.1 module (or in a comment), such as:
            -- if (@M.T.b.0 is odd) then:
            --        (@M.T.b.* shall be an odd integer)
     which is used to state that if the number of components in b is odd, all components of b must be odd.



16          Assigning types and values
16.1        A "typereference" shall be assigned a type by the notation specified by the "TypeAssignment" production:
                 TypeAssignment ::=
                     typereference
                     "::="
                     Type
The "typereference" shall not be an ASN.1 reserved word (see 12.38).


                                                                                       Rec. ITU-T X.680 (02/2021)              33
ISO/IEC 8824-1:2021 (E)

16.2   A "valuereference" shall be assigned a value by the notation specified by either the "ValueAssignment" or
"XMLValueAssignment" productions:
                ValueAssignment ::=
                    valuereference
                    Type
                    "::="
                    Value
                XMLValueAssignment ::=
                  valuereference
                  "::="
                  XMLTypedValue
                XMLTypedValue ::=
                  "<" & NonParameterizedTypeName ">"
                  XMLValue
                  "</" & NonParameterizedTypeName ">"
                | "<" & NonParameterizedTypeName "/>"
The value being assigned to the "valuereference" in the "ValueAssignment" is "Value", and is governed by "Type" and
shall be a notation for a value of the type defined by "Type" (as specified in 16.3). The value being assigned to the
"valuereference" in the "XMLValueAssignment" is "XMLValue" (see 17.7), and shall be a notation for a value of the
type defined by "NonParameterizedTypeName" (as specified in 16.4). If this is the "xmlasn1typename" item, then it
identifies the ASN.1 built-in type in the corresponding row of Table 4 (see also 14.3). Whitespace is permitted around
"XMLValue" in "XMLTypedValue" except where explicitly forbidden (see 41.9 and Rec. ITU-T X.693 |
ISO/IEC 8825-4, 31.3.4.1).
16.3       "Value" is a notation for a value of a type as specified in 17.7.
16.4      "XMLValue" is a notation for a value of a type if "XMLValue" is an "XMLBuiltinValue" notation for the
type (see 17.10).
16.5      The second alternative of "XMLTypedValue" (use of an XML empty-element tag) can be used only if an
instance of the "XMLValue" production is empty.
     NOTE – If the "XMLValue" production was an "xmlcstring" containing only white-space, this would not be empty, and the
     second alternative could not be used.

16.6     A "typereference" can be assigned a value set by the notation specified by the "ValueSetTypeAssignment"
production:
                ValueSetTypeAssignment ::=
                    typereference
                    Type
                    "::="
                    ValueSet
This notation assigns to "typereference" the type defined as a subtype of the type denoted by "Type" and which contains
exactly the values which are specified in or allowed by "ValueSet". The "typereference" shall not be an ASN.1 reserved
word (see 12.38), and may be referenced as a type. "ValueSet" is defined in 16.7.
16.7       A value set governed by some type shall be specified by the notation "ValueSet":
                ValueSet ::= "{" ElementSetSpecs "}"
The value set comprises all of the values, of which there shall be at least one, specified by "ElementSetSpecs" (see
clause 50).
16.8       The "ValueSetTypeAssignment" production expands into:
                typereference
                Type
                "::="
                "{" ElementSetSpecs "}"
For all purposes, including the application of encoding rules, this is defined to be exactly equivalent to the use of the
production:




34          Rec. ITU-T X.680 (02/2021)
                                                                                            ISO/IEC 8824-1:2021 (E)

              typereference
              "::="
              Type
              "(" ElementSetSpecs ")"
with the same "Type" and "ElementSetSpecs" specifications.


17       Definition of types and values
17.1     A type shall be specified by the notation "Type":
              Type ::= BuiltinType | ReferencedType | ConstrainedType
17.2     The built-in types of ASN.1 are specified by the notation "BuiltinType", defined as follows:
              BuiltinType ::=
                   BitStringType
              |    BooleanType
              |    CharacterStringType
              |    ChoiceType
              |    DateType
              |    DateTimeType
              |    DurationType
              |    EmbeddedPDVType
              |    EnumeratedType
              |    ExternalType
              |    InstanceOfType
              |    IntegerType
              |    IRIType
              |    NullType
              |    ObjectClassFieldType
              |    ObjectIdentifierType
              |    OctetStringType
              |    RealType
              |    RelativeIRIType
              |    RelativeOIDType
              |    SequenceType
              |    SequenceOfType
              |    SetType
              |    SetOfType
              |    PrefixedType
              |    TimeType
              |    TimeOfDayType

The various "BuiltinType" notations are defined in the following clauses (in this Recommendation | International
Standard unless otherwise stated):
              BitStringType              22
              BooleanType                18
              CharacterStringType        40
              ChoiceType                 29
              DateType                   38.4.1
              DateTimeType               38.4.3
              DurationType               38.4.4
              EmbeddedPDVType            36
              EnumeratedType             20
              ExternalType               37
              InstanceOfType             Rec. ITU-T X.681 | ISO/IEC 8824-2, Annex C
              IntegerType                19
              IRIType                    34
              NullType                   24
              ObjectClassFieldType       Rec. ITU-T X.681 | ISO/IEC 8824-2, 14.1
              ObjectIdentifierType       32
              OctetStringType            23

                                                                            Rec. ITU-T X.680 (02/2021)          35
ISO/IEC 8824-1:2021 (E)

                RealType                     21
                RelativeIRIType              35
                RelativeOIDType              33
                SequenceType                 25
                SequenceOfType               26
                SetType                      27
                SetOfType                    28
                PrefixedType                 31
                TimeType                     38.1.1
                TimeOfDayType                38.4.2
17.3       The referenced types of ASN.1 are specified by the notation "ReferencedType":
                ReferencedType ::=
                    DefinedType
                |   UsefulType
                |   SelectionType
                |   TypeFromObject
                |   ValueSetFromObjects
The "ReferencedType" notation provides an alternative means of referring to some other type (and ultimately to a built-
in type). The various "ReferencedType" notations, and the way in which the type to which they refer is determined, are
specified in the following places in this Recommendation | International Standard unless otherwise stated:
                DefinedType                  14.1
                UsefulType                   45.1
                SelectionType                30
                TypeFromObject               Rec. ITU-T X.681 | ISO/IEC 8824-2, clause 15
                ValueSetFromObjects          Rec. ITU-T X.681 | ISO/IEC 8824-2, clause 15
17.4       The "ConstrainedType" is defined in clause 49.
17.5    This Recommendation | International Standard requires the use of the notation "NamedType" in specifying the
components of the set types, sequence types and choice types. The notation for "NamedType" is:
                NamedType ::= identifier Type
17.6      The "identifier" is used to unambiguously refer to components of a set type, sequence type or choice type in
the value notation, in inner subtype constraints and in component relation constraints (see Rec. ITU-T X.682 | ISO/IEC
8824-3). It is not part of the type, and has no effect on the type.
17.7       A value of some type shall be specified by the notation "Value" or by the notation "XMLValue":
                Value ::=
                    BuiltinValue
                |   ReferencedValue
                |   ObjectClassFieldValue
                XMLValue ::=
                  XMLBuiltinValue
                | XMLObjectClassFieldValue
                    NOTE 1 – "ObjectClassFieldValue" and "XMLObjectClassFieldValue" are defined in Rec. ITU-T X.681 |
                    ISO/IEC 8824-2, 14.6.
                    NOTE 2 – "XMLValue" is only used in "XMLTypedValue".

17.8      If any part of the "XMLValue" production results in an XML start-tag immediately followed by an XML end-
tag, possibly separated by white-space inserted as permitted by 12.1.4 (for example, <field1></field1>), these two XML
tags, and any intervening white-space, can be replaced by a single XML empty-element tag (<field1/>).
     NOTE – If any white-space character, except white-space inserted as permitted by 12.1.4, is present between the final ">"
     character of the start tag and the initial "<" character of the end-tag, the condition above is not satisfied.

17.9     Values of the built-in types of ASN.1 can be specified by the notation "XMLBuiltinValue" (see 17.10) or
"BuiltinValue", defined as follows:
                BuiltinValue ::=
                     BitStringValue
                |    BooleanValue
                |    CharacterStringValue
                |    ChoiceValue

36           Rec. ITU-T X.680 (02/2021)
                                                                                           ISO/IEC 8824-1:2021 (E)

              |   EmbeddedPDVValue
              |   EnumeratedValue
              |   ExternalValue
              |   InstanceOfValue
              |   IntegerValue
              |   IRIValue
              |   NullValue
              |   ObjectIdentifierValue
              |   OctetStringValue
              |   RealValue
              |   RelativeIRIValue
              |   RelativeOIDValue
              |   SequenceValue
              |   SequenceOfValue
              |   SetValue
              |   SetOfValue
              |   PrefixedValue
              |   TimeValue
Each of the various "BuiltinValue" notations is defined in the same subclause as the corresponding "BuiltinType"
notation, as listed in 17.2.
17.10    "XMLBuiltinValue" is defined as follows:
              XMLBuiltinValue ::=
                XMLBitStringValue
              | XMLBooleanValue
              | XMLCharacterStringValue
              | XMLChoiceValue
              | XMLEmbeddedPDVValue
              | XMLEnumeratedValue
              | XMLExternalValue
              | XMLInstanceOfValue
              | XMLIntegerValue
              | XMLIRIValue
              | XMLNullValue
              | XMLObjectIdentifierValue
              | XMLOctetStringValue
              | XMLRealValue
              | XMLRelativeIRIValue
              | XMLRelativeOIDValue
              | XMLSequenceValue
              | XMLSequenceOfValue
              | XMLSetValue
              | XMLSetOfValue
              | XMLPrefixedValue
              | XMLTimeValue
Each of the various "XMLBuiltinValue" notations is defined in the same clause as the corresponding "BuiltinType"
notation, as listed in 17.2 above.
17.11    The referenced values of ASN.1 are specified by the notation "ReferencedValue":
              ReferencedValue ::=
                  DefinedValue
              |   ValueFromObject
The "ReferencedValue" notation provides an alternative means of referring to some other value (and ultimately to a
built-in value). The various "ReferencedValue" notations, and the way in which the value to which they refer is
determined, are specified in the following places (in this Recommendation | International Standard unless otherwise
stated):
         DefinedValue              14.1
         ValueFromObject           Rec. ITU-T X.681 | ISO/IEC 8824-2, clause 15
17.12     Regardless of whether or not a type is a "BuiltinType", "ReferencedType" or "ConstrainedType", its values
can be specified by either a "BuiltinValue" or "ReferencedValue" of that type.

                                                                          Rec. ITU-T X.680 (02/2021)            37
ISO/IEC 8824-1:2021 (E)

17.13  The value of a type referenced using the "NamedType" notation shall be defined by the notation
"NamedValue", or when used as part of an "XMLValue", by the notation "XMLNamedValue". These productions are:
                 NamedValue ::= identifier Value
                 XMLNamedValue ::= "<" & identifier ">" XMLValue "</" & identifier ">"
where the "identifier" is the same as that used in the "NamedType" notation.
     NOTE – The "identifier" is part of the notation, it does not form part of the value itself. It is used to unambiguously refer to the
     components of a set type, sequence type or choice type.

17.14     The implied (see 13.4) or explicit presence of an extension marker (see clause 6) in the definition of a type has
no effect on the value notation. That is, the value notation for a type with an extension marker is exactly the same as if
the extension marker was absent.
     NOTE – Subclause 50.11 prohibits value notation used in a subtype constraint from referencing a value that is not in the
     extension root of the parent type.



18          Notation for the boolean type
18.1        The boolean type (see 3.8.8) shall be referenced by the notation "BooleanType":
                 BooleanType ::= BOOLEAN
18.2        The tag for types defined by this notation is universal class, number 1.
18.3      The value of a boolean type (see 3.8.85 and 3.8.44) shall be defined by the notation "BooleanValue", or when
used as an "XMLValue", by the notation "XMLBooleanValue". These productions are:
                 BooleanValue ::= TRUE | FALSE
                 XMLBooleanValue ::=
                   EmptyElementBoolean
                 | TextBoolean
                 EmptyElementBoolean ::=
                    "<" & "true" "/>"
                 |  "<" & "false" "/>"
                 TextBoolean        ::=
                     extended-true
                 |   extended-false
18.4    If an "EmptyElementBoolean" appears in an "XMLValueAssignment", then there shall be no occurrence of
"TextBoolean" in that "XMLValueAssignment".


19          Notation for the integer type
19.1        The integer type (see 3.8.48) shall be referenced by the notation "IntegerType":
                 IntegerType ::=
                       INTEGER
                 |     INTEGER "{" NamedNumberList "}"

                 NamedNumberList ::=
                    NamedNumber
                 |  NamedNumberList "," NamedNumber
                 NamedNumber ::=
                    identifier "(" SignedNumber ")"
                 |  identifier "(" DefinedValue ")"
                 SignedNumber ::=
                     number
                 |   "-" number
19.2        The second alternative of "SignedNumber" shall not be used if the "number" is zero.




38           Rec. ITU-T X.680 (02/2021)
                                                                                                          ISO/IEC 8824-1:2021 (E)

19.3      The "NamedNumberList" is not significant in the definition of a type. It is used solely in the value notation
specified in 19.9.
19.4       The "valuereference" in "DefinedValue" shall be of type integer.
     NOTE – Since an "identifier" cannot be used to specify the value associated with "NamedNumber", the "DefinedValue" can
     never be misinterpreted as an "IntegerValue". Therefore in the following case
a INTEGER ::= 1
T1 ::= INTEGER { a(2) }
T2 ::= INTEGER { a(3), b(a) }
c T2 ::= b
d T2 ::= a
    c denotes the value 1, since it cannot be a reference to the second nor the third occurrence of a, and d denotes the value 3.

19.5       The value of each "SignedNumber" or "DefinedValue" appearing in the "NamedNumberList" shall be
different, and represents a distinguished value of the integer type.
19.6       Each "identifier" appearing in the "NamedNumberList" shall be different.
19.7       The order of the "NamedNumber"s in the "NamedNumberList" is not significant.
19.8       The tag for types defined by this notation is universal class, number 2.
19.9   The value of an integer type shall be defined by the notation "IntegerValue", or when used as an
"XMLValue", by the notation "XMLIntegerValue". These productions are:
                IntegerValue ::=
                     SignedNumber
                |    identifier
                XMLIntegerValue ::=
                  XMLSignedNumber
                | EmptyElementInteger
                | TextInteger
                XMLSignedNumber ::=
                  number
                | "-" & number
                EmptyElementInteger ::=
                   "<" & identifier "/>"
                TextInteger ::=
                    identifier
19.10    If an "EmptyElementInteger" appears in an "XMLValueAssignment", then there shall be no occurrence of
"TextInteger" in that "XMLValueAssignment".
19.11      The "identifier" in "IntegerValue" and in the last two alternatives for "XMLIntegerValue" shall be one of the
"identifier"s in the "IntegerType" with which the value is associated, and shall represent the corresponding number.
     NOTE – When referencing an integer value for which an "identifier" has been defined, use of the "identifier" form of
     "IntegerValue" and one of the "identifier" forms of "XMLIntegerValue" should be preferred.

19.12      Within an instance of value notation for an integer type with a "NamedNumberList", any occurrence of a
name that is both an "identifier" from the "NamedNumberList" and a reference name shall be interpreted as the
"identifier".
19.13      The second alternative of "XMLSignedNumber" shall not be used if the "number" is zero.


20         Notation for the enumerated type
20.1       The enumerated type (see 3.8.30) shall be referenced by the notation "EnumeratedType":
                EnumeratedType ::=
                   ENUMERATED "{" Enumerations "}"

                Enumerations ::=
                   RootEnumeration
                |  RootEnumeration "," "..." ExceptionSpec
                |  RootEnumeration "," "..." ExceptionSpec "," AdditionalEnumeration

                                                                                        Rec. ITU-T X.680 (02/2021)                  39
ISO/IEC 8824-1:2021 (E)

                 RootEnumeration ::= Enumeration
                 AdditionalEnumeration ::= Enumeration
                 Enumeration ::= EnumerationItem | EnumerationItem "," Enumeration
                 EnumerationItem ::= identifier | NamedNumber
     NOTE 1 – Each value of an "EnumeratedType" has an identifier which is associated with a distinct integer. However, the values
     themselves are not expected to have any integer semantics. Specifying the "NamedNumber" alternative of "EnumerationItem"
     provides control of the representation of the value in order to facilitate compatible extensions.
     NOTE 2 – The numeric values inside the "NamedNumber"s in the "RootEnumeration" are not necessarily ordered or contiguous,
     and the numeric values inside the "NamedNumber"s in the "AdditionalEnumeration" are ordered but not necessarily contiguous.

20.2       For each "NamedNumber", the "identifier" and the "SignedNumber" shall be distinct from all other
"identifier"s and "SignedNumber"s in the "Enumeration". Subclauses 19.2 and 19.4 also apply to each
"NamedNumber".
20.3     Each "EnumerationItem" (in an "EnumeratedType") which is an "identifier" is successively assigned a distinct
non-negative integer. For the "RootEnumeration", the successive integers starting with 0, but excluding any which are
employed in "EnumerationItem"s which are "NamedNumber"s, are assigned.
     NOTE – An integer value is associated with an "EnumerationItem" to assist in the definition of encoding rules. It is not otherwise
     used in the ASN.1 specification.

20.4     The value of each new                   "EnumerationItem"       shall    be   greater    than    all   previously    defined
"AdditionalEnumeration"s in the type.
20.5      When a "NamedNumber" is used in defining an "EnumerationItem" in the "AdditionalEnumeration", the
value associated with it shall be different from the value of all previously defined "EnumerationItem"s (in this type)
regardless of whether the previously defined "EnumerationItem"s occur in the enumeration root or not. For example:
A ::= ENUMERATED {a, b, ..., c(0)}        -- invalid, since both 'a' and 'c' equal 0
B ::= ENUMERATED {a, b, ..., c, d(2)} -- invalid, since both 'c' and 'd' equal 2
C ::= ENUMERATED {a, b(3), ..., c(1)} -- valid, 'c' = 1
D ::= ENUMERATED {a, b, ..., c(2)}        -- valid, 'c' = 2

20.6       The value associated with the first "EnumerationItem" in the "AdditionalEnumeration" alternative that is an
"identifier" (not a "NamedNumber") shall be the smallest value for which an "EnumerationItem" is not defined in the
"RootEnumeration" and all preceding "EnumerationItem"s in the "AdditionalEnumeration" (if any) are smaller. For
example, the following are all valid:
A ::= ENUMERATED {a, b, ..., c}           -- c = 2
B ::= ENUMERATED {a, b, c(0), ..., d} -- d = 3
C ::= ENUMERATED {a, b, ..., c(3), d} -- d = 4
D ::= ENUMERATED {a, z(25), ..., d}   -- d = 1

20.7        The enumerated type has a tag which is universal class, number 10.
20.8   The value of an enumerated type shall be defined by the notation "EnumeratedValue", or when used as an
"XMLValue", by the notation "XMLEnumeratedValue". These productions are:
                 EnumeratedValue ::= identifier
                 XMLEnumeratedValue ::=
                   EmptyElementEnumerated
                 | TextEnumerated
                 EmptyElementEnumerated ::= "<" & identifier "/>"
                 TextEnumerated ::= identifier
20.9     If an "EmptyElementEnumerated" appears in an "XMLValueAssignment", then there shall be no occurrence
of "TextEnumerated" in that "XMLValueAssignment".
20.10      The "identifier" in "EnumeratedValue" and in the two alternatives of "XMLEnumeratedValue" shall be equal
to that of an "identifier" in the "EnumeratedType" sequence with which the value is associated.
20.11      Within an instance of value notation for an enumerated type, any occurrence of a name that is both an
"identifier" from the "Enumeration" and a reference name shall be interpreted as the "identifier".




40           Rec. ITU-T X.680 (02/2021)
                                                                                                      ISO/IEC 8824-1:2021 (E)

21         Notation for the real type
21.1       The real type (see 3.8.60) shall be referenced by the notation "RealType":
                 RealType ::= REAL
21.2       The real type has a tag which is universal class, number 9.
21.3    The abstract values of the real type are the special values PLUS-INFINITY, MINUS-INFINITY, and
NOT-A-NUMBER together with numeric real numbers consisting of either plus zero or minus zero, or capable of being
specified by the following formula involving three integers, M, B and E:

                                                             M x BE

where M (non-zero) is called the mantissa, B (either 2 or 10) the base, and E the exponent. Values with B = 2 ("base"
2 abstract values) and B = 10 ("base" 10 abstract values) are defined as distinct abstract values. Otherwise, values of
M  BE which evaluate to the same numerical value are a single abstract value.
     NOTE – Minus zero and plus zero are two distinct abstract values for a mathematical zero, and the "base" 2 and "base" 10
     abstract values are distinct abstract values for all other numeric real numbers.

21.4      The real type has an associated type which is used to support the value and subtype notations for numeric
values of the real type (in addition to the notation for the special values of the real type and for plus zero and minus
zero).
     NOTE – Encoding rules may define a different type which is used to specify encodings, or may specify encodings without
     reference to the associated type. In particular, the encoding in BER and PER provides a Binary-Coded Decimal (BCD) encoding
     if "base" is 10, and an encoding which permits efficient transformation to and from hardware floating point representations if
     "base" is 2.

21.5    The associated type for value definition (and for subtyping purposes) of the numeric values is (with normative
comments):
           SEQUENCE {
           mantissa INTEGER,
           base INTEGER (2|10),
           exponent INTEGER
                 -- The associated mathematical real number is "mantissa"
                 -- multiplied by "base" raised to the power "exponent"
}
     NOTE 1 – Values represented by "base" 2 and by "base" 10 are considered to be distinct abstract values even if they evaluate to
     the same real number value, and may carry different application semantics.
     NOTE 2 – The notation REAL (WITH COMPONENTS { ... , base (10)}) can be used to restrict the set of values to the
     "base" 10 numeric values (and similarly for "base" 2 numeric values). This notation does not include the values (special real
     values and plus and minus zero) that cannot be represented by the associated type. If required, these can be added using set
     arithmetic.
     NOTE 3 – This type is capable of carrying an exact finite representation of any number which can be stored in typical floating
     point hardware, and of any number with a finite character-decimal representation.

21.6      The value of a real type shall be defined by the notation "RealValue", or when used in an "XMLValue", by
the notation "XMLRealValue":
                 RealValue ::=
                     NumericRealValue
                 |   SpecialRealValue
                 NumericRealValue ::=
                    realnumber
                 |  "-" realnumber
                 |  SequenceValue
                 SpecialRealValue ::=
                      PLUS-INFINITY
                 |    MINUS-INFINITY
                 |    NOT-A-NUMBER
     NOTE – The third alternative of "NumericRealValue" cannot be used for plus zero or minus zero values. These abstract values
     are specified using either the first or the second alternative respectively, with a single "0" character for "realnumber".

                 XMLRealValue ::=
                   XMLNumericRealValue | XMLSpecialRealValue


                                                                                     Rec. ITU-T X.680 (02/2021)                 41
ISO/IEC 8824-1:2021 (E)

                  XMLNumericRealValue ::=
                    realnumber
                  | "-" & realnumber
                  XMLSpecialRealValue ::=
                    EmptyElementReal
                  | TextReal
                  EmptyElementReal ::=
                     "<" & PLUS-INFINITY "/>"
                  |  "<" & MINUS-INFINITY "/>"
                  |  "<" & NOT-A-NUMBER "/>"
                  TextReal ::=
                      "INF"
                  |   "-" & "INF"
                  |   "NaN"
21.7     If an "EmptyElementReal" appears in an "XMLValueAssignment", then there shall be no occurrence of
"TextReal" in that "XMLValueAssignment".
21.8       When the "realnumber" notation is used, it identifies the corresponding "base" 10 abstract value, or plus zero.
When a "realnumber" value is preceded by "-", it identifies the corresponding "base" 10 abstract values that are
negative numbers, or minus zero. If the "RealType" is constrained to "base" 2, the "realnumber" or "-" "realnumber"
identifies the "base" 2 abstract value corresponding either to the decimal value specified by the "realnumber" or to a
locally-defined precision if an exact representation is not possible.


22          Notation for the bitstring type
22.1        The bitstring type (see 3.8.7) shall be referenced by the notation "BitStringType":
                  BitStringType ::=
                       BIT STRING
                  |    BIT STRING "{" NamedBitList "}"

                  NamedBitList ::=
                     NamedBit
                  |  NamedBitList "," NamedBit
                  NamedBit ::=
                     identifier "(" number ")"
                  |  identifier "(" DefinedValue ")"
22.2        The first bit in a bit string is called the leading bit. The final bit in a bit string is called the trailing bit.
     NOTE – This terminology is used in specifying the value notation and in defining encoding rules.

22.3        The "DefinedValue" shall be a reference to a non-negative value of type integer.
22.4     The value of each "number" or "DefinedValue" appearing in the "NamedBitList" shall be different, and is the
number of a distinguished bit in a bitstring value. The leading bit of the bit string is identified by the "number" zero,
with succeeding bits having successive values.
22.5        Each "identifier" appearing in the "NamedBitList" shall be different.
     NOTE 1 – The order of the "NamedBit" production sequences in the "NamedBitList" is not significant.
     NOTE 2 – Since an "identifier" that appears within the "NamedBitList" cannot be used to specify the value associated with a
     "NamedBit", the "DefinedValue" can never be misinterpreted as an "IntegerValue". Therefore in the following case:
             a INTEGER ::= 1
             T1 ::= INTEGER { a(2) }
             T2 ::= BIT STRING { a(3), b(a) }
     the last occurrence of a denotes the value 1, as it cannot be a reference to the second nor the third occurrence of a.

22.6       The presence of a "NamedBitList" has no effect on the set of abstract values of this type. Values containing
1 bits other than the named bits are permitted.
22.7       When a "NamedBitList" is used in defining a bitstring type ASN.1 encoding rules are free to add (or remove)
arbitrarily any trailing 0 bits to (or from) values that are being encoded or decoded. Application designers should


42           Rec. ITU-T X.680 (02/2021)
                                                                                                        ISO/IEC 8824-1:2021 (E)

therefore ensure that different semantics are not associated with such values which differ only in the number of trailing
0 bits.
22.8      This type has a tag which is universal class, number 3.
22.9   The value of a bitstring type shall be defined by the notation "BitStringValue", or when used as an
"XMLValue", by the notation "XMLBitStringValue". These productions are:
               BitStringValue ::=
                   bstring
               |   hstring
               |   "{" IdentifierList "}"
               |   "{" "}"
               |   CONTAINING Value

               IdentifierList ::=
                   identifier
               |   IdentifierList "," identifier
               XMLBitStringValue ::=
                 XMLTypedValue
                 |    xmlbstring
                 |    XMLIdentifierList
               | empty
               XMLIdentifierList ::=
                 EmptyElementList
               | TextList
               EmptyElementList ::=
                  "<" & identifier "/>"
               |  EmptyElementList "<" & identifier "/>"
               TextList ::=
                   identifier
               |   TextList identifier
22.10    If an "EmptyElementList" appears in an "XMLValueAssignment", then there shall be no occurrence of
"TextList" in that "XMLValueAssignment".
22.11     The "XMLTypedValue" alternative shall not be used unless the bitstring has a contents constraint which
includes an ASN.1 type and does not include an ENCODED BY. If this alternative is used, the "XMLTypedValue" shall
be a value of the ASN.1 type in the contents constraint.
22.12     The "XMLIdentifierList" alternative shall not be used unless the bitstring has a "NamedBitList".
22.13      Each "identifier" in "BitStringValue" or in the alternatives of "XMLBitStringValue" shall be the same as an
"identifier" in the "BitStringType" production sequence with which the value is associated.
22.14     The "empty" alternative denotes a bitstring with no bits.
22.15    If the bitstring has named bits, the "BitStringValue" or "XMLBitStringValue" notation denotes a bitstring
value with ones in the bit positions specified by the numbers corresponding to the "identifier"s, and with all other bits
zero.
   NOTE – For a "BitStringType" that has a "NamedBitList", the "{" "}" production sequence in "BitStringValue" and the "empty"
   in "XMLBitStringValue" are used to denote the bitstring which contains no one bits.

22.16      When using the "bstring" or "xmlbstring" notation, the leading bit of the bitstring value is on the left, and the
trailing bit of the bitstring value is on the right.
22.17     When using the "hstring" notation, the most significant bit of each hexadecimal digit corresponds to the
leftmost bit in the bitstring.
   NOTE – This notation does not, in any way, constrain the way encoding rules place a bitstring into octets for transfer.

22.18     The "hstring" notation shall not be used unless the bitstring value consists of a multiple of four bits.
EXAMPLE
'A98A'H

and


                                                                                     Rec. ITU-T X.680 (02/2021)              43
ISO/IEC 8824-1:2021 (E)

'1010100110001010'B

are alternative notations for the same bitstring value. If the type was defined using a "NamedBitList", the (single)
trailing zero does not form part of the value, which is thus 15 bits in length. If the type was defined without a
"NamedBitList", the trailing zero does form part of the value, which is thus 16 bits in length.
22.19     The CONTAINING alternative can only be used if there is a contents constraint on the bitstring type which
includes CONTAINING. The "Value" shall then be value notation for a value of the "Type" in the "ContentsConstraint"
(see Rec. ITU-T X.682 | ISO/IEC 8824-3, clause 11).
     NOTE – This value notation can never appear in a subtype constraint because Rec. ITU-T X.682 | ISO/IEC 8824-3, clause 11.3
     forbids further constraints after a "ContentsConstraint", and the above text forbids its use unless the governor has a
     "ContentsConstraint".

22.20    The CONTAINING alternative shall be used if there is a contents constraint on the bitstring type which does not
contain ENCODED BY.


23         Notation for the octetstring type
23.1       The octetstring type (see 3.8.55) shall be referenced by the notation "OctetStringType":
                OctetStringType ::= OCTET STRING
23.2       This type has a tag which is universal class, number 4.
23.3   The value of an octetstring type shall be defined by the notation "OctetStringValue", or when used as an
"XMLValue", by the notation "XMLOctetStringValue". These productions are:
                OctetStringValue ::=
                    bstring
                |   hstring
                |   CONTAINING Value

                XMLOctetStringValue ::=
                  XMLTypedValue
                | xmlhstring
23.4      The "XMLTypedValue" alternative shall not be used unless the octetstring has a contents constraint which
includes an ASN.1 type and does not include an ENCODED BY. If this alternative is used, the "XMLTypedValue" shall
be a value of the ASN.1 type in the contents constraint.
23.5      In specifying the encoding rules for an octetstring, the octets are referenced by the terms first octet and trailing
octet, and the bits within an octet are referenced by the terms most significant bit and least significant bit.
23.6       When using the "bstring" notation, the left-most bit of the "bstring" notation shall be the most significant bit
of the first octet of the octetstring value. If the "bstring" is not a multiple of eight bits, it shall be interpreted as if it
contained additional zero trailing bits to make it the next multiple of eight.
23.7      When using the "hstring" or "xmlhstring" notation, the left-most hexadecimal digit shall be the most
significant semi-octet of the first octet.
23.8      If the "hstring" is an odd number of hexadecimal digits, it shall be interpreted as if it contained a single
additional trailing zero hexadecimal digit. The "xmlhstring" shall not be an odd number of hexadecimal digits.
23.9      The CONTAINING alternative can only be used if there is a contents constraint on the octetstring type which
includes CONTAINING. The "Value" shall then be value notation for a value of the "Type" in the "ContentsConstraint"
(see Rec. ITU-T X.682 | ISO/IEC 8824-3, clause 11).
     NOTE – This value notation can never appear in a subtype constraint because Rec. ITU-T X.682 | ISO/IEC 8824-3, clause 11.3
     forbids further constraints after a "ContentsConstraint", and the above text forbids its use unless the governor has a
     "ContentsConstraint".

23.10     The CONTAINING alternative shall be used if there is a contents constraint on the octetstring type which does
not contain ENCODED BY.


24         Notation for the null type
24.1       The null type (see 3.8.51) shall be referenced by the notation "NullType":



44           Rec. ITU-T X.680 (02/2021)
                                                                                              ISO/IEC 8824-1:2021 (E)

              NullType ::= NULL
24.2     This type has a tag which is universal class, number 5.
24.3      The value of a null type shall be referenced by the notation "NullValue", or when used as an "XMLValue", by
the notation "XMLNullValue". These productions are:
              NullValue ::= NULL
              XMLNullValue ::= empty


25       Notation for sequence types
25.1     The notation for defining a sequence type (see 3.8.67) shall be the "SequenceType":
              SequenceType ::=
                  SEQUENCE "{" "}"
              |   SEQUENCE "{" ExtensionAndException OptionalExtensionMarker "}"
              |   SEQUENCE "{" ComponentTypeLists "}"

              ExtensionAndException ::= "..." | "..." ExceptionSpec
              OptionalExtensionMarker ::= "," "..." | empty
              ComponentTypeLists ::=
                 RootComponentTypeList
                 |   RootComponentTypeList "," ExtensionAndException ExtensionAdditions
                     OptionalExtensionMarker
              |  RootComponentTypeList "," ExtensionAndException ExtensionAdditions
                     ExtensionEndMarker "," RootComponentTypeList
                 |   ExtensionAndException ExtensionAdditions ExtensionEndMarker ","
                     RootComponentTypeList
              |  ExtensionAndException ExtensionAdditions OptionalExtensionMarker
              RootComponentTypeList ::= ComponentTypeList
              ExtensionEndMarker ::= "," "..."
              ExtensionAdditions ::=
                  "," ExtensionAdditionList
              |   empty
              ExtensionAdditionList ::=
                  ExtensionAddition
              |   ExtensionAdditionList "," ExtensionAddition
              ExtensionAddition ::=
                  ComponentType
              |   ExtensionAdditionGroup
              ExtensionAdditionGroup ::= "[[" VersionNumber ComponentTypeList "]]"
              VersionNumber ::= empty | number ":"
              ComponentTypeList ::=
                 ComponentType
              |  ComponentTypeList "," ComponentType
              ComponentType ::=
                 NamedType
              |  NamedType OPTIONAL
              |  NamedType DEFAULT Value
              |  COMPONENTS OF Type

25.2     For the purposes of the following clauses, a "PrefixedType" is defined to be a textually tagged type if either:
         a)   the "PrefixedType" is a "TaggedType"; or
         b)   the "Type" in the "PrefixedType" is a textually tagged type.



                                                                              Rec. ITU-T X.680 (02/2021)               45
ISO/IEC 8824-1:2021 (E)

25.3      When the "ComponentTypeLists" production occurs within the definition of a module for which automatic
tagging is selected (see 13.3), and none of the occurrences of "NamedType" in any of the first three alternatives for
"ComponentType" is a textually tagged type (see 25.2), then the automatic tagging transformation is selected for the
entire "ComponentTypeLists", otherwise it is not.
     NOTE 1 – The use of the "TaggedType" notation within the definition of the list of components for a sequence type gives control
     of tags to the specifier, as opposed to automatic assignment by the automatic tagging mechanism. Therefore, in the following
     case:
            T ::= SEQUENCE { a INTEGER, b [1] BOOLEAN, c OCTET STRING }
     no automatic tagging is applied to the list of components a, b, c, even if this definition of sequence type T occurs within a module
     for which automatic tagging is selected.
     NOTE 2 – Only those occurrences of the "ComponentTypeLists" production appearing within a module where automatic tagging
     is selected are candidates for transformation by automatic tagging.

25.4       The decision to apply the automatic tagging transformation is taken individually for each occurrence of
"ComponentTypeLists" and prior to the COMPONENTS OF transformation specified by 25.5. However, as specified
in 25.8 to 25.10, the automatic tagging transformation (if applied) is applied after the COMPONENTS OF transformation.
     NOTE – The effect of this is that the application of automatic tags is suppressed by tags textually present in the
     "ComponentTypeLists", but not by tags present in the "Type" following COMPONENTS OF.

25.5      "Type" in the "COMPONENTS OF Type" notation shall be a sequence type. The "COMPONENTS OF Type"
notation shall be used to define the inclusion, at this point in the list of components, of all the component types (of
which there shall be at least one) of the referenced type, except for any extension marker and extension additions that
may be present in the "Type". (Only the "RootComponentTypeList" of the "Type" in the "COMPONENTS OF Type" is
included; extension markers and extension additions, if any, are ignored by the "COMPONENTS OF Type" notation.) Any
subtype constraint applied to the referenced type is ignored by this transformation.
     NOTE – This transformation is logically completed prior to the satisfaction of the requirements in the following subclauses.

25.6      The following subclauses each identify a series of occurrences of "ComponentType" in either the root or the
extension additions or both. The rule of 25.6.1 shall apply to all such series.
25.6.1  Where there are one or more consecutive occurrences of "ComponentType" that are all marked OPTIONAL or
DEFAULT, the tags of those "ComponentType"s and of any immediately following component type in the series shall be
distinct (see 31.2). If automatic tagging was selected, the requirement that tags be distinct applies only after automatic
tagging has been performed, and will always be satisfied.
25.6.2      Subclause 25.6.1 shall apply to the series of "ComponentType"s in the root.
25.6.3 Subclause 25.6.1 shall apply to the complete series of "ComponentType"s in the root or in the extension
additions, in the textual order of their occurrence in the type definition (ignoring all version brackets and ellipsis
notation). (See also 52.7.)
25.7      When the third or fourth alternative of "ComponentTypeLists" is used, all "ComponentType"s in extension
additions shall have tags which are distinct from the tags of the textually following "ComponentType"s up to and
including the first such "ComponentType" that is not marked OPTIONAL or DEFAULT in the trailing
"RootComponentTypeList", if any. (See also 52.7.)
25.8     The automatic tagging transformation of an occurrence of "ComponentTypeLists" is logically performed after
the transformation specified by 25.5, but only if 25.3 determines that it shall apply to that occurrence of
"ComponentTypeLists". Automatic tagging transformation impacts each "ComponentType" of the
"ComponentTypeLists" by replacing the "Type" originally in the "NamedType" production with a replacement
"TaggedType" occurrence specified in 25.10.
25.9   If automatic tagging is in effect and the "ComponentType"s in the extension root have no tags, then no
"ComponentType" within the "ExtensionAdditionList" shall be a textually tagged type.
25.10       If automatic tagging is in effect, the replacement "TaggedType" is specified as follows:
            a)   the replacement "TaggedType" notation uses the "Tag Type" alternative;
            b)   the "Class" of the replacement "TaggedType" is empty (i.e., tagging is context-specific);
            c)   the "ClassNumber" in the replacement "TaggedType" is tag value zero for the first "ComponentType" in
                 the "RootComponentTypeList", one for the second, and so on, proceeding with increasing tag numbers;
            d)   the "ClassNumber" in the replacement "TaggedType" of the first "ComponentType" in the
                 "ExtensionAdditionList" is zero if the "RootComponentTypeList" is missing, else it is one greater than
                 the largest "ClassNumber" in the "RootComponentTypeList", with the next "ComponentType" in the
                 "ExtensionAdditionList" having a "ClassNumber" one greater than the first, and so on, proceeding with
                 increasing tag numbers;


46           Rec. ITU-T X.680 (02/2021)
                                                                                                      ISO/IEC 8824-1:2021 (E)

          e)   the "Type" in the replacement "TaggedType" is the original "Type" being replaced.
   NOTE 1 – The rules governing specification of implicit tagging or explicit tagging for replacement "TaggedType"s are provided
   by 31.2.7. Automatic tagging is always implicit tagging unless the "Type" is a choice type or an open type notation, or a
   "DummyReference" (see Rec. ITU-T X.683 | ISO/IEC 8824-4, 8.3), in which case it is explicit tagging.
   NOTE 2 – Once 25.8 is satisfied, the tags of the components are completely determined, and are not modified even when the
   sequence type is referenced in the definition of a component within another "ComponentTypeLists" for which automatic tagging
   transformation applies. Thus, in the following case:
          T ::= SEQUENCE { a         Ta,    b     Tb,   c    Tc }
          E ::= SEQUENCE { f1        E1,    f2    T,    f3   E3 }
   automatic tagging applied to the components of E never affects the tags attached to components a, b and c of T, whatever the
   tagging environment of T. If T is defined in an automatic tagging environment and E is not in an automatic tagging environment,
   automatic tagging is still applied to components a, b and c of T.
   NOTE 3 – When a sequence type appears as the "Type" in "COMPONENTS OF Type", each occurrence of "ComponentType" in it
   is duplicated by the application of 25.5 prior to the possible application of automatic tagging to the referencing sequence type.
   Thus, in the following case:
          T ::= SEQUENCE { a        Ta,    b    SEQUENCE { b1     T1,   b2    T2,   b3   T3},    c Tc }
          W ::= SEQUENCE { x        Wx,    COMPONENTS OF      T, y    Wy }
   the tags of a, b, and c within T need not be the same as the tags of a, b, and c within W if W has been defined in an automatic
   tagging environment, but the tags of b1, b2 and b3 are the same in both T and W. In other words, the automatic tagging
   transformation is only applied once to a given "ComponentTypeLists".
   NOTE 4 – Subtyping has no impact on automatic tagging.
   NOTE 5 – When automatic tagging is in place, insertion of new components at any location other than the extension insertion
   point (see 3.8.35) may result in changes to other components due to the side effect of modifying the tags thus causing
   interworking problems with an older version of the specification.

25.11     If OPTIONAL or DEFAULT are present, the corresponding value may be omitted from a value of the new type.
25.12    If DEFAULT occurs, the omission of a value for that type shall be exactly equivalent to the insertion of the
value defined by "Value", which shall be a value notation for a value of the type defined by "Type" in the
"NamedType" production sequence.
25.13     The value corresponding to an "ExtensionAdditionGroup" (all components together) is optional. However, if
such a value is present, then the value corresponding to the components within the bracketed "ComponentTypeList" that
are not marked OPTIONAL or DEFAULT shall be present.
25.14     The "identifier"s in all "NamedType" production sequences of the "ComponentTypeLists" (together with
those obtained by expansion of COMPONENTS OF) shall all be distinct.
25.15     A value for a given extension addition type shall not be specified unless there are values specified for all
extension addition types not marked OPTIONAL or DEFAULT that lie logically between the extension addition type and
the extension root.
   NOTE 1 – Where the type has grown from the extension root (version 1) through version 2 to version 3 by the addition of
   extension additions, the presence in an encoding of any addition from version 3 requires the presence of an encoding of all
   additions in version 2 that are not marked OPTIONAL or DEFAULT.
   NOTE 2 – "ComponentType"s that are extension additions but not contained within an "ExtensionAdditionGroup" should always
   be encoded if they are not marked OPTIONAL or DEFAULT, except when the abstract value is being relayed from a sender that is
   using an earlier version of the abstract syntax in which the "ComponentType" is not defined.
   NOTE 3 – Use of the "ExtensionAdditionGroup" production is recommended because:
           a)    it can result in more compact encodings depending on the encoding rules (e.g., PER);
           b) the syntax is more precise in that it clearly indicates that a value of a type defined in the "ExtensionAdditionList"
                and not marked OPTIONAL or DEFAULT should always be present in an encoding if the extension addition group in
                which it is defined is encoded (compare with Note 1);
           c)    the syntax makes it clear which types in an "ExtensionAdditionList" must as a group be supported by an
           application.

25.16     A "VersionNumber" shall be used only if all "ExtensionAdditions"s and "ExtensionAdditionAlternatives",
within the module are "ExtensionAdditionGroup"s or "ExtensionAdditionAlternativesGroup"s with "VersionNumber"s.
The "number" in each "VersionNumber" of an "ExtensionAdditionGroup" shall be greater than or equal to two, and
shall be greater than the "number" in any preceding "ExtensionAdditionGroup" within an insertion point.
   NOTE 1 – The convention used here is that the specification with no extension addition groups is version 1, thus the first added
   extension addition group will have a number greater than or equal to 2. Where a single "ExtensionAddition" is needed for an
   "ExtensionAdditions", an "ExtensionAdditionGroup" can be used with a single "ExtensionAddition".
   NOTE 2 – The restrictions on use of "VersionNumber" apply only within a single module and impose no constraints on imported
   types.

25.17     All sequence types have a tag which is universal class, number 16.


                                                                                    Rec. ITU-T X.680 (02/2021)                  47
ISO/IEC 8824-1:2021 (E)

     NOTE – Sequence-of types have the same tag as sequence types (see 26.2).

25.18  The notation for defining a value of a sequence type shall be "SequenceValue", or when used as an
"XMLValue", "XMLSequenceValue". These productions are:
                 SequenceValue ::=
                     "{" ComponentValueList "}"
                 |   "{" "}"
                 ComponentValueList ::=
                    NamedValue
                 |  ComponentValueList "," NamedValue
                 XMLSequenceValue ::=
                   XMLComponentValueList
                 | empty
                 XMLComponentValueList ::=
                   XMLNamedValue
                 | XMLComponentValueList XMLNamedValue
25.19      The "{" "}" or "empty" notation shall only be used if:
           a)    all "ComponentType" sequences in the "SequenceType" are marked DEFAULT or OPTIONAL, and all
                 values are omitted; or
           b)    the type notation was SEQUENCE{}.
25.20    There shall be one "NamedValue" or "XMLNamedValue" for each "NamedType" in the "SequenceType"
which is not marked OPTIONAL or DEFAULT, and the values shall be in the same order as the corresponding
"NamedType" sequences.


26         Notation for sequence-of types
26.1       The notation for defining a sequence-of type (see 3.8.68) from another type shall be the "SequenceOfType".
                 SequenceOfType ::= SEQUENCE OF Type | SEQUENCE OF NamedType
     NOTE – If an initial letter which is upper-case is needed for an XML tag name used in XML Value Notation for the
     "SequenceOfType", then the first alternative should be used. (The XML tag name is then formed from the name of the "Type".)

26.2       All sequence-of types have a tag which is universal class, number 16.
     NOTE – Sequence types have the same tag as sequence-of types (see 25.17).

26.3   The notation for defining a value of a sequence-of type shall be the "SequenceOfValue", or when used as an
"XMLValue", "XMLSequenceOfValue". These productions are:
                 SequenceOfValue ::=
                     "{" ValueList "}"
                 |   "{" NamedValueList "}"
                 |   "{" "}"
                 ValueList ::=
                     Value
                 |   ValueList "," Value
                 NamedValueList ::=
                    NamedValue
                 |  NamedValueList "," NamedValue
                 XMLSequenceOfValue ::=
                   XMLValueList
                 | XMLDelimitedItemList
                 | empty
                 XMLValueList ::=
                   XMLValueOrEmpty
                 | XMLValueOrEmpty XMLValueList




48           Rec. ITU-T X.680 (02/2021)
                                                                                                ISO/IEC 8824-1:2021 (E)

                XMLValueOrEmpty ::=
                  XMLValue
                | "<" & NonParameterizedTypeName "/>"
                XMLDelimitedItemList ::=
                  XMLDelimitedItem
                | XMLDelimitedItem XMLDelimitedItemList
                XMLDelimitedItem ::=
                  "<" & NonParameterizedTypeName ">" XMLValue
                       "</" & NonParameterizedTypeName ">"
                | "<" & identifier ">" XMLValue "</" & identifier ">"
The "{" "}" or "empty" notation is used when the "SequenceOfValue" or "XMLSequenceOfValue" is an empty list.
   NOTE – Semantic significance may be placed on the order of these values.

26.4     If the"XMLValue" for the component is "empty", then the second alternative of "XMLValueOrEmpty" shall
be chosen to represent that value of the component.
   NOTE – This occurs only for SEQUENCE OF NULL.

26.5      The "XMLValueList" or "XMLDelimitedItemList" productions shall be used in accordance with column 2 of
Table 5, where the "Type" of the component is listed in column 1.

               Table 5 – "XMLSequenceOfValue" and "XMLSetOfValue" notation for ASN.1 types

                   ASN.1 type                                            XML value notation
    BitStringType                            XMLDelimitedItemList
    BooleanType                              See 26.6
    CharacterStringType                      XMLDelimitedItemList
    ChoiceType                               XMLValueList
    EmbeddedPDVType                          XMLDelimitedItemList
    EnumeratedType                           See 26.7
    ExternalType                             XMLDelimitedItemList
    InstanceOfType                           See Rec. ITU-T X.681 | ISO/IEC 8824-2, C.9
    IntegerType                              XMLDelimitedItemList
    IRIType                                  XMLDelimitedItemList
    NullType                                 XMLValueList
    ObjectClassFieldType                     See Rec. ITU-T X.681 | ISO/IEC 8824-2, 14.10 and 14.11
    ObjectIdentifierType                     XMLDelimitedItemList
    OctetStringType                          XMLDelimitedItemList
    RealType                                 XMLDelimitedItemList
    RelativeIRIType                          XMLDelimitedItemList
    RelativeOIDType                          XMLDelimitedItemList
    SequenceType                             XMLDelimitedItemList
    SequenceOfType                           XMLDelimitedItemList
    SetType                                  XMLDelimitedItemList
    SetOfType                                XMLDelimitedItemList
    PrefixedType                             See 26.10.1
    UsefulType (GeneralizedTime)             XMLDelimitedItemList
    UsefulType (UTCTime)                     XMLDelimitedItemList
    UsefulType (ObjectDescriptor)            XMLDelimitedItemList
    TypeFromObject                           See Rec. ITU-T X.681 | ISO/IEC 8824-2, 15.6
    ValueSetFromObjects                      See Rec. ITU-T X.681 | ISO/IEC 8824-2, 15.6

26.6     If "EmptyElementBoolean" is used for the value of a boolean type, then "XMLValueList" shall be used;
otherwise, "XMLDelimitedItemList" shall be used.
26.7      If "EmptyElementEnumerated" is used for the value of an enumerated type, then "XMLValueList" shall be
used; otherwise, "XMLDelimitedItemList" shall be used.


                                                                                Rec. ITU-T X.680 (02/2021)          49
ISO/IEC 8824-1:2021 (E)

26.8   If the "Type" of the component is a "DefinedType" then the type which determines the
"XMLSequenceOfValue" notation shall be the type referenced by the "DefinedType" (see 14.1).
26.9      The second alternative of "XMLDelimitedItem" shall be used if and only if the "SequenceOfType" contains
an "identifier", and the "identifier" in the "XMLDelimitedItem" shall be that "identifier".
26.10     If the first alternative of "XMLDelimitedItem" is used, then if the component of the sequence-of type (after
ignoring any occurrences of "TypePrefix") is a "typereference" or an "ExternalTypeReference", then the
"NonParameterizedTypeName" shall be the "typereference" or the "typereference" in the "ExternalTypeReference",
respectively; otherwise it shall be the "xmlasn1typename" specified in Table 4 corresponding to the built-in type of the
component.
26.10.1 If the "Type" of the component is a "PrefixedType", then the type which determines the
"XMLSequenceOfValue" alternative and the "xmlasn1typename" (if required) shall be the "Type" in the
"PrefixedType" (see 31.1.5). If this is itself a "PrefixedType", a "ConstrainedType" or a "SelectionType", then these
subclauses of 26.10 shall be recursively applied.
26.10.2 If the "Type" of the component is a "ConstrainedType", then the type which determines the
"XMLSequenceOfValue" alternative and the "xmlasn1typename" (if required) shall be the "Type" in the
"ConstrainedType" (see 49.1). If this is itself a "PrefixedType", a "ConstrainedType" or a "SelectionType", then these
subclauses of 26.10 shall be recursively applied.
26.10.3 If the "Type" of the component is a "SelectionType", then the type which determines the
"XMLSequenceOfValue" alternative and the "xmlasn1typename" (if required) notation shall be the type referenced by
the "SelectionType" (see clause 30). If this is itself a "PrefixedType", a "ConstrainedType" or a "SelectionType", then
these subclauses of 26.10 shall be recursively applied.
26.11  If the first alternative of "SequenceOfType" is used, then the first alternative of "SequenceOfValue" shall be
used. Each "Value" in the "ValueList" of "SequenceOfValue", and each "XMLValue" in the alternatives of
"XMLSequenceOfValue" shall be of the type specified in the "SequenceOfType".
26.12     If the second alternative of "SequenceOfType" is used, then the second alternative of "SequenceOfValue"
shall be used, and each "NamedValue" in the "NamedValueList" shall contain a "Value" of the type specified in the
"NamedType" of the "SequenceOfType". The "identifier" in the "NamedValue"s shall be the "identifier" in the
"NamedType" of the "SequenceOfType".


27          Notation for set types
27.1        The notation for defining a set type (see 3.8.72) from other types shall be the "SetType":
                 SetType ::=
                     SET "{" "}"
                 |   SET "{" ExtensionAndException OptionalExtensionMarker "}"
                 |   SET "{" ComponentTypeLists "}"

"ComponentTypeLists", "ExtensionAndException" and "OptionalExtensionMarker" are specified in 25.1.
27.2      "Type" in the "COMPONENTS OF Type" notation shall be a set type. The "COMPONENTS OF Type" notation
shall be used to define the inclusion, at this point in the list of components, of all the component types of the referenced
type, except for any extension marker and extension additions that may be present in the "Type". (Only the
"RootComponentTypeList" of the "Type" in the "COMPONENTS OF Type" is included; extension markers and extension
additions, if any, are ignored by the "COMPONENTS OF Type" notation.) Any subtype constraint applied to the
referenced type is ignored by this transformation.
     NOTE – This transformation is logically completed prior to the satisfaction of the requirements in the following subclauses.

27.3    The "ComponentType" types in a set type shall all have different tags (see 31.2). The tag of each new
"ComponentType" added to the "ExtensionAdditions" shall be canonically greater (see 8.6) than those of the other
components in the "ExtensionAdditions".
     NOTE – Where the "TagDefault" for the module in which this notation appears is AUTOMATIC TAGS, this is achieved
     regardless of the actual "ComponentType"s, as a result of the application of 25.8. (See also 52.7.)

27.4        Subclauses 25.3 and 25.8 to 25.14 also apply to set types.
27.5        All set types have a tag which is universal class, number 17.
     NOTE – Set-of types have the same tag as set types (see 28.2).

27.6        There shall be no semantics associated with the order of values in a set type.



50           Rec. ITU-T X.680 (02/2021)
                                                                                                  ISO/IEC 8824-1:2021 (E)

27.7   The notation for defining the value of a set type shall be "SetValue", or when used as an "XMLValue",
"XMLSetValue". These productions are:
                 SetValue ::=
                     "{" ComponentValueList "}"
                 |   "{" "}"
                 XMLSetValue ::=
                   XMLComponentValueList
                 | empty
"ComponentValueList" and "XMLComponentValueList" are specified in 25.18.
27.8       The "SetValue" and "XMLSetValue" shall only be "{" "}" and "empty" respectively if:
           a)    all "ComponentType" sequences in the "SetType" are marked DEFAULT or OPTIONAL, and all values are
                 omitted; or
           b)    the type notation was SET{}.
27.9     There shall be one "NamedValue" or "XMLNamedValue" for each "NamedType" in the "SetType" which is
not marked OPTIONAL or DEFAULT.
     NOTE – These "NamedValue"s or "XMLNamedValue"s may appear in any order.



28         Notation for set-of types
28.1       The notation for defining a set-of type (see 3.8.73) from another type shall be the "SetOfType":
                 SetOfType ::=
                     SET OF Type
                 |   SET OF NamedType
     NOTE – If an initial letter which is upper-case is needed for an XML tag name used in XML Value Notation for the
     "SetOfType", then the first alternative should be used. (The XML tag name is then formed from the name of the "Type".)

28.2       All set-of types have a tag which is universal class, number 17.
     NOTE – Set types have the same tag as set-of types (see 27.5).

28.3   The notation for defining a value of a set-of type shall be the "SetOfValue", or when used as an "XMLValue",
"XMLSetOfValue". These productions are:
                 SetOfValue ::=
                     "{" ValueList "}"
                 |   "{" NamedValueList "}"
                 |   "{" "}"
                 XMLSetOfValue ::=
                   XMLValueList
                 | XMLDelimitedItemList
                 | empty
"ValueList", "NamedValueList" and the alternatives of "XMLSetOfValue" are specified in 26.3, and the choice of
alternative is the same as if "XMLSequenceOfValue" had been used. The "{" "}" or "empty" notation is used when the
"SetOfValue" or "XMLSetOfValue" is an empty list.
     NOTE 1 – Semantic significance should not be placed on the order of these values.
     NOTE 2 – Encoding rules are not required to preserve the order of these values.
     NOTE 3 – The set-of type is not a mathematical set of values, thus, as an example, for SET OF INTEGER the values { 1 } and
     { 1 1 } are distinct.

28.4      If the first alternative of "SetOfType" is used, then the first alternative of "SetOfValue" shall be used. Each
"Value" in the "ValueList" of "SetOfValue", and each "XMLValue" in the alternatives of "XMLSetOfValue" shall be of
the type specified in the "SetOfType".
28.5      If the second alternative of "SetOfType" is used, then the second alternative of "SetOfValue" shall be used,
and each "NamedValue" sequence in the "NamedValueList" shall contain a "Value" of the type specified in the
"NamedType" of the "SetOfType". The "identifier" in the "NamedValue"s shall be the "identifier" in the "NamedType"
of the "SetOfType".




                                                                                  Rec. ITU-T X.680 (02/2021)                51
ISO/IEC 8824-1:2021 (E)

29         Notation for choice types
29.1       The notation for defining a choice type (see 3.8.14) from other types shall be the "ChoiceType":
                 ChoiceType ::= CHOICE "{" AlternativeTypeLists "}"
                 AlternativeTypeLists ::=
                     RootAlternativeTypeList
                 |   RootAlternativeTypeList ","
                          ExtensionAndException ExtensionAdditionAlternatives
                          OptionalExtensionMarker
                 RootAlternativeTypeList ::= AlternativeTypeList
                 ExtensionAdditionAlternatives ::=
                     "," ExtensionAdditionAlternativesList
                 |   empty
                 ExtensionAdditionAlternativesList ::=
                     ExtensionAdditionAlternative
                 |   ExtensionAdditionAlternativesList "," ExtensionAdditionAlternative
                 ExtensionAdditionAlternative ::=
                     ExtensionAdditionAlternativesGroup
                 |   NamedType
                 ExtensionAdditionAlternativesGroup ::=
                     "[[" VersionNumber AlternativeTypeList "]]"
                 AlternativeTypeList ::=
                     NamedType
                 |   AlternativeTypeList "," NamedType
     NOTE – "T ::= CHOICE { a        A }" and A are not the same type, and may be encoded differently by encoding rules.

29.2       When the "AlternativeTypeLists" production occurs within the definition of a module for which automatic
tagging is selected (see 13.3), and none of the occurrences of "NamedType" in any "AlternativeTypeList" is a textually
tagged type (see 25.2), the automatic tagging transformation is selected for the entire "AlternativeTypeLists", otherwise
it is not.
29.3      The types defined in the "AlternativeTypeList" productions in an "AlternativeTypeLists" shall have distinct
tags (see 31.2, and 52.7). If automatic tagging was selected, the requirement that tags be distinct applies only after
automatic tagging has been performed, and will always be satisfied.
29.4   If automatic tagging is in effect and the "NamedType"s in the extension root have no tags, then no
"NamedType" within the "ExtensionAdditionAlternativesList" shall be a textually tagged type.
29.5    The automatic tagging transformation impacts each "NamedType" of the "AlternativeTypeLists" by replacing
the "Type" originally in the "NamedType" production with a replacement "TaggedType". The replacement
"TaggedType" is specified as follows:
           a)    the replacement "TaggedType" notation uses the "Tag Type" alternative;
           b)    the "Class" of the replacement "TaggedType" is empty (i.e., tagging is context-specific);
           c)    the "ClassNumber" in the replacement "TaggedType" is tag value zero for the first "NamedType" in the
                 "RootAlternativeTypeList", one for the second, and so on, proceeding with increasing tag numbers;
           d)    the "ClassNumber" in the replacement "TaggedType" of the first "NamedType" in the
                 "ExtensionAdditionAlternativesList" is one greater than the largest "ClassNumber" in the
                 "RootAlternativeTypeList", with the next "NamedType" in the "ExtensionAdditionAlternativesList"
                 having a "ClassNumber" one greater than the first, and so on, proceeding with increasing tag numbers;
           e)    the "Type" in the replacement "TaggedType" is the original "Type" being replaced.
     NOTE 1 – The rules governing specification of implicit tagging or explicit tagging for replacement "TaggedType"s are provided
     by 31.2.7. Automatic tagging is always implicit tagging unless the "Type" is an untagged choice type or an untagged open type
     notation, or an untagged "DummyReference" (see Rec. ITU-T X.683 | ISO/IEC 8824-4, 8.3), in which case it is explicit tagging.
     NOTE 2 – Once automatic tagging has been applied, the tags of the components are completely determined, and are not modified
     even when the choice type is referenced in the definition of an alternative within another "AlternativeTypeLists" for which
     automatic tagging transformation applies. Thus, in the following case:
           T ::= CHOICE { a Ta, b Tb, c Tc }
           E ::= CHOICE {f1 E1, f2 T, f3 E3}



52           Rec. ITU-T X.680 (02/2021)
                                                                                                     ISO/IEC 8824-1:2021 (E)

    automatic tagging applied to the components of E never affects the tags attached to components a, b and c of T, whatever the
    tagging environment of T. If T is defined in an automatic tagging environment and E is not in an automatic tagging environment,
    automatic tagging is still applied to components a, b and c of T.
    NOTE 3 – Subtyping does not affect automatic tagging.
    NOTE 4 – When automatic tagging is in place, insertion of new alternatives at any location other than the extension insertion
    point (see 3.8.35) may result in changes to other alternatives due to the side effect of modifying the tags thus causing
    interworking problems with an older version of the specification.

29.6     "VersionNumber" is defined in 25.1, and the restrictions on consistent use of "VersionNumber" throughout a
module that are specified in 25.16 shall apply to the use of "number"s within this production.
29.7      The tag of each new "NamedType" added to the "ExtensionAdditionAlternativesList" shall be canonically
greater (see 8.6) than those of the other alternatives in the "ExtensionAdditionAlternativesList", and shall be the last
"NamedType" in the "ExtensionAdditionAlternativesList".
29.8      The choice type contains values which do not all have the same tag. (The tag depends on the alternative which
contributed the value to the choice type.)
29.9      When this type does not have an extension marker and is used in a place where this Recommendation |
International Standard requires the use of types with distinct tags (see 29.3), all possible tags of values of the choice
type shall be considered in such requirement. The following examples which assume that the "TagDefault" is not
AUTOMATIC TAGS illustrate this requirement.

EXAMPLES
1            A ::= CHOICE {
b         B,
c         NULL}
          B ::= CHOICE {
d         [0] NULL,
e         [1] NULL}
2         A ::= CHOICE {
b         B,
c         C}
          B ::= CHOICE {
d         [0] NULL,
e         [1] NULL}
          C ::= CHOICE {
f         [2] NULL,
g         [3] NULL}

3         (Incorrect)
          A ::= CHOICE {
b         B,
c         C}
               B ::= CHOICE {
d         [0] NULL,
e         [1] NULL}
               C ::= CHOICE {
f         [0] NULL,
g         [1] NULL}

Examples 1 and 2 are correct uses of the notation. Example 3 is incorrect without automatic tagging, as the tags for
types d and f are identical, as well as for e and g.
29.10  The "identifier"s of all "NamedType"s in the "AlternativeTypeLists" shall differ from those of the other
"NamedType"s in that list.
29.11  The notation for defining the value of a choice type shall be the "ChoiceValue", or when used as an
"XMLValue", "XMLChoiceValue". These productions are:
                ChoiceValue ::= identifier ":" Value
                XMLChoiceValue ::= "<" & identifier ">" XMLValue "</" & identifier ">"
29.12     "Value" or "XMLValue" shall be a notation for a value of the type in the "AlternativeTypeLists" that is named
by the "identifier".



                                                                                    Rec. ITU-T X.680 (02/2021)                 53
ISO/IEC 8824-1:2021 (E)

30          Notation for selection types
30.1        The notation for defining a selection type (see 3.8.66) shall be "SelectionType":
                 SelectionType ::= identifier "<" Type
where "Type" denotes a choice type, and "identifier" is that of some "NamedType" appearing in the
"AlternativeTypeLists" of the definition of that choice type.
30.2      When "Type" denotes a constrained type, the selection is performed on the parent type, ignoring any subtype
constraint on the parent type.
30.3       Where the "SelectionType" is used as a "NamedType", the "identifier" of the "NamedType" is present, as well
as the "identifier" of the "SelectionType".
30.4      Where the "SelectionType" is used as a "Type", the "identifier" is retained and the type denoted is that of the
selected alternative.
30.5      The notation for a value of a selection type shall be the notation for a value of the type referenced by the
"SelectionType".


31          Notation for prefixed types

31.1        General
31.1.1 A prefixed type (see 3.8.78) is a new type which is isomorphic with an old type, but which has a different or
additional tag and may have a different or additional associated encoding instructions.
31.1.2      A prefixed type is either a "TaggedType" or an "EncodingPrefixedType".
31.1.3 A prefixed type which is a tagged type is mainly of use where this Recommendation | International Standard
requires the use of types with distinct tags (see 25.6 to 25.7, 27.3 and 29.3). The use of a "TagDefault" of AUTOMATIC
TAGS in a module allows this to be accomplished without the explicit appearance of "TaggedType" in that module.
     NOTE – Where a protocol determines that values from several data types may be transmitted at any moment in time, distinct tags
     may be needed to enable the recipient to correctly decode the value.

31.1.4 The assignment of an encoding instruction using an "EncodingPrefixedType" is only relevant to the encodings
identified by the associated encoding reference and has no effect on the abstract values of the type.
31.1.5      The notation for a prefixed type shall be "PrefixedType":
                 PrefixedType ::=
                      TaggedType
                 |    EncodingPrefixedType
     NOTE – Specification of the syntax for "PrefixedType" would be simpler and clearer if tagging was described as the assignment
     of an encoding instruction. However, historically, tagging was introduced in the earliest versions of the ASN.1 specifications, and
     can affect the legality of a type definition. Minimum changes to the concepts of tagging (and the associated syntactic
     descriptions) were made when encoding prefixed types were introduced. Tagging also differs syntactically from assignment of
     encoding instructions: the specification that tagging is EXPLICIT or IMPLICIT occurs following the closing "]" of the tag, it is
     not contained within the paired "[" and "]" as is the case with normal encoding instructions.

31.1.6 The notation for a value of a "PrefixedType" shall be "PrefixedValue", or when used as an "XMLValue",
"XMLPrefixedValue". These productions are:
                 PrefixedValue ::= Value
                 XMLPrefixedValue ::= XMLValue
where "Value" or "XMLValue" is a notation for a value of the "Type" in the "TaggedType" or the
"EncodingPrefixedType" of the "PrefixedType".
     NOTE 1 – Neither the "Tag" nor any part of the "EncodingPrefix" appears in this notation.
     NOTE 2 – Encoding instructions can also be assigned to a type in an encoding control section (see clause 54). Such an
     assignment has no effect on the value notation for a type.




54           Rec. ITU-T X.680 (02/2021)
                                                                                                   ISO/IEC 8824-1:2021 (E)

31.2      The tagged type
31.2.1    The notation for a tagged type shall be "TaggedType":
               TaggedType ::=
                   Tag Type
               |   Tag IMPLICIT Type
               |   Tag EXPLICIT Type
               Tag ::= "[" EncodingReference Class ClassNumber "]"
               EncodingReference ::=
                   encodingreference ":"
               |   empty
               ClassNumber ::=
                   number
               |   DefinedValue
               Class ::=
                    UNIVERSAL
               |    APPLICATION
               |    PRIVATE
               |    empty
31.2.2 When used in "Tag", the "encodingreference" shall be TAG. The "EncodingReference" in "Tag" shall not be
"empty" unless the default encoding reference for the module is TAG (see 13.5).
31.2.3    The "valuereference" in "DefinedValue" shall be of type integer, and assigned a non-negative value.
31.2.4 The new type is isomorphic with the old type, but has a tag with class "Class" and number "ClassNumber",
except when "Class" is "empty", in which case the tag is context-specific class and number is "ClassNumber".
31.2.5 The "Class" shall not be UNIVERSAL except for types defined in this Recommendation | International
Standard.
   NOTE 1 – Use of universal class tags are agreed from time-to-time by ITU-T and ISO.
   NOTE 2 – Subclause G.2.12 contains guidance and hints on stylistic use of tag classes.

31.2.6 All application of tags is either implicit tagging or explicit tagging. Implicit tagging indicates, for those
encoding rules which provide the option, that explicit identification of the original tag of the "Type" in the
"TaggedType" is not needed during transfer.
   NOTE – It can be useful to retain the old tag where this was universal class, and hence unambiguously identifies the old type
   without knowledge of the ASN.1 definition of the new type. Minimum transfer octets is, however, normally achieved by the use
   of IMPLICIT. An example of an encoding using IMPLICIT is given in Rec. ITU-T X.690 | ISO/IEC 8825-1.

31.2.7    The tagging construction specifies explicit tagging if any of the following holds:
          a)   the "Tag EXPLICIT Type" alternative is used;
          b)   the "Tag Type" alternative is used and the value of "TagDefault" for the module is either EXPLICIT
               TAGS or is empty;
          c)   the "Tag Type" alternative is used and the value of "TagDefault" for the module is IMPLICIT TAGS or
               AUTOMATIC TAGS, but the type defined by "Type" is an untagged choice type, an untagged open type, or
               an untagged "DummyReference" (see Rec. ITU-T X.683 | ISO/IEC 8824-4, 8.3).
The tagging construction specifies implicit tagging otherwise.
31.2.8 If the "Class" is "empty", there are no restrictions on the use of "Tag", other than those implied by the
requirement for distinct tags in 25.6 to 25.7, 27.3 and 29.3.
31.2.9 The IMPLICIT alternative shall not be used if the type defined by "Type" is an untagged choice type or an
untagged open type or an untagged "DummyReference" (see Rec. ITU-T X.683 | ISO/IEC 8824-4, 8.3).

31.3      The encoding prefixed type
31.3.1    The notation for an encoding prefixed type shall be "EncodingPrefixedType":
               EncodingPrefixedType ::=
               EncodingPrefix Type


                                                                                    Rec. ITU-T X.680 (02/2021)               55
ISO/IEC 8824-1:2021 (E)

                 EncodingPrefix ::=
                 "[" EncodingReference EncodingInstruction "]"
"EncodingReference" is defined in 31.2.1.
31.3.2 The "EncodingInstruction" production is specified in the Recommendation | International Standard identified
by the "EncodingReference" (see Annex E) and can consist of any sequence of ASN.1 lexical items (including
comment, cstring and white-space).
     NOTE 1 – The "[" and "]" lexical items never appear in "EncodingInstruction".
     NOTE 2 – Future versions of this Recommendation | International Standard may add further encoding references to Annex E. It
     is recommended that ASN.1 tools provide (only) warnings if an "encodingreference" is not one of those specified in Annex E and
     then ignore the whole "EncodingPrefix" using a "]" as the terminator (see Note 1 above).

31.3.3 If the "EncodingReference" is empty, then the encoding reference for the encoding prefix is the default
encoding reference for the module.
     NOTE – If the default encoding reference for the module is TAG (see 31.2.2) and the "EncodingReference" is "empty", then the
     "PrefixedType" is a "TaggedType", not an "EncodingPrefixedType".

31.3.4 There are in general restrictions on the encoding instructions (with the same encoding reference) that can be
used in combination, and on the types to which particular instructions or combinations of instructions can be applied.
These restrictions are specified in the Recommendation | International Standard associated with the encoding reference
(see Annex E), and are not specified in this Recommendation | International Standard.


32         Notation for the object identifier type
32.1       The object identifier type (see 3.8.54) shall be referenced by the notation "ObjectIdentifierType":
                 ObjectIdentifierType ::=
                      OBJECT IDENTIFIER

32.2       This type has a tag which is universal class, number 6.
32.3  The value notation for an object identifier shall be "ObjectIdentifierValue", or when used as an "XMLValue",
"XMLObjectIdentifierValue". These productions are:
                 ObjectIdentifierValue ::=
                     "{" ObjIdComponentsList "}"
                 |   "{" DefinedValue ObjIdComponentsList "}"
                 ObjIdComponentsList ::=
                     ObjIdComponents
                 |   ObjIdComponents ObjIdComponentsList
                 ObjIdComponents ::=
                     NameForm
                 |   NumberForm
                 |   NameAndNumberForm
                 |   DefinedValue
                 NameForm ::= identifier
                 NumberForm ::= number | DefinedValue
                 NameAndNumberForm ::=
                    identifier "(" NumberForm ")"
                 XMLObjectIdentifierValue ::=
                   XMLObjIdComponentList
                 XMLObjIdComponentList ::=
                   XMLObjIdComponent
                 | XMLObjIdComponent & "." & XMLObjIdComponentList
                 XMLObjIdComponent ::=
                   NameForm
                 | XMLNumberForm
                 | XMLNameAndNumberForm




56           Rec. ITU-T X.680 (02/2021)
                                                                                                      ISO/IEC 8824-1:2021 (E)

                 XMLNumberForm ::= number
                 XMLNameAndNumberForm ::=
                   identifier & "(" & XMLNumberForm & ")"
32.4      The "valuereference" in "DefinedValue" of "NumberForm" shall be of type integer, and assigned a non-
negative value.
32.5       The "valuereference" in "DefinedValue" of "ObjectIdentifierValue" shall be of type object identifier.
32.6      The "DefinedValue" of "ObjIdComponents" shall be of type relative object identifier, and shall identify an
ordered set of arcs from some starting node in the object identifier tree to some later node in the object identifier tree.
The starting node is identified by the earlier "ObjIdComponents"s, and later "ObjIdComponents"s (if any) identify arcs
from the later node. The starting node is required to be neither the root, nor a node immediately beneath the root.
   NOTE – A relative object identifier value has to be associated with a specific object identifier value so as to unambiguously
   identify an object. Object identifier values are required (see 32.11) to have at least two components. This is why there is a
   restriction on the starting node.

32.7       The "NameForm" shall be used only for those object identifier components whose numeric value and
identifier are specified in Rec. ITU-T X.660 | ISO/IEC 9834-1, Annex A (see also Annex F of this Recommendation |
International Standard), and shall be one of the identifiers specified in Rec. ITU-T X.660 | ISO/IEC 9834-1, Annexes A
to C.
   NOTE – Where the "NameForm" is allowed, the use of the "NameAndNumberForm" instead has been recommended in some
   circumstances by Rec. ITU-T X.660 | ISO/IEC 9834-1, A.1.2.

32.8      Where Rec. ITU-T X.660 | ISO/IEC 9834-1 specifies synonymous identifiers, synonyms may be used under
conditions established when the synonym was registered in accordance with Rec. ITU-T X.660 | ISO/IEC 9834-1.
Where the same name is both an identifier specified in Rec. ITU-T X.660 | ISO/IEC 9834-1 and an ASN.1 value
reference within the module containing the "NameForm", the name within the object identifier value shall be treated as
an Rec. ITU-T X.660 | ISO/IEC 9834-1 identifier.
32.9      The "number" in the "NumberForm" and "XMLNumberForm" shall be the numeric value assigned to the
object identifier component.
32.10    There is flexibility in the "identifier"s that can be used in the "NameAndNumberForm" and
"XMLNameAndNumberForm" beneath the three top-level arcs. These identifiers are not included in encodings, and
may change over time. This is in recognition that the names of organizations can change. Identifiers for arcs should
normally be agreed between the Registration Authority responsible for the node above an arc, and the Registration
Authority to which responsibility for subsequent arcs has been assigned.
   NOTE – The Registration Authorities responsible for arcs beneath the three top-level arcs are identified in Rec. ITU-T X.660 |
   ISO/IEC 9834-1.

32.11      The semantics associated with an object identifier value are specified in Rec. ITU-T X.660 | ISO/IEC 9834-1.
   NOTE – Rec. ITU-T X.660 | ISO/IEC 9834-1 requires that an object identifier value shall contain at least two arcs.

32.12     The significant part of the object identifier component is the "NameForm" or "NumberForm" or
"XMLNumberForm" which it reduces to, and which provides the numeric value for the object identifier component.
Except for the arcs specified in Rec. ITU-T X.660 | ISO/IEC 9834-1, Annexes A to C (see also Annex F of this
Recommendation | International Standard), the numeric value of the object identifier component is always present in an
instance of object identifier value notation.
32.13      Where the "ObjectIdentifierValue" includes a "DefinedValue" for an object identifier value, the list of object
identifier components to which it refers is prefixed to the components explicitly present in the value.
   NOTE – Rec. ITU-T X.660 | ISO/IEC 9834-1 recommends that whenever an object identifier value is assigned to identify an
   object, an object descriptor value is also assigned.

EXAMPLES
With identifiers assigned as specified in Rec. ITU-T X.660 | ISO/IEC 9834-1, the values:
{ iso standard 8571 application-context (1) }
and
{ 1 0 8571 1 }

would each identify an object, application-context, defined in ISO 8571, as would
iso.standard.8571.application-context(1)

and


                                                                                    Rec. ITU-T X.680 (02/2021)               57
ISO/IEC 8824-1:2021 (E)

1.0.8571.1

in an "XMLObjectIdentifierValue".
With the following additional definition:
ftam OBJECT IDENTIFIER ::= { iso standard 8571 }

the following value is equivalent to those above:
{ ftam application-context(1) }



33           Notation for the relative object identifier type
33.1         The relative object identifier type (see 3.8.64) shall be referenced by the notation "RelativeOIDType":
                  RelativeOIDType ::= RELATIVE-OID
33.2         This type has a tag which is universal class, number 13.
33.3   The value notation for a relative object identifier shall be "RelativeOIDValue", or when used as "XMLValue",
"XMLRelativeOIDValue". These productions are:
                  RelativeOIDValue ::=
                      "{" RelativeOIDComponentsList "}"
                  RelativeOIDComponentsList ::=
                      RelativeOIDComponents
                  |   RelativeOIDComponents RelativeOIDComponentsList
                  RelativeOIDComponents ::=
                      NumberForm
                  |   NameAndNumberForm
                  |   DefinedValue
                  XMLRelativeOIDValue ::=
                    XMLRelativeOIDComponentList
                  XMLRelativeOIDComponentList ::=
                    XMLRelativeOIDComponent
                  | XMLRelativeOIDComponent & "." & XMLRelativeOIDComponentList
                  XMLRelativeOIDComponent ::=
                    XMLNumberForm
                  | XMLNameAndNumberForm
33.4  The    productions    "NumberForm",                "NameAndNumberForm",                             "XMLNumberForm",
"XMLNameAndNumberForm", and their semantics, are defined in subclauses 32.3 to 32.12.
33.5      The "DefinedValue" of "RelativeOIDComponents" shall be of type relative object identifier, and shall
identify an ordered set of arcs from some starting node in the object identifier tree to some later node in the object
identifier tree. The starting node is identified by the earlier "RelativeOIDComponents"s (if any), and later
"RelativeOIDComponents"s (if any) identify arcs from the later nodes.
33.6      The first "RelativeOIDComponents" or "XMLRelativeOIDComponent" identifies one or more arcs from
some starting node in the object identifier tree to some later node in the object identifier tree. The starting point can be
defined by comments associated with the type definition. If there is no definition of the starting node within comments
associated with the type definition, then it needs to be transmitted as an object identifier value in an instance of
communication (see G.2.21). The starting node is required to be neither the root, nor a node immediately beneath the
root.
     NOTE – A relative object identifier value has to be associated with a specific object identifier value so as to unambiguously
     identify an object. Object identifier values are required (see 32.11) to have at least two components. This is why there is a
     restriction on the starting node.

EXAMPLE
With the following definitions:
thisUniversity OBJECT IDENTIFIER            ::=
          {joint-iso-itu-t example(999) universities(56) thisuni(32)}



58            Rec. ITU-T X.680 (02/2021)
                                                                                                   ISO/IEC 8824-1:2021 (E)

firstgroup RELATIVE-OID ::= {science-fac(4) maths-dept(3)}

or in XML value notation:
thisUniversity ::= <OBJECT_IDENTIFIER>2.999.56.32</OBJECT_IDENTIFIER>
firstgroup ::= <RELATIVE_OID>4.3</RELATIVE_OID>

the relative object identifier:
relOID RELATIVE-OID ::= {firstgroup room(4) socket(6)}

or in XML value notation:
relOID ::= <RELATIVE_OID>4.3.4.6</RELATIVE_OID>

can be used instead of the OBJECT IDENTIFIER value {2 999 56 32                    4   3    4   6} if the current root (known
by the application or transmitted by the application) is thisUniversity.


34        Notation for the OID internationalized resource identifier type
34.1      The OID internationalized resource identifier type (see 3.8.47) shall be referenced by the notation "IRIType":
                IRIType ::= OID-IRI
34.2      This type has a tag which is universal class, number 35.
34.3   The value notation for an OID internationalized resource identifier shall be "IRIValue", or when used as an
"XMLValue", "XMLIRIValue". These productions are:
                IRIValue ::=
                    """
                    FirstArcIdentifier
                    SubsequentArcIdentifier
                    """
                FirstArcIdentifier ::=
                     "/" ArcIdentifier
                SubsequentArcIdentifier ::=
                    "/" ArcIdentifier SubsequentArcIdentifier
                |   empty
                ArcIdentifier ::=
                    integerUnicodeLabel
                |   non-integerUnicodeLabel
                XMLIRIValue ::=
                  FirstArcIdentifier
                  SubsequentArcIdentifier
34.4      The "FirstArcIdentifier" shall identify an arc (possibly a long arc) from the root of the OID tree.
34.5      Each "SubsequentArcIdentifier" shall identify an arc from the preceding "ArcIdentifier".
EXAMPLES
With identifiers assigned as specified in Rec. ITU-T X.660 | ISO/IEC 9834-1 and ISO/IEC 19785 the object identified
by:
{iso registration-authority cbeff (19785) organizations(0) jtc1-sc37(257) patron-formats(1) tlv-encoded (5)}

or in XML value notation:
<OBJECT_IDENTIFIER>1.1.19785.0.257.1.5</OBJECT_IDENTIFIER>

which identifies a TLV-encoded CBEFF Patron Format, could also have an ASN.1 OID-IRI identification of
"/ISO/Registration_Authority/19785.CBEFF/Organizations/JTC1-SC37/Patron-formats/TLV-encoded"

Or, in XML value notation:
<OID-IRI>/ISO/Registration_Authority/19785.CBEFF/Organizations/JTC1-SC37/Patron-
formats/TLV-encoded</OID-IRI>


                                                                                  Rec. ITU-T X.680 (02/2021)              59
ISO/IEC 8824-1:2021 (E)

35         Notation for the relative OID internationalized resource identifier type
35.1      The relative OID internationalized resource identifier type (see 3.8.62) shall be referenced by the notation
"RelativeIRIType":
                 RelativeIRIType ::= RELATIVE-OID-IRI
35.2       This type has a tag which is universal class, number 36.
35.3    The value notation for a relative OID internationalized resource identifier shall be "RelativeIRIValue", or
when used as an "XMLValue", "XMLRelativeIRIValue". These productions are:
                 RelativeIRIValue ::=
                     """
                     FirstRelativeArcIdentifier
                     SubsequentArcIdentifier
                     """
                 FirstRelativeArcIdentifier ::=
                      ArcIdentifier
                 XMLRelativeIRIValue ::=
                   FirstRelativeArcIdentifier
                   SubsequentArcIdentifier
35.4      The "FirstRelativeArcIdentifier" shall identify an arc from some starting node in the object identifier tree to
some later node in the object identifier tree. The starting point can be defined by comments associated with the type
definition. If there is no definition of the starting node within comments associated with the type definition, then it
needs to be transmitted as an OID internationalized resource identifier value in an instance of communication.
     NOTE – A relative OID internationalized resource identifier value has to be associated with a specific OID internationalized
     reference identifier value so as to unambiguously identify a resource.

EXAMPLE
With the following identified node:
cbeffPatronFormats OID-IRI ::=
           "/ISO/Registration_Authority/19785.CBEFF/Patron-formats"


the relative OID internationalized resource identifier:
tlv-encoded RELATIVE-OID-IRI ::= "TLV-encoded"

identifies the TLV-encoded Patron Format.


36         Notation for the embedded-pdv type
36.1       The embedded-pdv type (see 3.8.24) shall be referenced by the notation "EmbeddedPDVType":
                 EmbeddedPDVType ::= EMBEDDED PDV
     NOTE – The term "Embedded PDV" means an abstract value from a possibly different abstract syntax (essentially, the value and
     encoding of a message defined in a separate – and identified – protocol) that is embedded in a message. Historically, it meant
     "Embedded Presentation Data Value" from its use in the OSI Presentation Layer, but this expansion is not used today, and it
     should be interpreted as "embedded value".

36.2       This type has a tag which is universal class, number 11.
36.3       The type consists of values representing:
           a)    an encoding of a single data value that may, but need not, be the value of an ASN.1 type; and
           b)    identification (separately or together) of:
                 1)   an abstract syntax; and
                 2)   the transfer syntax.
     NOTE 1 – The data value may be the value of an ASN.1 type, or may, for example, be the encoding of a still image or a moving
     picture. The identification consists of either one or two object identifiers, or (in an OSI environment) references an OSI
     presentation context identifier which specifies the abstract and transfer syntaxes.




60           Rec. ITU-T X.680 (02/2021)
                                                                                                    ISO/IEC 8824-1:2021 (E)

   NOTE 2 – The identification of the abstract syntax and/or the encoding may also be determined by the application designer as a
   fixed value, in which case it is not encoded in an instance of communication.

36.4      The embedded-pdv type has an associated type. This associated type is used to support the value and subtype
notations of the embedded-pdv type.
36.5     The associated type for value definition and subtyping, assuming an automatic tagging environment, is (with
normative comments):
SEQUENCE {
identification                            CHOICE {
           syntaxes                              SEQUENCE {
                abstract                            OBJECT IDENTIFIER,
                transfer                            OBJECT IDENTIFIER }
               -- Abstract and transfer syntax object identifiers --,
               syntax                                     OBJECT IDENTIFIER
               -- A single object identifier for identification of the abstract
               -- and transfer syntaxes --,
               presentation-context-id                    INTEGER
               -- (Applicable only to OSI environments)
               -- The negotiated OSI presentation context identifies the
               -- abstract and transfer syntaxes --,
               context-negotiation                        SEQUENCE {
               presentation-context-id                    INTEGER,
               transfer-syntax                            OBJECT IDENTIFIER }
               -- (Applicable only to OSI environments)
               -- Context-negotiation in progress, presentation-context-id
               -- identifies only the abstract syntax
               -- so the transfer syntax shall be specified --,
               transfer-syntax                            OBJECT IDENTIFIER
               -- The type of the value (for example, specification that it is
               -- the value of an ASN.1 type)
               -- is fixed by the application designer (and hence known to both
               -- sender and receiver). This
               -- case is provided primarily to support
               -- selective-field-encryption (or other encoding
               -- transformations) of an ASN.1 type --,
               fixed                                      NULL
               -- The data value is the value of a fixed ASN.1 type (and hence
               -- known to both sender
               -- and receiver) -- },
          data-value-descriptor                      ObjectDescriptor OPTIONAL
               -- This provides human-readable identification of the class of the
               -- value --,
data-value                                OCTET STRING }
( WITH COMPONENTS {
          ... ,
          data-value-descriptor ABSENT } )
   NOTE – The embedded-pdv type does not allow the inclusion of a data-value-descriptor value. However, the definition of
   the associated type provided here underlies the commonalities which exist between the embedded-pdv type, the external type and
   the unrestricted character string type.

36.6      The presentation-context-id alternative is only applicable in an OSI environment, when the integer
value shall be an OSI presentation context identifier in the OSI defined context set. This alternative shall not be used
during OSI context negotiation.
36.7      The context-negotiation alternative is only applicable in an OSI environment, and shall only be used
during OSI context negotiation. The integer value shall be an OSI presentation context identifier proposed for addition
to the OSI defined context set. The object identifier transfer-syntax shall identify a proposed transfer syntax for
that OSI presentation context which is to be used to encode the value.




                                                                                  Rec. ITU-T X.680 (02/2021)                  61
ISO/IEC 8824-1:2021 (E)

36.8       The notation for a value of the embedded-pdv type shall be the value notation for the associated type defined
in 36.5, where the value of the data-value component of type OCTET STRING represents an encoding using the
transfer syntax specified in identification.
                 EmbeddedPDVValue ::= SequenceValue
                 XMLEmbeddedPDVValue ::= XMLSequenceValue
EXAMPLE – If a single option is to be enforced, such as use of syntaxes, then this can be done by writing:
EMBEDDED PDV (WITH COMPONENTS {
          ... ,
          identification (WITH COMPONENTS {
                syntaxes PRESENT } ) } )



37          Notation for the external type
37.1        The external type (see 3.8.43) shall be referenced by the notation "ExternalType":
                 ExternalType ::= EXTERNAL
37.2        This type has a tag which is universal class, number 8.
37.3        The type consists of values representing:
            a)   an encoding of a single data value that may, but need not, be the value of an ASN.1 type; and
            b)   identification of:
                 1)    an abstract syntax; and
                 2)    the transfer syntax; and
            c)   (optionally) an object descriptor which provides a human-readable description of the category of the data
                 value. The optional object descriptor shall not be present unless explicitly permitted by comment
                 associated with use of the "ExternalType" notation.
     NOTE – Note 1 in 36.3 also applies to the external type.

37.4      The external type has an associated type. This type is used to give precision to the definition of the abstract
values of the external type and is also used to support the value and subtype notations of the external type.
     NOTE – Encoding rules may define a different type which is used to derive encodings, or may specify encodings without
     reference to any associated type. For example, the encoding in BER uses a different sequence type for historical reasons.

37.5     The associated type for value definition and subtyping, assuming an automatic tagging environment, is (with
normative comments):
SEQUENCE {
identification                              CHOICE {
           syntaxes                                SEQUENCE {
                abstract                              OBJECT IDENTIFIER,
                transfer                              OBJECT IDENTIFIER }
                 -- Abstract and transfer syntax object identifiers --,
                 syntax                                         OBJECT IDENTIFIER
                 -- A single object identifier for identification of the abstract
                 -- and transfer syntaxes --,
                 presentation-context-id                        INTEGER
                 -- (Applicable only to OSI environments)
                 -- The negotiated OSI presentation context identifies the
                 -- abstract and transfer syntaxes --,
                 context-negotiation                            SEQUENCE {
                 presentation-context-id                        INTEGER,
                 transfer-syntax                                OBJECT IDENTIFIER }
                 -- (Applicable only to OSI environments)
                 -- Context-negotiation in progress, presentation-context-id
                 -- identifies only the abstract syntax
                 -- so the transfer syntax shall be specified --,
                 transfer-syntax                                OBJECT IDENTIFIER
                 -- The type of the value (for example, specification that it is


62           Rec. ITU-T X.680 (02/2021)
                                                                                                       ISO/IEC 8824-1:2021 (E)

                 -- the value of an ASN.1 type)
                 -- is fixed by the application designer (and hence known to both
                 -- sender and receiver). This
                 -- case is provided primarily to support
                 -- selective-field-encryption (or other encoding
                 -- transformations) of an ASN.1 type --,
                 fixed                                            NULL
                 -- The data value is the value of a fixed ASN.1 type (and hence
                 -- known to both sender
                 -- and receiver) -- },
data-value-descriptor                       ObjectDescriptor OPTIONAL
                 -- This provides human-readable identification of the class of
                 -- the value --,
data-value                                 OCTET STRING }
( WITH COMPONENTS {
          ... ,
          identification (WITH COMPONENTS {
                ... ,
                syntaxes                                             ABSENT,
                transfer-syntax                                      ABSENT,
                fixed                      ABSENT } ) } )
   NOTE – For historical reasons, the external type does not allow the syntaxes, transfer-syntax or fixed alternatives of
   identification. Application designers requiring these options should use the embedded-pdv type. The definition of the
   associated type provided here underlies the commonalities which exist between the external type, the unrestricted character string
   type and the embedded-pdv type.

37.6       The text of 36.6 and 36.7 also applies to the external type.
37.7     The notation for a value of the external type shall be the value notation for the associated type defined in 37.5,
where the value of the data-value component of type OCTET STRING represents an encoding using the transfer
syntax specified in identification.
                 ExternalValue ::= SequenceValue
                 XMLExternalValue ::= XMLSequenceValue
     NOTE – For historical reasons, encoding rules are able to transfer embedded values in EXTERNAL whose encodings are not an
     exact multiple of eight bits. Such values cannot be represented in value notation using the above associated type.



38         The time type

38.1       General
38.1.1     The time type (see 3.8.83) shall be referenced by the notation "TimeType":
                 TimeType ::= TIME
38.1.2     The tag for types defined by this notation is universal class, number 14.
38.1.3 The value of a time type shall be defined by the notation "TimeValue", or when used as an "XMLValue", by
the notation "XMLTimeValue". The syntax of these notations is defined in 38.3 as the contents of a "simplestring",
using notation defined in ISO 8601, 3.4.

38.2       Time properties and settings of time abstract values
38.2.1 Table 6 specifies in column 1 the description and names of the time properties of time abstract values. In
column 2, it specifies the names of the possible time property settings for the column 1 time property. Column 3
specifies (generally by reference to ISO 8601) the abstract values to which the time property is applicable, and that have
the corresponding time property settings.
     NOTE 1 – ASN.1 does not specify abstract values that are not supported by ISO 8601 representations.
     NOTE 2 – The names of time properties and of their settings appear in the property assertions of the property settings subtype
     notation (see clause 51).
     NOTE 3 – ASN.1 recognizes an order relationship between TIME abstract values if they have the same properties and the same
     settings of those properties. For those abstract values that include a time difference, an order relationship is only recognized
     between abstract values with the same time difference.


                                                                                     Rec. ITU-T X.680 (02/2021)                  63
ISO/IEC 8824-1:2021 (E)


                                  Table 6 – Properties and settings for time abstract values

                                                                                              Abstract values that have this
                     Time property                             Names of property settings
                                                                                                    property setting
 Basic nature of the abstract value                          Date                           See ISO 8601, 4.1.
 Name: Basic                                                                                All abstract values that are dates
 Comment: The setting of this property identifies the                                       only.
 basic nature of the abstract value. All time abstract       Time                           See ISO 8601, 4.2.
 values have this property.                                                                 All abstract values that are a time-
                                                                                            of-day only.
                                                             Date-Time                      See ISO 8601, 4.3.
                                                                                            All abstract values that are a date
                                                                                            and a time-of-day.
                                                             Interval                       See ISO 8601, 4.4.
                                                                                            All the time interval abstract
                                                                                            values.
                                                             Rec-Interval                   See ISO 8601, 4.5.
                                                                                            All the recurring interval abstract
                                                                                            values.
 Time scale and accuracy for a date                          C (Century)                    See ISO 8601, 4.1.2.3 c).
 Name: Date                                                                                 All abstract values containing a
 Comment: This applies only to an abstract value that                                       date that represents only a century.
 includes identification of a date. It identifies the time   Y (Year only)                  See ISO 8601, 4.1.2.3 b).
 scale and accuracy of that date.
                                                                                            All abstract values containing a
 NOTE – Any abstract value identifying more than                                            date that represents only a year.
 one date (for example, an interval) has a single setting
 for Date that applies to both dates.                        YM (Year-Month)                See ISO 8601, 4.1.2.3 a).
                                                                                            All abstract values containing a
                                                                                            date that uses the year-month time
                                                                                            scale.
                                                             YMD (Year-Month-Day)           See ISO 8601, 4.1.2.2.
                                                                                            All abstract values containing a
                                                                                            date that uses the year-month-day
                                                                                            time scale.
                                                             YD (Year-Day)                  See ISO 8601, 4.1.3.2.
                                                                                            All abstract values containing a
                                                                                            date that uses the year-day time
                                                                                            scale.
                                                             YW (Year-Week)                 See ISO 8601, 4.1.4.3.
                                                                                            All abstract values containing a
                                                                                            date that uses the year-week time
                                                                                            scale.
                                                             YWD (Year-Week-Day)            See ISO 8601, 4.1.4.2.
                                                                                            All abstract values containing a
                                                                                            date that uses the year-week-day
                                                                                            time scale.




64          Rec. ITU-T X.680 (02/2021)
                                                                                                     ISO/IEC 8824-1:2021 (E)


                                 Table 6 – Properties and settings for time abstract values

                                                                                                Abstract values that have this
                    Time property                             Names of property settings
                                                                                                      property setting
Type of associated year                                    Basic                              All abstract values containing a
Name: Year                                                                                    year in the range 1582 to 9999 (or
                                                                                              a century in the range 15 to 99).
Comment: This applies only to an abstract value that
includes identification of one or more years or
centuries. Its setting identifies whether the year (or     Proleptic                          All abstract values containing a
century) identification is a "normal" year, a year in                                         year in the range 0 to 1581 (or a
the proleptic Gregorian Calendar (see J.2.2), a year                                          century in the range 00 to 14).
that is negative, or a year that requires more than four                                      NOTE – In the proleptic Gregorian
digits to represent it.                                                                       calendar, a year value of zero has a
NOTE – Any abstract value involving more than one                                             meaning which roughly
year (for example, an interval) has a single setting for                                      corresponds to the year 1 BC (see
Year that applies to both years.                                                              J.2.2).
                                                           Negative                           All abstract values containing a
                                                                                              year in the range –9999 to –0001
                                                                                              (or a century in the range –99 to
                                                                                              –01).
                                                           L5, L6, L7, etc., to infinity      All abstract values containing a
                                                           (Large)                            year whose decimal representation
                                                                                              requires 5, 6, 7, etc., digits (or a
                                                                                              century whose decimal
                                                                                              representation requires 3, 4, 5,
                                                                                              etc., digits) respectively, whether
                                                                                              positive or negative.
Accuracy for a time                                        H (Hour)                           See ISO 8601, 4.2.2.3 b).
Name: Time                                                                                    All abstract values containing a
Comment: This applies only to an abstract value that                                          time-of-day to an accuracy of
includes identification of a time-of-day. It identifies                                       hours.
the accuracy of that time-of-day.                          HM (Hour-Minute)                   See ISO 8601, 4.2.2.3 a).
NOTE – Any abstract value identifying more than                                               All abstract values containing a
one time-of-day (for example, an interval) has a                                              time-of-day to an accuracy of
single setting for Time that applies to both the time-                                        minutes.
of-days.
                                                           HMS (Hour-Minute-Second)           See ISO 8601, 4.2.2.2.
                                                                                              All abstract values containing a
                                                                                              time-of-day to an accuracy of
                                                                                              seconds.
                                                           HF1, HF2, HF3, etc., to infinity   See ISO 8601, 4.2.2.4 c).
                                                           (Hour-decimal-fraction)            All abstract values containing a
                                                                                              time-of-day to an accuracy of
                                                                                              hours to 1, 2, 3, etc., decimal
                                                                                              places.
                                                           HMF1, HMF2, HMF3, etc., to         See ISO 8601, 4.2.2.4 b).
                                                           infinity (Hour-Minute-fraction)    All abstract values containing a
                                                                                              time-of-day to an accuracy of
                                                                                              minutes to 1, 2, 3, etc., decimal
                                                                                              places.
                                                           HMSF1, HMSF2, HMSF3, etc., to      See ISO 8601, 4.2.2.4 a).
                                                           infinity                           All abstract values containing a
                                                           Hour-Minute-Second-Fraction        time-of-day to an accuracy of
                                                                                              seconds to 1, 2, 3, etc., decimal
                                                                                              places.




                                                                                       Rec. ITU-T X.680 (02/2021)                 65
ISO/IEC 8824-1:2021 (E)


                                  Table 6 – Properties and settings for time abstract values

                                                                                                  Abstract values that have this
                     Time property                              Names of property settings
                                                                                                        property setting
 Local or UTC time scale for a time                          L (Local time of day only)         See 38.2.2 and ISO 8601, 4.2.2 and
 Name: Local-or-UTC                                                                             4.2.3.
 Comment: This applies only to an abstract value that                                           All abstract values containing a
 includes identification of a time. It identifies the time                                      time-of-day that specifies local
 scale of that time (local time of day, UTC, or local                                           time of day only.
 time of day plus the difference from UTC). Time             Z (UTC only)                       See ISO 8601, 4.2.4.
 differences are determined by local administrations.                                           All abstract values containing a
 ASN.1 supports time differences in the range –15                                               time-of-day that specifies UTC and
 hours to +15 hours. The difference is positive if the                                          not local time of day.
 local time of day is ahead of or equal to UTC (see
 ISO 8601, 4.2.5.1). See also J.2.11.                        LD (Local time of day and the      See ISO 8601, 4.2.5.
 NOTE – Any abstract value identifying more than             difference from UTC)               All abstract values containing a
 one time (for example, an interval) has a single                                               time-of-day that specifies local
 setting for Local-or-UTC that applies to both times.                                           time of day and the time (which
                                                                                                may be negative) added to UTC to
                                                                                                obtain local time of day.
 Form of interval specification                              SE (Start and end points)          See ISO 8601, 4.4.1 a).
 Name: Interval-type                                                                            All abstract values that specify an
 Comment: This applies only to an abstract value that                                           interval using a start and an end
 is an interval or a recurring interval. It identifies the                                      point.
 form of interval specification (a start and an end          D (Duration only)                  See ISO 8601, 4.4.1 b) and 4.4.3.
 point, a duration, a start point and a duration, or a                                          All abstract values that specify an
 duration with an end point).                                                                   interval using only a duration.
                                                             SD (Start point and duration)      See ISO 8601, 4.4.1 c).
                                                                                                All abstract values that specify an
                                                                                                interval using a start point and a
                                                                                                duration.
                                                             DE (Duration and end point)        See ISO 8601, 4.4.1 d).
                                                                                                All abstract values that specify an
                                                                                                interval using a duration and an
                                                                                                end point.
 Nature of the start and/or end point specification          Date                               See ISO 8601, 4.1.
 Name: SE-point                                                                                 All abstract values that specify
 Comment: This applies only to intervals or recurring                                           start and/or end points using dates
 intervals using a start point or an end point or both.                                         only.
 The setting of this property identifies the nature of the   Time                               See ISO 8601, 4.2.
 start point and/or end point that forms part of this                                           All abstract values that specify
 abstract value.                                                                                start and/or end points using time-
 NOTE – All interval abstract values with both a start                                          of-day only.
 point and an end point have a single setting for this
                                                             Date-Time                          See ISO 8601, 4.3.
 property, and for any associated properties related to
 date or time-of-day.                                                                           All abstract values that specify
                                                                                                start and/or end points using a date
 There are no interval abstract values that have
                                                                                                and a time-of-day.
 different forms of start point and end point. Thus all
 abstract values with both an interval start point and an
 interval end point have the same set of time
 components for the start point and the end point (but
 see Table 7 for value notation for the end-point). This
 is a difference from ISO 8601.
 Recurrence specification                                    Unlimited (No limit on the         See ISO 8601, 4.5.
 Name: Recurrence                                            number of recurrences, expressed   All abstract values representing an
                                                             with an empty string for the       unlimited number of recurrences of
 Comment: This applies only to an abstract value that        number of recurrences)
 is a recurring interval. It identifies the agreed limits                                       an interval.
 on the number of recurrences (or unlimited).                R1, R2, R3, etc., to infinity      See ISO 8601, 4.5.
                                                             (Number of recurrence digits)      All abstract values representing
                                                                                                recurrences of an interval that
                                                                                                require 1, 2, 3, etc. digits,
                                                                                                respectively, to express the number
                                                                                                of recurrences.



66          Rec. ITU-T X.680 (02/2021)
                                                                                                         ISO/IEC 8824-1:2021 (E)


                                 Table 6 – Properties and settings for time abstract values

                                                                                                   Abstract values that have this
                     Time property                            Names of property settings
                                                                                                         property setting
 Midnight start or end of a day                             Start (Start-of-day)                 See ISO 8601, 4.2.3 a).
 Name: Midnight                                                                                  An abstract value containing a time
 Comment: This applies only to an abstract value that                                            that represents midnight at the start
 contains a time that represents midnight. It identifies                                         of a day.
 whether this midnight value is the start of a day (often   End (End-of-day)                     See ISO 8601, 4.2.3 b).
 represented as 00:00:00) or the end of a day (often                                             An abstract value containing a time
 represented as 24:00:00).                                                                       that represents midnight at the end
                                                                                                 of a day.
 NOTE – ASN.1 does not support the use of start and end points of intervals that have different time properties, as there is only a
 single SE-point setting that governs the syntax of both the start point and the end-point. The start and end points are required to
 use the same time format. This is a difference from ISO 8601.

38.2.2 ISO 8601 provides two basic representations for midnight: "2400" for midnight at the end of a day and "0000"
for midnight at the start of a day (with any second or fractional part of a second containing only zero digits). These are
not considered different representations for a single abstract value, but as distinct abstract values.
   NOTE 1 – This is because as a stand-alone time, they are clearly distinct and represent start of a day and end of a day. When used
   in conjunction with a day, "2400" on day x should be considered less than "0000" on day x+1, despite having exactly the same
   position on the time axis.
   NOTE 2 – They have, respectively, the time property setting "Midnight=End" and "Midnight=Start".
   NOTE 3 – As with other times, there are infinitely many distinct abstract values that are midnight at the start and end of any
   particular day, depending on the accuracy of the seconds and fractional part of seconds. There are also further infinite sets of
   midnight abstract values based on the use of fractions of an hour or of a minute rather than of seconds. (All these fractional parts
   will be zero to various different accuracies if the abstract value is a midnight value.)

38.2.3 ISO 8601 provides two basic representations for duration (either weeks, or some combination of years,
months, days, hours, minutes and seconds) as a component of time intervals and recurring time intervals. Different
strings representing durations in ISO 8601 are considered to represent different abstract values in ASN.1, except where
the only difference is the omission or inclusion of a zero time component that does not change the duration (including
the accuracy of the duration) being represented. Inclusion or omission of zero time components is fully specified in
canonical encoding rules, and in all the encoding rules of Rec. ITU-T X.691 | ISO/IEC 8825-2. There are no time
properties (other than "Basic=Interval Interval-type=D") associated with a duration, but restrictions can be
applied to the time components of a duration, requiring them to be absent or limiting their value (see 38.4.4).
   NOTE 1 – There is an ISO 8601 requirement for prior agreement on the size of components (and particularly of fractional parts).
   This is normally handled by property settings for the different accuracies. However, in the case of DURATION, for simplicity,
   property settings were not introduced to determine the accuracy of the components. Instead, inner subtyping constraints on the
   equivalent sequence type can be applied, as specified in 38.4.4, to record prior agreements on the components of a DURATION.
   NOTE 2 – ISO 8601 requires that use of a weeks component shall not be combined with the use of any other date component
   (years, months, days), nor with the use of an hours, minutes, or seconds time component. This restriction is also applied in ASN.1
   for consistency with ISO 8601.

38.2.4 There is no defined order relation between the different DURATION abstract values unless they are expressed
using a single time element (for example, weeks or months or days only), as there is no agreed international definition
of a duration of one month or one year in terms of seconds.

38.3      Basic value notation and XML value notation for time abstract values with specified property
          settings
38.3.1 All time abstract values with the same time property settings have the same value notation, varied only by the
values of year, month, week, day, hour, minute, second, etc. (on the associated time scale) that are used to distinguish
that abstract value from others with the same property settings.
38.3.2    The value notations for the time type shall be "TimeValue" and "XMLTimeValue":
                TimeValue ::= tstring
                XMLTimeValue ::= xmltstring
The content of the "tstring" and of the "xmltstring" is defined in 38.3.4 using the time component syntax that is defined
in column 3 of Table 7. Table 7 defines a number of possible notations for the different components (for example, the
year component). The precise notation to be used depends on the property settings of the abstract value specified in


                                                                                      Rec. ITU-T X.680 (02/2021)                       67
ISO/IEC 8824-1:2021 (E)

column 2. Properties not listed in column 2 have no effect on the notation to be used for the component. These time
component notations are normally defined by reference to an ISO 8601 representation (with which they are
conformant), but in order to avoid ambiguity in value notation, an additional C character is added to time components
that designate a century and not a full year, as specified in column 3 of Table 7.
38.3.3 Table 7 specifies (in column 3) the value notation and XML value notation for time components (listed in
column 1). Column 1 identifies a time component. Column 2 specifies the conditions in which a particular row is
applicable, in terms of the settings of properties associated with abstract values. Column 3 specifies the notation to be
used for that time component. The notation used in column 3 is that defined in ISO 8601, 3.4, with the addition of C as a
century designator.
     NOTE 1 – The ISO 8601 notation used in column 3 can be summarized as: Y is a year digit, M is a month digit or month
     designator, D is a day digit, w is a week digit, h is an hour digit, m is a minute digit, s is a second digit, n is any of 0 to 9, ± is
     plus or minus, and underline represents zero or more repetitions (for example "±YYYYY"). The ISO 8601 notation is used in
     preference to any other notation used in this Recommendation | International Standard in order to make the linkage to ISO 8601
     clear.
     NOTE 2 – Clause J.2 provides a tutorial on ISO 8601 key concepts that will help in understanding this notation. See also
     clause G.3 for examples of the resulting value notation.


                 Table 7 – Value notation for time abstract values with specific properties and settings

       Time component                         Property                                       Value notation syntax
 Year component                  "Year=Basic"                           ISO 8601, 4.1.2.3 c) followed by the character LATIN
                                 and "Date=C"                           CAPITAL LETTER C: [YYC]
                                 or
                                 "Year=Proleptic"
                                 and "Date=C"
 Year component                  "Year=Negative"                        ISO 8601, 4.1.2.4 d) followed by the character LATIN
                                 and "Date=C"                           CAPITAL LETTER C: [±YYYC]
                                 or
                                 "Year=Ln" and "Date=C"                 The number of repetitions of Y shall be zero for
                                                                        "Year=Negative" and equal to n-4 for "Year=Ln".
 Year component                  "Year=Basic"                           ISO 8601, 4.1.2.2: [YYYY]
                                 and Date is not C
                                 or
                                 "Year=Proleptic"
                                 and Date is not C
 Year component                  "Year=Negative" and Date               ISO 8601, 4.1.2.4 c): [±YYYYY]
                                 is not C
                                 or                                     The number of repetitions of Y shall be zero for
                                 "Year=Ln" and Date is not C            "Year=Negative" and equal to n-4 for "Year=Ln".
 Month component                 Any                                    ISO 8601, 4.1.2.3 a): [-MM]
 Week component                  Any                                    ISO 8601, 4.1.4.3: [-Www]
 Day component                   "Year=YMD"                             ISO 8601, 4.1.2.2 Extended format: [-DD]
 Day component                   "Year=YD"                              ISO 8601, 4.1.3.2 Extended format: [-DDD]
 Day component                   "Year=YWD"                             ISO 8601, 4.1.4.2 Extended format: [-D]
 Hours component                 "Basic=Time"                           ISO 8601, 4.2.2.3 b): [hh]
                                 or
                                 "Basic=Interval" and                   The hours component value notation 24 shall always be used
                                 "SE-point=Time"                        for the abstract value "midnight at end of day" and the hours
                                                                        component value notation 00 for "midnight at start of day".
                                 or
                                 "Basic=Rec-Interval" and
                                 "SE-point=Time"




68           Rec. ITU-T X.680 (02/2021)
                                                                                                 ISO/IEC 8824-1:2021 (E)


                Table 7 – Value notation for time abstract values with specific properties and settings

    Time component                     Property                                   Value notation syntax
Hours component              "Basic=Date-Time"               ISO 8601, 4.3.2 Extended format: [Thh]
                             or
                             "Basic=Interval" and            The value notation T24 shall always be used for the hours
                             "SE-point=Date-Time"            component of the abstract value "midnight at end of day" and
                             or                              the value notation T00 for "midnight at start of day".
                             "Basic=Rec-Interval"
                             and
                             "SE-point=Date-Time"
Minutes component            Any                             ISO 8601, 4.3.2 Extended format: [:mm]
Seconds component            Any                             ISO 8601, 4.3.2 Extended format: [:ss]
Decimal fraction             Any                             ISO 8601, 4.2.2.4: [,hh] or [.hh], [,mm] or [.mm], or
component of hour,                                           [,ss] or [.ss]
minute, or second                                            NOTE – It is recommended that in any given ASN.1 module,
                                                             the comma or full stop be consistently used for the decimal
                                                             sign.
Decimal fraction             "Basic=Interval" and            ISO 8601, 4.4.3.2: [,nn] or [.nn]
component of year, month,    "Interval-type=D"               NOTE – It is recommended that in any given ASN.1 module,
week, or day in a duration   or                              the comma or full stop be consistently used for the decimal
(see J.2.6, Note)                                            sign.
                             "Basic=Interval" and
                             "Interval-type=SD"
                             or
                             "Basic=Interval" and
                             "Interval-type=DE"
UTC designator               "Local-or-UTC=Z"                ISO 8601, 4.2.4: [Z]
component
Time difference              "Local-or-UTC=LD"               ISO 8601, 4.2.5.2 Extended format: [±hh] or [±hh:mm]
component                                                    The time difference component shall be the exact time
                                                             difference in minutes if it is not an exact multiple of hours.
                                                             NOTE – This means that the minutes component has to be
                                                             present unless the difference between local time of day and
                                                             UTC is an integral number of hours.
Duration component           "Interval-type=D"               ISO 8601, 4.4.3.2:
                             or                              see 38.3.6
                             "Interval-type=SD"
                             or
                             "Interval-type=DE"
Time interval                "Interval-type=SE"              ISO 8601, 4.4 Extended formats:
                             or                              Start point component ("Interval-type=SE" or
                             "Interval-type=SD"              "Interval-type=SD") or duration component
                                                             ("Interval-type=DE"), followed by [/], followed by
                             or                              duration component ("Interval-type=SD") or end point
                             "Interval-type=DE"              component ("Interval-type=SE" or "Interval-
                                                             type=DE").


Start point component        Depends on SE-point setting     This is determined by the setting of SE-point, which shall be
                                                             interpreted as a setting of the Basic property for representing
                                                             this component. The Date, Year, Time, and Local-or-
                                                             UTC property settings shall then be used to determine the
                                                             format of the start point component.




                                                                               Rec. ITU-T X.680 (02/2021)                     69
ISO/IEC 8824-1:2021 (E)


                 Table 7 – Value notation for time abstract values with specific properties and settings

       Time component                       Property                                    Value notation syntax
 End point component            Depends on SE-point setting         This is determined by the setting of SE-point, which shall be
                                                                    interpreted as a setting of the Basic property for representing
                                                                    this component. The Date, Year, Time, and Local-or-
                                                                    UTC property settings shall then be used to determine the
                                                                    format of the end point component. It is permissible
                                                                    (optionally) to omit the time difference component if the
                                                                    difference between UTC and local time of day for the end
                                                                    point is the same as the difference for the start point.
                                                                    NOTE – This is not as general as ISO 8601, but is restricted to
                                                                    these cases for simplicity.
 Recurring time intervals       "Recurrence=Unlimited"              ISO 8601, 4.5 Extended format: [R/] followed by the time
                                                                    interval component.


 Recurring time intervals       "Recurrence=R1",                    ISO 8601, 4.5 Extended format: [Rnn/] followed by the time
                                "Recurrence=R2",                    interval component.
                                "Recurrence=R3", etc.

38.3.4 The value of the "tstring" shall be the concatenation of the character encodings of the time components
(determined by the settings of their properties in accordance with Table 6), preceded and followed by a QUOTATION
MARK (34) character (") as specified in 12.17. The value of the "xmltstring" shall be the concatenation of the character
encodings of the time components (determined by the settings of their properties in accordance with Table 6), without
surrounding QUOTATION MARK characters.
     NOTE 1 – The value notation and XML value notation are canonical except for:
              a) the varying representations of duration; and
              b) the varying use of comma or full stop for the decimal separator; and
              c) the varying use of hours and minutes or hours only for time difference components that are an integral number of
                  hours; and
              d) the inclusion or omission of a time difference component in the end point of an interval (with both a start point
                  and an end point) when the time difference in the end point is the same as the time difference in the start point.
     NOTE 2 – Examples of the value notation are provided in G.3.

38.3.5     The notations for the time components shall be concatenated in the order specified in ISO 8601.
     NOTE – This means the most significant time component first and the zone designator (time difference component or Z) last.

38.3.6 The basic value notation and the XML value notation for the duration component are specified in the
following subclauses.
38.3.6.1 The value notation shall be [P] (see ISO 8601, 4.4.3) followed by either:
           a)    a year-month-day designation (see 38.3.6.2) optionally followed by an hours-mins-sec designation
                 (see 38.3.6.3); or
           b)    a week designation (see 38.3.6.4); or
           c)    an hours-mins-sec designation (see 38.3.6.3).
38.3.6.2 A year-month-day designation shall be one or more (in order) of:
           a)    a year designation (see 38.3.6.5);
           b)    a month designation (see 38.3.6.6);
           c)    a day designation (see 38.3.6.7).
38.3.6.3 An hours-mins-secs designation shall be [T] followed by one or more (in order) of:
           a)    an hours designation (see 38.3.6.8); or
           b)    a minutes designation (see 38.3.6.9); or
           c)    a seconds designation (see 38.3.6.10).
38.3.6.4 A week designation shall consist of one or more digits optionally followed by a fractional part (see 38.3.6.12)
followed by [W].
38.3.6.5 A year designation shall consist of one or more digits optionally followed by a fractional part (see 38.3.6.12)
followed by [Y].


70           Rec. ITU-T X.680 (02/2021)
                                                                                                      ISO/IEC 8824-1:2021 (E)

38.3.6.6 A month designation shall consist of one or more digits optionally followed by a fractional part
(see 38.3.6.12) followed by [M].
38.3.6.7 A day designation shall consist of one or more digits optionally followed by a fractional part (see 38.3.6.12)
followed by [D].
38.3.6.8 An hours designation shall consist of one or more digits optionally followed by a fractional part
(see 38.3.6.12) followed by [H].
38.3.6.9 A minutes designation shall consist of one or more digits optionally followed by a fractional part
(see 38.3.6.12) followed by [M].
38.3.6.10 A seconds designation shall consist of one or more digits optionally followed by a fractional part
(see 38.3.6.12) followed by [S].
38.3.6.11 The integral part of a designation shall not contain leading zeros unless it is the single digit zero, optionally
followed by a fractional part. There shall be at least one digit in the integral part if there is a following fractional part.
38.3.6.12 A fractional part shall consist of a decimal separator (which shall be either a full stop or a comma), followed
by one or more decimal digits.
38.3.6.13 If a designation contains a fractional part, there shall be no following designation.
38.3.6.14 Value notations expressing a duration to different accuracies represent different abstract values.
EXAMPLE 1: The following value notations all represent different abstract values:
          a)   P29M (or P0Y29M) -- 0 years, 29 months to an accuracy of 1 month.
          b)   P29M0D (or P0Y29M0D) -- 0 years, 29 months, 0 days to an accuracy of 1 day.
          c)   P29MT0S (or P0Y29M0DT0H0M0S) -- 0 years, 29 months, 0 days, 0 hours, 0 minutes, 0 seconds, to an
               accuracy of 1 second.
          d)   P29MT0.00H (or P0Y29M0DT0,00H) -- 0 years, 29 months, 0 days, 0 hours, to an accuracy of one-
               hundredth of an hour.
          e)   P29MT0.000S (or P0Y29M0DT0H0M0.000S) -- 0 years, 29 months, 0 days, 0 hours, 0 minutes,
               0 seconds, to an accuracy of 1 millisecond.
EXAMPLE 2: The following value notations all represent the same abstract value (0 years, 29 months, 0 days, 0 hours,
0 minutes) to an accuracy of one-hundredth of a minute:
          a)   P0Y29M0DT0H0.00M
          b)   P0Y29M0DT0.00M
          c)   P0Y29MT0H0.00M
          d)   P0Y29MT0.00M
          e)   P29M0DT0H0.00M
          f)   P29M0DT0.00M
          g)   P29MT0H0.00M
          h)   P29MT0.00M


38.4      Useful time types
The following useful time types are defined, and are expected to cover most normal requirements of application
designers.
   NOTE – These definitions use the property setting subtype notation specified in clause 51. Where alternative time scales are
   required, for example, use of a Year and Day calendar, defined time types (see Annex B) can be used, or the property setting
   subtype notation can be used to define additional subtypes of the TIME type (see G.3 for examples of properties and settings that
   can be used).

38.4.1    The date type shall be referenced by the notation:
          DateType ::= DATE
and is defined as:
        DATE ::= [UNIVERSAL 31] IMPLICIT TIME
(SETTINGS "Basic=Date Date=YMD Year=Basic")



                                                                                    Rec. ITU-T X.680 (02/2021)                  71
ISO/IEC 8824-1:2021 (E)

38.4.2      The time-of-day type shall be referenced by the notation:
            TimeOfDayType ::= TIME-OF-DAY
and is defined as:
        TIME-OF-DAY ::= [UNIVERSAL 32] IMPLICIT TIME
(SETTINGS "Basic=Time Time=HMS Local-or-UTC=L")
   NOTE – This type allows midnight at start of day (00:00:00) as well as midnight at end of day (24:00:00).

38.4.3      The date-time type shall be referenced by the notation:
            DateTimeType ::= DATE-TIME
and is defined as:
          DATE-TIME ::= [UNIVERSAL 33] IMPLICIT TIME
(SETTINGS "Basic=Date-Time Date=YMD Year=Basic Time=HMS
 Local-or-UTC=L")
   NOTE – This type allows midnight at start of day (00:00:00) as well as midnight at end of day (24:00:00).

38.4.4      The duration type shall be referenced by the notation:
            DurationType ::= DURATION
and is defined as:
        DURATION ::= [UNIVERSAL 34] IMPLICIT TIME
(SETTINGS "Basic=Interval Interval-type=D")

Any subset of the TIME type, all of whose abstract values have the property settings "Basic=Interval Interval-
type=D" (whether UNIVERSAL 34 or UNIVERSAL 14), is called a duration subtype. This type can be constrained in
accordance with the following subclauses.
38.4.4.1 Inner subtyping constraints can be applied to any duration subtype using an equivalent sequence type
(see 38.4.4.2).
     NOTE – The inner subtyping constraint applied to the equivalent sequence type can be used to forbid or to require particular time
     components in the duration type, or to place range constraints on the values of some or all time components of the duration type
     (see also 51.11.2).

38.4.4.2 The DURATION-EQUIVALENT equivalent sequence type is:
            DURATION-EQUIVALENT ::= SEQUENCE {
            years            INTEGER (0..MAX) OPTIONAL,
            months           INTEGER (0..MAX) OPTIONAL,
            weeks            INTEGER (0..MAX) OPTIONAL,
            days             INTEGER (0..MAX) OPTIONAL,
            hours            INTEGER (0..MAX) OPTIONAL,
            minutes          INTEGER (0..MAX) OPTIONAL,
            seconds          INTEGER (0..MAX) OPTIONAL,
            fractional-part SEQUENCE {
                  number-of-digits  INTEGER(1..MAX),
                  fractional-value  INTEGER(0..MAX) } OPTIONAL }

where the years component of the equivalent sequence type corresponds to the years time component of the abstract
value of the duration type, and so on.
38.4.4.3 Constraints placed on the components of the equivalent sequence type are constraints on the corresponding
time components of the duration type.
     NOTE 1 – The rules for duration types require that at least one of the time components be present (see 38.2.3), but that no other
     time components be present when the week is present. Use of an inner subtyping constraint that violated these rules would be an
     illegal specification.
     NOTE 2 – The fractional-part always applies to the least significant time component that is present in the abstract value.

38.4.5 The basic value notation and the XML value notation for all the useful time types shall be the value notation
for the TIME type (see 38.3.2), restricted to notation for those abstract values that are present in the useful time type.


39          The character string types
These types consist of strings of characters from some specified character repertoire. It is normal to define a character
repertoire and its encoding by use of cells in one or more tables, each cell corresponding to a character in the repertoire.


72           Rec. ITU-T X.680 (02/2021)
                                                                                                     ISO/IEC 8824-1:2021 (E)

A graphic symbol and a character name are also usually assigned to each cell, although in some repertoires, cells are left
empty, or have names but no shapes (examples of cells with names but no shape include control characters such as EOF
in ISO/IEC 646 and spacing characters such as THIN-SPACE and EN-SPACE in ISO/IEC 10646).
In general, the information associated with a cell denotes a distinct abstract character in the repertoire even if that
information is null (no graphic symbol or name is assigned to that cell).
The ASN.1 basic value notation for character string types has three variants (which can be combined), specified
formally below:
          a)   A representation of the characters in the string using assigned graphic symbols, possibly including
               spacing characters; this is the "cstring" notation.
                   NOTE 1 – Such a representation can be ambiguous in a printed representation when the same graphic symbol is
                   used for more than one character in the repertoire.
                   NOTE 2 – Such a representation can be ambiguous in a printed representation when spacing characters of
                   different widths are present in the repertoire or the specification is printed with a proportional-spacing font.
          b)   A listing of the characters in the character string value by giving a series of ASN.1 value references that
               have been assigned the character; a set of such value references is defined in the module
               ASN1-CHARACTER-MODULE in clause 42 for the ISO/IEC 10646 character repertoire and for the
               IA5String character repertoire; this form is not available for other character repertoires unless the user
               assigns to such value references using the value notation described in a) above or c) below.
          c)   A listing of the characters in the character string value by identifying each abstract character by the
               position of its cell in the character repertoire table(s); this form is available only for IA5String,
               UniversalString, UTF8String and BMPString.
The ASN.1 XML value notation for character string types uses the "xmlcstring" notation, which includes the ability to
use escape sequences for certain special characters, and for specification of characters using decimal or hexadecimal
(see 12.15).


40        Notation for character string types
40.1      The notation for referencing a character string type (see 3.8.12) shall be:
               CharacterStringType ::=
                  RestrictedCharacterStringType
               |  UnrestrictedCharacterStringType
"RestrictedCharacterStringType" is the notation for a restricted character string type and is defined in clause 41.
"UnrestrictedCharacterStringType" is the notation for the unrestricted character string type and is defined in 44.1.
40.2      The tag of each restricted character string type is specified in 41.1. The tag of the unrestricted character string
type is specified in 44.2.
40.3      The notation for a character string value shall be:
               CharacterStringValue ::=
                  RestrictedCharacterStringValue
               |  UnrestrictedCharacterStringValue
               XMLCharacterStringValue ::=
                 XMLRestrictedCharacterStringValue
               | XMLUnrestrictedCharacterStringValue
"RestrictedCharacterStringValue" and "XMLRestrictedCharacterStringValue" are defined in 41.8 and 41.9 respectively.
"UnrestrictedCharacterStringValue" and "XMLUnrestrictedCharacterStringValue" are notations for an unrestricted
character string value and they are defined in 44.7.


41        Definition of restricted character string types
This clause defines types whose values are restricted to sequences of zero, one or more characters from some
specified collection of characters. The notation for referencing a restricted character string type shall be
"RestrictedCharacterStringType":
               RestrictedCharacterStringType ::=
                    BMPString
               |    GeneralString


                                                                                   Rec. ITU-T X.680 (02/2021)                   73
ISO/IEC 8824-1:2021 (E)

                 |    GraphicString
                 |    IA5String
                 |    ISO646String
                 |    NumericString
                 |    PrintableString
                 |    TeletexString
                 |    T61String
                 |    UniversalString
                 |    UTF8String
                 |    VideotexString
                 |    VisibleString

Each "RestrictedCharacterStringType" alternative is defined by specifying:
           a)    the tag assigned to the type; and
           b)    a name (e.g., NumericString) by which the type is referenced; and
           c)    the characters in the collection of characters used in defining the type, by reference to a table listing the
                 character graphics or by reference to a registration number in the ISO International Register of Coded
                 Character Sets (see ISO International Register of Coded Character Sets to be used with Escape
                 Sequences), or by reference to ISO/IEC 10646.

                                      Table 8 – List of restricted character string types

                                                 Universal         Defining registration numbera), table number,
       Name for referencing the type                                                                                     Notes
                                               class number        or Rec. ITU-T X.680 | ISO/IEC 8824-1 clause

     UTF8String                                      12          Subclause 41.16
     NumericString                                   18          Table 9                                                (Note 1)
     PrintableString                                 19          Table 10                                               (Note 1)
     TeletexString (T61String)                       20          6, 87, 102, 103, 106, 107, 126, 144, 150, 153, 156,    (Note 2)
                                                                 164, 165, 168 + SPACE + DELETE
     VideotexString                                  21          1, 13, 72, 73, 87, 89, 102, 108, 126, 128, 129, 144,   (Note 3)
                                                                 150, 153, 164, 165, 168 + SPACE + DELETE
     IA5String                                       22          1, 6 + SPACE + DELETE
     GraphicString                                   25          All G sets + SPACE
     VisibleString (ISO646String)                    26          6 + SPACE
     GeneralString                                   27          All G and all C sets + SPACE + DELETE
     UniversalString                                 28          See 41.6
     BMPString                                       30          See 41.15

a)      The defining registration numbers are listed in ISO International Register of Coded Character Sets to be used with Escape
        Sequences.
NOTE 1 – The type-style, size, colour, intensity, or other display characteristics are not significant.
NOTE 2 – Register entries 6 and 156 can be used instead of 102 and 103.
NOTE 3 – The entries corresponding to these registration numbers provide the functionality of CCITT Rec. T.100 and Rec. ITU-
T T.101.

41.1       Table 8 lists the name by which each restricted character string type is referenced, the number of the universal
class tag assigned to the type, the defining registration number or table, or the defining text clause, and, where
necessary, identification of a Note relating to the entry in the table. Where a synonymous name is defined in the
notation, this is listed in parentheses.
41.2      Table 9 lists the characters which can appear in the NumericString type and NumericString character
abstract syntax.




74           Rec. ITU-T X.680 (02/2021)
                                                                                                    ISO/IEC 8824-1:2021 (E)

                                                    Table 9 – NumericString
                                                   Name                  Graphic
                                                   Digits                0, 1, ... 9
                                                   Space                  (space)

41.3      The following object identifier, OID internationalized resource identifier and object descriptor values are
assigned to identify and describe the NumericString character abstract syntax:
{ joint-iso-itu-t asn1(1) specification(0) characterStrings(1) numericString(0) }
"/Joint-ISO-ITU-T/ASN.1/Specification/Character_Strings/Numeric_String"

and
"NumericString character abstract syntax"
   NOTE 1 – This object identifier value can be used in CHARACTER STRING values and in other cases where there is a need to carry
   the identification of the character string type separate from the value.
   NOTE 2 – A value of a NumericString character abstract syntax may be encoded by:
         a)     One of the rules given in ISO/IEC 10646 for encoding the abstract characters. In this case the character transfer
                syntax is identified by the object identifier associated with those rules in ISO/IEC 10646, Annex N.
         b)     The ASN.1 encoding rules for the built-in type NumericString. In this case the character transfer syntax is
                identified by the object identifier value {joint-iso-itu-t asn1(1) basic-encoding(1)}.

41.4      Table 10 lists the characters which can appear in the PrintableString type and PrintableString
character abstract syntax.

                                                  Table 10 – PrintableString

                                                 Name                        Graphic

                                          Latin capital letters              A, B, ... Z
                                          Latin small letters                a, b, ... z
                                                 Digits                      0, 1, ... 9
                                                SPACE                         (space)
                                           APOSTROPHE                            '
                                        LEFT PARENTHESIS                          (
                                       RIGHT PARENTHESIS                          )
                                             PLUS SIGN                            +
                                               COMMA                              ,
                                          HYPHEN-MINUS                            -
                                             FULL STOP                            .
                                              SOLIDUS                             /
                                               COLON                              :
                                           EQUALS SIGN                            =
                                         QUESTION MARK                            ?

41.5      The following object identifier, OID internationalized resource identifier and object descriptor values are
assigned to identify and describe the PrintableString character abstract syntax:
{ joint-iso-itu-t asn1(1) specification(0) characterStrings(1) printableString(1) }
"/Joint-ISO-ITU-T/ASN.1/Specification/Character_Strings/Printable_String"

and
"PrintableString character abstract syntax"
   NOTE 1 – This object identifier value can be used in CHARACTER STRING values and in other cases where there is a need to carry
   the identification of the character string type separate from the value.
   NOTE 2 – A value of a PrintableString character abstract syntax may be encoded by:
         a)     One of the rules given in ISO/IEC 10646 for encoding the abstract characters. In this case the character transfer
                syntax is identified by the object identifier associated with those rules in ISO/IEC 10646, Annex N.
         b)     The ASN.1 encoding rules for the built-in type PrintableString. In this case the character transfer syntax is
                identified by the object identifier { joint-iso-itu-t asn1(1) basic-encoding(1) }.



                                                                                       Rec. ITU-T X.680 (02/2021)             75
ISO/IEC 8824-1:2021 (E)

41.6    The characters which can appear in the UniversalString type are any of the characters allowed by
ISO/IEC 10646.
41.7       Use of this type invokes the conformance requirements specified in ISO/IEC 10646.
     NOTE – Clause 42 defines an ASN.1 module containing a number of subtypes of this type for the "Collections of graphics
     characters for subsets" defined in ISO/IEC 10646, Annex A.

41.8      The "RestrictedCharacterStringValue" notation for the restricted character string types shall be "cstring" (see
12.14), "CharacterStringList", "Quadruple", or "Tuple". "Quadruple" is only capable of defining a character string of
length one, and can only be used in value notation for UniversalString, UTF8String or BMPString types. "Tuple"
is only capable of defining a character string of length one, and can only be used in value notation for IA5String
types.
                 RestrictedCharacterStringValue ::=
                     cstring
                 |   CharacterStringList
                 |   Quadruple
                 |   Tuple
                 CharacterStringList ::= "{" CharSyms "}"
                 CharSyms ::=
                    CharsDefn
                 |  CharSyms "," CharsDefn
                 CharsDefn ::=
                    cstring
                 |  Quadruple
                 |  Tuple
                 |  DefinedValue
                 Quadruple ::= "{" Group "," Plane "," Row "," Cell "}"
                 Group      ::= number
                 Plane      ::= number
                 Row        ::= number
                 Cell       ::= number
                 Tuple      ::= "{" TableColumn "," TableRow "}"
                 TableColumn ::= number
                 TableRow ::= number
     NOTE 1 – The "cstring" notation can only be used unambiguously on a medium capable of displaying the graphic symbols for
     the characters which are present in the value. Conversely, if the medium has no such capability, the only means of
     unambiguously specifying a character string value that uses such graphic symbols is by means of the "CharacterStringList"
     notation, and only if the type is UniversalString, UTF8String, BMPString or IA5String, and the "DefinedValue"
     alternative of "CharsDefn" is used (see 42.1.2).
     NOTE 2 – Clause 42 defines a number of "valuereference"s which denote single characters (strings of size 1) of type BMPString
     (and hence UniversalString and UTF8String) and IA5String.
            EXAMPLE – Suppose that one wishes to specify a value of "abcdef" for a UniversalString where the character "" is
            not representable on the available medium, this value can also be expressed as:
           IMPORTS BasicLatin, greekCapitalLetterSigma FROM ASN1-CHARACTER-MODULE
           { joint-iso-itu-t asn1(1) specification(0) modules(0) iso10646(0) };
           MyAlphabet ::= UniversalString (FROM (BasicLatin | greekCapitalLetterSigma))
            mystring MyAlphabet ::= { "abc" , greekCapitalLetterSigma , "def" }
     NOTE 3 – When specifying the value of a UniversalString, UTF8String or BMPString type, the "cstring" notation should
     not be used unless ambiguities arising from different graphic characters with similar shapes have been resolved.
            EXAMPLE – The following "cstring" notation should not be used because the graphic symbols 'H', 'O', 'P' and 'E' occur in
            the BASIC LATIN, CYRILLIC and BASIC GREEK alphabets and thus are ambiguous.
           IMPORTS BasicLatin, Cyrillic, BasicGreek FROM ASN1-CHARACTER-MODULE
           { joint-iso-itu-t asn1(1) specification(0) modules(0) iso10646(0) };
           MyAlphabet ::= UniversalString (FROM (BasicLatin | Cyrillic | BasicGreek))



76           Rec. ITU-T X.680 (02/2021)
                                                                                                       ISO/IEC 8824-1:2021 (E)

            mystring MyAlphabet ::= "HOPE"
     An alternative unambiguous definition of mystring would be:
            mystring MyAlphabet(BasicLatin) ::= "HOPE"
     Formally, mystring is a value reference to a value of a subset of MyAlphabet, but it can, by the value mapping rules of Annex
     C, be used wherever a value reference is needed to this value within MyAlphabet.

41.9       The "XMLRestrictedCharacterStringValue" notation is:
                 XMLRestrictedCharacterStringValue ::= xmlcstring
Whitespace shall not occur around "XMLValue" in "XMLTypedValue" (see 16.2) for an
"XMLRestrictedCharacterStringValue" except where this notation is used in an encoding and the encoding rules
explicitly allow the whitespace (see Rec. ITU-T X.693 | ISO/IEC 8825-4, 39.3.2).
41.10 There are characters which cannot be directly represented in "xmlcstring". These shall be represented using the
escape sequences specified in 12.15.
     NOTE – If the restricted character string value contains characters which are not ISO/IEC 10646 characters specified in 12.15.1,
     these cannot be represented in "xmlcstring", and such values cannot be transferred using XML Encoding Rules (see Rec. ITU-T
     X.693 | ISO/IEC 8825-4).

41.11      The "DefinedValue" in "CharsDefn" shall be a reference to a value of that type.
41.12    The "number" in the "Plane", "Row" and "Cell" productions shall be less than 256, and in the "Group"
production it shall be less than 128.
41.13     The "Group" specifies a group in the coding space of the UCS, the "Plane" specifies a plane within the group,
the "Row" specifies a row within the plane, and the "Cell" specifies a cell within the row. The abstract character
identified by this notation is the abstract character for the cell specified by the "Group", "Plane", "Row", and "Cell"
values. In all cases, the set of permitted characters may be restricted by subtyping.
     NOTE – Application designers should consider carefully the conformance implications when using open-ended character string
     types such as GeneralString, GraphicString, and UniversalString without the application of constraints. Careful text on
     conformance is also needed for bounded but large character string types such as TeletexString.

41.14    The "number" in the "TableColumn" production shall be in the range zero to seven, and the "number" in the
"TableRow" production shall be in the range zero to fifteen. The "TableColumn" specifies a column and the
"TableRow" specifies a row of a character code table in accordance with Figure 1 of ISO/IEC 2022. This notation is
used only for IA5String when the code table contains Register Entry 1 in columns 0 and 1 and Register Entry 6 in
columns 2 to 7 (see the ISO International Register of Coded Character Sets to be used with Escape Sequences).
41.15     BMPString is a subtype of UniversalString that has its own unique tag and contains only the characters in
the Basic Multilingual Plane (those corresponding to the first 64K-2 cells, less cells whose encoding is used to address
characters outside the Basic Multilingual Plane) of ISO/IEC 10646. It has an associated type defined as:
           UniversalString (Bmp)

where Bmp is defined in the ASN.1 module ASN1-CHARACTER-MODULE (see clause 42) as the subtype of
UniversalString corresponding to the "BMP" collection name defined in ISO/IEC 10646, Annex A.
     NOTE 1 – Since BMPString is a built-in type, it is not defined in ASN1-CHARACTER-MODULE.
     NOTE 2 – The purpose of defining BMPString as a built-in type is to enable encoding rules (such as BER) that do not take
     account of constraints to use 16-bit rather than 32-bit encodings.
     NOTE 3 – In the value notation all BMPString values are valid UniversalString and UTF8String values.

41.16  UTF8String is synonymous with UniversalString at the abstract level and can be used wherever
UniversalString is used (subject to rules requiring distinct tags) but has a different tag and is a distinct type.
     NOTE – The encoding of UTF8String used by BER and PER is different from that of UniversalString, and for most text will
     be less verbose.



42         Naming characters, collections and property category sets
This clause specifies an ASN.1 built-in module which contains the definition of a value reference name for each
character from ISO/IEC 10646, where each name references a UniversalString value of size 1. This module also
contains the definition of a type reference name for each collection of characters from ISO/IEC 10646, where each
name references a subset of the UniversalString type. Finally, it contains the definition of a "typereference" name
for the set of characters in each general category of character properties that are listed in 4.5 of The Unicode Standard,
where each name references a subset of the UniversalString type.



                                                                                     Rec. ITU-T X.680 (02/2021)                  77
ISO/IEC 8824-1:2021 (E)

     NOTE – These values are available for use in the value notation of the UniversalString type and types derived from it. All of
     the value and type references defined in the module specified in 42.1 are exported and must be imported by any module that uses
     them.

42.1       Specification of the ASN.1 Module "ASN1-CHARACTER-MODULE"
The module is not printed here in full. Instead, the means by which it is defined is specified.
          NOTE – This Recommendation | International Standard is based on ISO/IEC 10646:2003. It cannot be applied using
          later versions of this standard. The specification of the means by which the "ASN1-CHARACTER-MODULE" is
          defined can only be applied with ISO/IEC 10646:2003.


42.1.1     The module begins as follows:
ASN1-CHARACTER-MODULE { joint-iso-itu-t asn1(1) specification(0) modules(0) iso10646(0) }
"/Joint-ISO-ITU-T/ASN.1/Specification/Modules/ISO_10646"
DEFINITIONS ::= BEGIN
           -- All of the value references and type references defined within this
           -- module are implicitly exported, and are available for import by any module.
           -- ISO/IEC 646 control characters:
           nul IA5String ::= {0, 0}
soh        IA5String ::= {0, 1}
stx        IA5String ::= {0, 2}
etx        IA5String ::= {0, 3}
eot        IA5String ::= {0, 4}
enq        IA5String ::= {0, 5}
ack        IA5String ::= {0, 6}
bel        IA5String ::= {0, 7}
bs         IA5String ::= {0, 8}
ht         IA5String ::= {0, 9}
lf         IA5String ::= {0,10}
vt         IA5String ::= {0,11}
ff         IA5String ::= {0,12}
cr         IA5String ::= {0,13}
so         IA5String ::= {0,14}
si         IA5String ::= {0,15}
dle        IA5String ::= {1, 0}
dc1        IA5String ::= {1, 1}
dc2        IA5String ::= {1, 2}
dc3        IA5String ::= {1, 3}
dc4        IA5String ::= {1, 4}
nak        IA5String ::= {1, 5}
syn        IA5String ::= {1, 6}
etb        IA5String ::= {1, 7}
can        IA5String ::= {1, 8}
em         IA5String ::= {1, 9}
sub        IA5String ::= {1,10}
esc        IA5String ::= {1,11}
is4        IA5String ::= {1,12}
is3        IA5String ::= {1,13}
is2        IA5String ::= {1,14}
is1        IA5String ::= {1,15}
del        IA5String ::= {7,15}

42.1.2 For each entry in each list of character names for the graphic characters (glyphs) shown in clauses 24 and 25
of ISO/IEC 10646, the module includes a statement of the form:
<namedcharacter> BMPString ::= <tablecell>
-- represents the character <iso10646name>, see ISO/IEC 10646
where:
           a)    <iso10646name> is the character name derived from one listed in ISO/IEC 10646;
           b)    <namedcharacter> is a string obtained by applying to <iso10646name> the procedures specified in
                 42.2;
           c)    <tablecell> is the glyph in the table cell in ISO/IEC 10646 corresponding to the list entry.
EXAMPLE
latinCapitalLetterA BMPString ::= {0, 0, 0, 65}


78           Rec. ITU-T X.680 (02/2021)
                                                                                                        ISO/IEC 8824-1:2021 (E)

-- represents the character LATIN CAPITAL LETTER A, see ISO/IEC 10646
greekCapitalLetterSigma BMPString ::= {0, 0, 3, 163}
-- represents the character GREEK CAPITAL LETTER SIGMA, see ISO/IEC 10646
42.1.3 For each name for a collection of graphic characters specified in ISO/IEC 10646, Annex A, a statement is
included in the module of the form:
<namedcollectionstring> ::= BMPString
(FROM (<alternativelist>))
          -- represents the collection of characters <collectionstring>,
          -- see ISO/IEC 10646.
where:
          a)   <collectionstring> is the name for the collection of characters assigned in ISO/IEC 10646;
          b)   <namedcollectionstring> is formed by applying to <collectionstring> the procedures of 42.3;
          c)   <alternativelist> is formed by using the <namedcharacter>s as generated in 42.2 for each of the
               characters specified by ISO/IEC 10646.
The resulting type reference, <namedcollectionstring>, forms a limited subset. (See the tutorial in Annex H.)
   NOTE – A limited subset is a list of characters in a specified subset. Contrast this to a selected subset, which is a collection of
   characters listed in ISO/IEC 10646, Annex A, plus the BASIC LATIN collection.

EXAMPLE (partial)
          space BMPString          ::= {0, 0, 0, 32}
exclamationMark BMPString ::= {0, 0, 0, 33}
quotationMark BMPString      ::= {0, 0, 0, 34}
...                    -- and so on
tilde BMPString        ::= {0, 0, 0, 126}
          BasicLatin ::= BMPString
          (FROM (space
          | exclamationMark
          | quotationMark
          | ...    -- and so on
          | tilde)
          )
-- represents the collection of characters BASIC LATIN, see ISO/IEC 10646.
-- The ellipsis in this example is used for brevity and means "and so on";
-- you cannot use this in an actual ASN.1 module.
42.1.4    ISO/IEC     10646     defines     three   levels    of   implementation.      By    default    all   types    defined    in
ASN1-CHARACTER-MODULE, except for Level1 and Level2 conform to implementation level 3, since such types have
no restriction on use of combining characters. Level1 indicates that implementation level 1 is required, Level2
indicates that implementation level 2 is required, and Level3 indicates that implementation level 3 is required. Thus,
the following are defined in ASN1-CHARACTER-MODULE:
Level1 ::= BMPString (FROM (BMPString(SIZE(1)) EXCEPT CombiningCharacters))
Level2 ::= BMPString (FROM (BMPString(SIZE(1)) EXCEPT CombiningCharactersType-2))
Level3 ::= BMPString
   NOTE 1 – CombiningCharacters and CombiningCharactersType-2 are the <namedcollectionstring>s corresponding to
   "COMBINING CHARACTERS" and "COMBINING CHARACTERS B-2", respectively, defined in ISO/IEC 10646, Annex A.
   NOTE 2 – Level1 and Level2 will be used either following an "IntersectionMark" (see clause 50) or as the only constraint in a
   "ConstraintSpec". (See G.2.7.1 for an example.)
   NOTE 3 – See H.2.5 for more information on this topic.

42.1.5 For each abbreviation and each description listed in The Unicode Standard, Table 4-5, two statements are
included in the module of the form:
          <categoryabbreviation> ::= UniversalString (FROM (<alternativelist>))
               -- represents the set of characters with the property
               -- category <categoryabbreviation>.
          <categorydescription> UniversalString ::= <categoryabbreviation>




                                                                                     Rec. ITU-T X.680 (02/2021)                   79
ISO/IEC 8824-1:2021 (E)

where:
           a)    <categoryabbreviation> is the abbreviation for the general category of character properties listed in The
                 Unicode Standard, Table 4-5 (for example, Lu or Nd or Pi);
           b)    <categorydescription> is the description for the same general category of characters, with the initial letter
                 of all words uppercased, the comma and all spaces removed, and all description in parentheses removed
                 (for example, LetterUppercase or NumericDigit or PunctuationInitialQuote);
           c)    The <alternativelist> for each <categoryabbreviation> is a list of the <namedcharacter> names produced
                 by 42.2 for each of the characters listed in The Unicode Character Database (version 3.2.0) of The
                 Unicode Standard that have the corresponding <categoryabbreviation>.
                NOTE – The Unicode name for a character is the same as the <iso10646name> for that character.

42.1.6 For the initial letter of each abbreviation listed in The Unicode Standard, Table 4-5, two statements are
included in the module of the form:
           <categoryabbreviationletter> ::= UniversalString (FROM (<alternativelist>))
                 -- represents the set of characters with any category property
                 -- with the initial letter <categoryabbreviationletter>.
           <maincategorydescription> UniversalString ::= <categoryabbreviationletter>

where:
           a)    <categoryabbreviationletter> is the first letter of the abbreviation for the general category of character
                 properties listed in The Unicode Standard, Table 4-5 (for example, L or N or P);
           b)    <categorydescription> is the first word of the description for the same general category of characters (for
                 example, Letter or Numeric or Punctuation);
           c)    The <alternativelist> for each <categoryabbreviationletter> is a list of the <namedcharacter> names
                 produced by 42.2 for each of the characters listed in The Unicode Character Database (version 3.2.0) of
                 The Unicode Standard that have the corresponding <categoryabbreviationletter>.
                NOTE – The Unicode name for a character is the same as the <iso10646name> for that character.

42.1.7     The module is terminated by the statement:
           END

42.1.8     A user-defined equivalent of the example in 42.1.3 is:
           BasicLatin ::= BMPString (FROM (space..tilde))
           -- represents the collection of characters BASIC LATIN,
           -- see ISO/IEC 10646.
42.2     A <namedcharacter> is the string obtained by taking an <iso10646name> (see 42.1.2) and applying the
following algorithm:
           a)    each upper-case letter of the <iso10646name> is transformed into the corresponding lower-case letter,
                 unless the upper-case letter is preceded by a SPACE, in which case the upper-case letter is kept
                 unchanged;
           b)    each digit and each HYPHEN-MINUS is kept unchanged;
           c)    each SPACE is deleted.
     NOTE – The above algorithm, taken in conjunction with the character naming guidelines in Annex K of ISO/IEC 10646 will
     always result in unambiguous value notation for every character name listed in ISO/IEC 10646.

EXAMPLE – The character from ISO/IEC 10646, row 0, cell 60, which is named "LESS-THAN SIGN" and has the
graphic representation "<" can be referenced using the "DefinedValue" of:
           less-thanSign

42.3     A <namedcollectionstring> is the string obtained by taking <collectionstring> and applying the
following algorithm:
           a)    each upper-case letter of the ISO/IEC 10646 collection name is transformed into the corresponding
                 lower-case letter, unless the upper-case letter is preceded by a SPACE or it is the first letter of the name,
                 in which case the upper-case letter is kept unchanged;
           b)    each digit and each HYPHEN-MINUS is kept unchanged;
           c)    each SPACE is deleted.



80          Rec. ITU-T X.680 (02/2021)
                                                                                                         ISO/IEC 8824-1:2021 (E)

EXAMPLES
1)          The collection identified in Annex A of ISO/IEC 10646 as:
                 BASIC LATIN
has the ASN.1 type reference:
            BasicLatin

2)     A character string type consisting of the characters in the BASIC LATIN collection, together with the BASIC
ARABIC collection, could be defined as follows:
          My-Character-String ::= BMPString (FROM (BasicLatin | BasicArabic) )
     NOTE – The above construction is necessary because the apparently simpler construction of:
           My-Character-String ::= BMPString (BasicLatin | BasicArabic)
     would allow only strings which were entirely BASIC LATIN or BASIC ARABIC but not a mixture of both.



43          Canonical order of characters
43.1      For the purpose of "ValueRange" subtyping and for possible use by encoding rules, a canonical ordering of
characters is specified for UniversalString, UTF8String, BMPString, NumericString, PrintableString,
VisibleString, and IA5String.

43.2     For the purpose of this clause only, a character is in one-to-one correspondence with a cell in a code table,
whether that cell has been assigned a character name or shape, and whether it is a control character or printing character,
combining or non-combining character.
43.3      The canonical order of an abstract character is defined by the canonical order of its value in the 32-bit
representation of ISO/IEC 10646, with low numbers appearing first and high numbers appearing last in the canonical
order.
43.4      Endpoints of "ValueRanges" within "PermittedAlphabet" notations (or individual characters) can be specified
using either the ASN.1 value reference defined in the module ASN1-CHARACTER-MODULE or (where the graphic symbol
is unambiguous in the context of the specification and the medium used to represent it) by giving the graphic symbol in
a "cstring" (ASN1-CHARACTER-MODULE is defined in 42.1) , or by use of the "Quadruple" or "Tuple" notation of 41.8.
43.5        For NumericString, the canonical ordering, increasing from left to right, is defined (see Table 9 of 41.2) as:
            (space) 0    1   2    3   4   5    6   7    8   9

The entire character set contains precisely 11 characters. The endpoint of a "ValueRange" (or individual characters) can
be specified using the graphic symbol in a "cstring".
     NOTE – This order is the same as the order of the corresponding characters in the BASIC LATIN collection of ISO/IEC 10646.

43.6     For PrintableString, the canonical ordering, increasing from left to right and top to bottom, is defined (see
Table 10 of 41.4) as:
            (SPACE) (APOSTROPHE) (LEFT PARENTHESIS) (RIGHT PARENTHESIS) (PLUS SIGN)
            (COMMA) (HYPHEN-MINUS) (FULL STOP) (SOLIDUS) 0123456789 (COLON) (EQUAL SIGN)
            (QUESTION MARK) ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
The entire character set contains precisely 74 characters. The endpoint of a "ValueRange" (or individual characters) can
be specified using the graphic symbol in a "cstring".
     NOTE – This order is the same as the order of the corresponding characters in the BASIC LATIN collection of ISO/IEC 10646.

43.7     For VisibleString, the canonical order of the cells is defined from the ISO/IEC 646 encoding (called
ISO 646 ENCODING) as follows:
            (ISO 646 ENCODING) - 32
     NOTE – That is, the canonical order is the same as the characters in cells 2/0-7/14 of the ISO/IEC 646 code table.

The entire character set contains precisely 95 characters. The endpoint of a "ValueRange" (or individual characters) can
be specified using the graphic symbol in a "cstring".
43.8        For IA5String, the canonical order of the cells is defined from the ISO/IEC 646 encoding as follows:
            (ISO 646 ENCODING)



                                                                                       Rec. ITU-T X.680 (02/2021)            81
ISO/IEC 8824-1:2021 (E)

The entire character set contains precisely 128 characters. The endpoint of a "ValueRange" (or individual characters)
can be specified using the graphic symbol in a "cstring" or an ISO 646 control character value reference defined in
42.1.1.


44          Definition of unrestricted character string types
This clause defines a type whose values are the values of any character abstract syntax. In an OSI environment, this
abstract syntax may be part of the OSI defined context set. Otherwise, it is referenced directly for each instance of use
of the unrestricted character string type.
     NOTE 1 – A character abstract syntax (and one or more corresponding character transfer syntaxes) can be defined by any
     organization able to allocate ASN.1 OBJECT IDENTIFIERs.
     NOTE 2 – Profiles produced by a community of interest will normally determine the character abstract syntaxes and character
     transfer syntaxes that are to be supported for specific instances or groups of instances of CHARACTER STRING. It will be usual in
     OSI applications to include reference to supported syntaxes in an OSI Protocol Implementation Conformance Statement.

44.1      The unrestricted character             string     type   (see   3.8.89)   shall   be    referenced    by    the   notation
"UnrestrictedCharacterStringType":
                 UnrestrictedCharacterStringType ::= CHARACTER STRING
44.2        This type has a tag which is universal class, number 29.
44.3        The type consists of values representing:
            a)   a character string value that may, but need not, be the value of an ASN.1 character string type; and
            b)   identification (separately or together) of:
                 1)      a character abstract syntax; and
                 2)      the character transfer syntax.
44.4     The unrestricted character string type has an associated type. This associated type is used to support its value
and subtype notations.
44.5     The associated type for value definition and subtyping, assuming an automatic tagging environment, is (with
normative comments):
SEQUENCE {
identification                               CHOICE {
           syntaxes                                 SEQUENCE {
                abstract                               OBJECT IDENTIFIER,
                transfer                               OBJECT IDENTIFIER }
                              -- Abstract and transfer syntax object identifiers --,
                 syntax                                            OBJECT IDENTIFIER
                              -- A single object identifier for identification of the
                              -- abstract and transfer syntaxes --,
            presentation-context-id                           INTEGER
                              -- (Applicable only to OSI environments)
                              -- The negotiated OSI presentation context identifies the
                              -- abstract and transfer syntaxes --,
                 context-negotiation                               SEQUENCE {
                 presentation-context-id                           INTEGER,
                 transfer-syntax                                   OBJECT IDENTIFIER }
                 -- (Applicable only to OSI environments)
                 -- Context-negotiation in progress, presentation-context-id
                 -- identifies only the
                 -- abstract-syntax, so the transfer syntax shall be specified --,
                 transfer-syntax                                          OBJECT IDENTIFIER
                 -- The type of the value (for example, specification that it is
                 -- the value of an ASN.1 type) is fixed by the application
                 -- designer (and hence known to both sender and receiver). This
                 -- case is provided primarily to support
                 -- selective-field-encryption (or other encoding
                 -- transformations) of an ASN.1 type --,
                 fixed                                                    NULL



82           Rec. ITU-T X.680 (02/2021)
                                                                                                      ISO/IEC 8824-1:2021 (E)

                 -- The data value is the value of a fixed ASN.1 type (and hence
                 -- known to both sender and receiver) -- },
           data-value-descriptor                       ObjectDescriptor OPTIONAL
                 -- This provides human-readable identification of the class of
                 -- the value --,
string-value                              OCTET STRING }
( WITH COMPONENTS {
           ... ,
           data-value-descriptor ABSENT } )
    NOTE – The unrestricted character string type does not allow the inclusion of a data-value-descriptor value together with
    the identification. However, the definition of the associated type provided here underlies the commonalities which exist
    between the embedded-pdv type, the external type and the unrestricted character string type.

44.6       The text of 36.6 and 36.7 also applies to the unrestricted character string type.
44.7       The value notation shall be the value notation for the associated type defined in 44.5, where the value of the
string-value component of type OCTET STRING represents an encoding using the transfer syntax specified in
identification.

           UnrestrictedCharacterStringValue ::= SequenceValue
           XMLUnrestrictedCharacterStringValue ::= XMLSequenceValue
44.8       An example of the unrestricted character string type is given in G.2.8.


45         Notation for types defined in clauses 46 to 48
45.1       The notation for referencing a type defined in clauses 46 to 48 shall be:
                 UsefulType ::= typereference
where "typereference" is one of those defined in clauses 46 to 48 using the ASN.1 notation.
45.2       The tag of each "UsefulType" is specified in clauses 46 to 48.


46         Generalized time
     NOTE 1 – Earlier versions of this Recommendation | International Standard used different text (due to the evolution of the ISO
     time standards), but the technical content is unchanged from the first version of this Recommendation | International Standard.
     NOTE 2 – The time type (see clause 38) gives more flexibility and should be preferred.

46.1       This type shall be referenced by the name:
           GeneralizedTime

46.2       The type consists of a calendar date, together with:
           a)    a local time of day, including midnight at the start of a day, but excluding midnight at the end of a day, to
                 an accuracy of:
                 1)   hours, minutes, and seconds (or seconds and fractions of a second to any number of decimal places);
                      or
                 2)   hours and minutes (or minutes and fractions of a minute to any number of decimal places); or
                 3)   hours (or hours and fractions of an hour to any number of decimal places); or
           b)    a UTC time of day, including midnight at the start of a day, but excluding midnight at the end of a day, to
                 any of the accuracies listed in a) above; or
           c)    a local time of day as specified in a) above, together with the difference between local time of day and
                 UTC.
                NOTE – The time difference component is positive if the local time of day is ahead of UTC.

46.3       The type is defined, using ASN.1, as follows:
           GeneralizedTime ::= [UNIVERSAL 24] IMPLICIT VisibleString

with the values of the VisibleString restricted to strings of characters which are either:




                                                                                     Rec. ITU-T X.680 (02/2021)                  83
ISO/IEC 8824-1:2021 (E)

         a)   a specification of a calendar date followed by a local time of day, consisting of:
              1)   a string representing the calendar date, as specified in ISO 8601, 4.1.2.2 – Basic format); followed
                   by:
                      NOTE 1 – This specifies a four-digit representation of the year, a two-digit representation of the month and
                      a two-digit representation of the day, without use of separators.
              2) a string representing the time of day to an accuracy of one hour, one minute, one second, or
              fractions of a second (to any degree of accuracy), using either comma or full stop as the decimal sign (as
              specified in ISO 8601, 4.2.2.2 and 4.2.2.3 – Basic format); optionally followed by:
              3)   a decimal fraction of a minute if seconds are omitted, or a decimal fraction of an hour if minutes and
                   seconds are omitted (as specified in ISO 8601, 4.2.2.4); or
                      NOTE 2 – ISO 8601 specifies the use of either a comma or a full stop as the decimal sign. There are no
                      other separators present. It is recommended that in any given ASN.1 specification, either comma or full stop
                      be consistently used as the decimal sign.
         b)   a specification of a calendar date and a UTC time consisting of the characters in a) above followed by an
              upper-case letter Z; or
         c)   a specification of a calendar date, the local time, and the exact difference between local time of day and
              UTC as specified in ISO 8601, with the minutes component optionally omitted if the difference is an
              integral number of hours.
                      NOTE 3 – Early work on ASN.1 canonical encoding rules assumed that there was no actual concept of
                      accuracy, so that an abstract value that might be represented with a seconds component of 3.000 was
                      regarded as the same abstract value as one that was represented with a seconds component of 3, and forbade
                      the use of trailing zeros in canonical encoding fractional parts, and forbade the omission of seconds or
                      minutes and seconds. It also supported only the use of UTC time, not local time of day or local time of day
                      with a time difference component. This has not been changed in later editions of the ASN.1 standards, for
                      backwards compatibility. The TIME type (introduced into ASN.1 in 2004) recognizes that abstract values
                      can have an associated accuracy, and that (e.g.) the representations of seconds as 3.000 and 3 produces
                      different abstract values, and that local time of day and UTC specifications represent different abstract
                      values. The canonical encoding rules for TIME encode the full range of its abstract values, so use of TIME
                      may be preferred in new specifications to the use of GeneralizedTime.
         In case c), the part of the string formed as in case a) represents the local time of day (t1), and the (signed) time
              difference (t2) enables UTC to be determined. If t2 is positive, local time of day is ahead of UTC. We can
              thus determine UTC as:
         UTC is t1 − t2
EXAMPLES
         Case a)
         "19851106210627.3"
         Local time of day 6 minutes, 27.3 seconds after 9 pm on 6 November 1985.
         Case b)
         "19851106210627.3Z"
         Coordinated universal time as above.
         Case c)
         "19851106210627.3-0500"
        Local time of day as in example a), with a coordinated universal time of 6 minutes, 27.3 seconds after 2 am on
7 November 1985.
         Case d)
         "198511062106.456"
         Local time of day 6.456 minutes after 9 pm on 6 November 1985.
         Case e)
         "1985110621.14159"
         Local time of day 0.14159 hours after 9 pm on 6 November 1985.
46.4     The tag shall be as defined in 46.3.
46.5     The value notation shall be the value notation for the VisibleString defined in 46.3.




84         Rec. ITU-T X.680 (02/2021)
                                                                                                 ISO/IEC 8824-1:2021 (E)

47         Universal time
47.1       This type shall be referenced by the name:
           UTCTime

47.2       The type consists of values representing:
           a)   calendar date; and
           b)   time to a precision of one minute or one second; and
           c)   (optionally) a local time of day differential from coordinated universal time.
47.3       The type is defined, using ASN.1, as follows:
           UTCTime ::= [UNIVERSAL 23] IMPLICIT VisibleString

with the values of the VisibleString restricted to strings of characters which are the juxtaposition of:
           a)   the six digits YYMMDD where YY is the two low-order digits of the Christian year, MM is the month
                (counting January as 01), and DD is the day of the month (01 to 31); and
           b)   either:
                1)   the four digits hhmm where hh is hour (00 to 23) and mm is minutes (00 to 59); or
                2)   the six digits hhmmss where hh and mm are as in 1) above, and ss is seconds (00 to 59); and
           c)   either:
                1)   the character Z; or
                2)   one of the characters + or -, followed by hhmm, where hh is hour and mm is minutes.
The alternatives in b) above allow varying precisions in the specification of the time.
In alternative c) 1), the time is coordinated universal time. In alternative c) 2), the time (t1) specified by a) and b) above
is the local time of day; the time differential (t2) specified by c) 2) above enables the coordinated universal time to be
determined as follows:
           Coordinated universal time is t1 − t2
EXAMPLE 1 – If local time of day is 7am on 2 January 1982 and coordinated universal time is 12 noon on 2 January
1982, the value of UTCTime is either of:
           –    "8201021200Z"; or
           –    "8201020700-0500".

EXAMPLE 2 – If local time of day is 7am on 2 January 2001 and coordinated universal time is 12 noon on 2 January
2001, the value of UTCTime is either of:
           –    "0101021200Z"; or
           –    "0101020700-0500".

47.4       The tag shall be as defined in 47.3.
47.5       The value notation shall be the value notation for the VisibleString defined in 47.3.


48         The object descriptor type
48.1       This type shall be referenced by the name:
           ObjectDescriptor

48.2       The type consists of human-readable text which serves to describe an object. The text is not an unambiguous
identification of the object, but identical text for different objects is intended to be uncommon.
     NOTE – It is recommended that an authority assigning values of type OBJECT IDENTIFIER to an object should also assign
     values of type ObjectDescriptor to that object.

48.3       The type is defined, using ASN.1, as follows:
           ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString

The GraphicString contains the text describing the object.



                                                                                Rec. ITU-T X.680 (02/2021)                 85
ISO/IEC 8824-1:2021 (E)

48.4       The tag shall be as defined in 48.3.
48.5       The value notation shall be the value notation for the GraphicString defined in 48.3.


49         Constrained types
49.1      The "ConstrainedType" notation allows a constraint to be applied to a (parent) type, either to restrict its set of
values to some subtype of the parent or (within a set or sequence type) to specify that component relations apply to
values of the parent type and to values of some other component in the same set or sequence value. It also allows an
exception identifier to be associated with a constraint.
                 ConstrainedType ::=
                     Type Constraint
                 |   TypeWithConstraint
In the first alternative, the parent type is "Type", and the constraint is specified by "Constraint" as defined in 49.6. The
second alternative is defined in 49.5.
49.2     When the "Constraint" notation follows a set-of or sequence-of type notation, it applies to the "Type" in the
(innermost) set-of or sequence-of notation, not to the set-of or sequence-of type.
     NOTE – For example, in the following the constraint (SIZE(1..64)) applies to the VisibleString, not the SEQUENCE OF:
           NamesOfMemberNations ::= SEQUENCE OF VisibleString (SIZE(1..64))

49.3      When the "Constraint" notation follows the selection type notation, it applies to the choice type, and not to the
type of the selected alternative. Such a constraint is ignored (see 30.2).
     NOTE – In the following example, the constraint (WITH COMPONENTS {..., a ABSENT}) applies to the CHOICE type T, not to
     the selected SEQUENCE type, and has no effect on the values of V.
           T ::= CHOICE {
           a SEQUENCE {
                a INTEGER OPTIONAL,
                b BOOLEAN
           },
           b NULL
}
           V ::= a < T (WITH COMPONENTS {..., a ABSENT})

49.4      When the "Constraint" notation follows a "PrefixedType" notation, the interpretation of the overall notation is
the same regardless of whether the "PrefixedType" or the "Type" is considered as the parent type.
49.5      As a consequence of the interpretation specified in 49.2, special notation is provided to allow a constraint to
be applied to a set-of or sequence-of type. This is "TypeWithConstraint":
                 TypeWithConstraint ::=
                     SET Constraint OF Type
                 |   SET SizeConstraint OF Type
                 |   SEQUENCE Constraint OF Type
                 |   SEQUENCE SizeConstraint OF Type
                 |   SET Constraint OF NamedType
                 |   SET SizeConstraint OF NamedType
                 |   SEQUENCE Constraint OF NamedType
                 |   SEQUENCE SizeConstraint OF NamedType

In the first and second alternatives the parent type is "SET OF Type", while in the third and fourth it is "SEQUENCE OF
Type". In the fifth and sixth alternatives the parent type is "SET OF NamedType", and in the seventh and eighth is
"SEQUENCE OF NamedType". In the first, third, fifth and seventh alternatives, the constraint is "Constraint" (see 49.6),
while in the second, fourth, sixth and eighth it is "SizeConstraint" (see 51.5).
     NOTE – Although the "Constraint" alternatives encompass the corresponding "SizeConstraint" alternatives, the "SizeConstraint"
     alternatives are provided for historical reasons.

49.6       A constraint is specified by the notation "Constraint":
                 Constraint ::= "(" ConstraintSpec ExceptionSpec ")"




86           Rec. ITU-T X.680 (02/2021)
                                                                                                    ISO/IEC 8824-1:2021 (E)

                 ConstraintSpec ::=
                     SubtypeConstraint
                 |   GeneralConstraint
"ExceptionSpec" is defined in clause 53. Unless it is used in conjunction with an "extension marker" (see clause 52), it
shall only be present if the "ConstraintSpec" includes an occurrence of "DummyReference" (see Rec. ITU-T X.683 |
ISO/IEC 8824-4, 8.3) or is a "UserDefinedConstraint" (see Rec. ITU-T X.682 | ISO/IEC 8824-3, clause 9). The
"GeneralConstraint" is defined in Rec. ITU-T X.682 | ISO/IEC 8824-3, 8.1.
49.7       The notation "SubtypeConstraint" is the general-purpose "ElementSetSpecs" notation (see clause 50):
                 SubtypeConstraint ::= ElementSetSpecs
In this context, the elements are values of the parent type (the governor of the element set is the parent type). There shall
be at least one element in the set.

50         Element set specification
50.1      In some notations a set of elements of some identified type or information object class (the governor) can be
specified. In such cases, the notation "ElementSetSpec" is used:
                 ElementSetSpecs ::=
                     RootElementSetSpec
                 |   RootElementSetSpec "," "..."
                 |   RootElementSetSpec "," "..." "," AdditionalElementSetSpec
                 RootElementSetSpec ::= ElementSetSpec
                 AdditionalElementSetSpec ::= ElementSetSpec
                 ElementSetSpec ::= Unions
                 |   ALL Exclusions

                 Unions ::= Intersections
                 |   UElems UnionMark Intersections
                 UElems ::= Unions
                 Intersections ::= IntersectionElements
                 |    IElems IntersectionMark IntersectionElements
                 IElems ::= Intersections
                 IntersectionElements ::= Elements | Elems Exclusions
                 Elems ::= Elements
                 Exclusions ::= EXCEPT Elements
                 UnionMark ::= "|" | UNION
                 IntersectionMark ::= "^" | INTERSECTION
     NOTE 1 – The caret character "^" and the word INTERSECTION are synonymous. The character "|" and the word UNION are
     synonymous. It is recommended that, as a stylistic matter, either the characters or the words be used throughout a user
     Specification. EXCEPT can be used with either style.
     NOTE 2 – The order of precedence from highest to lowest is: EXCEPT, "^", "|". Notice that ALL EXCEPT is specified so that it
     cannot be interspersed with the other constraints without the use of parentheses around "ALL EXCEPT xxx".
     NOTE 3 – Anywhere that "Elements" occurs, either a constraint without parentheses [e.g., INTEGER (1..4)] or a parenthesized
     subtype constraint [e.g., INTEGER ((1..4 | 9))] can appear.
     NOTE 4 – Note that two EXCEPT operators must have either "|", "^", "(" or ")" separating them, so (A EXCEPT B EXCEPT
     C) is not permitted. This must be changed to ((A EXCEPT B) EXCEPT C) or (A EXCEPT (B EXCEPT C)).
     NOTE 5 – Note that ((A EXCEPT B) EXCEPT C) is the same as (A EXCEPT (B | C)).
     NOTE 6 – The elements that are referenced by "ElementSetSpecs" is the union of the elements referenced by the
     "RootElementSetSpec" and "AdditionalElementSetSpec" (when present).
     NOTE 7 – When the elements are information objects (i.e., the governor is an information object class), the notation
     "ObjectSetElements" as defined in Rec. ITU-T X.681 | ISO/IEC 8824-2, 12.10 is used.




                                                                                   Rec. ITU-T X.680 (02/2021)                 87
ISO/IEC 8824-1:2021 (E)

50.2      The elements forming the set are:
          a)   if the first alternative of the "ElementSetSpec" is selected, those specified in the "Unions" [see b)],
               otherwise all elements of the governor except those specified in the "Elements" notation of the
               "Exclusions";
          b)   if the first alternative of "Unions" is selected, then those specified in the "Intersections" [see c)],
               otherwise those specified at least once either in the "UElems" or "Intersections";
          c)   if the first alternative of "Intersections" is selected, those specified in the "IntersectionElements" [see d)],
               otherwise those specified by "IElems" which also are specified by "IntersectionElements";
          d)   if the first alternative of "IntersectionElements" is selected, those specified in the "Elements", otherwise
               those specified in the "Elems" except those specified in the "Exclusions".
50.3      When the elements are information objects (i.e., the governor is an information object class), the second
alternative of "ElementSetSpec" shall not be used.
50.4      The set of values is defined to be extensible if the following conditions hold:
          a)   for "ElementsSetSpecs": there is an extension marker at the outer level;
                   NOTE – This applies even if all values of the parent are included in the root of the new constrained type.
          b)   for "Unions": at least one of the "UElems" is extensible;
          c)   for "Intersections": at least one of the "IElems" is extensible;
          d)   for "Exclusions": the set of elements preceding EXCEPT is extensible.
Otherwise, the set of values is not extensible (see also I.4).
50.5      If the set of values is extensible, the root values can be determined by performing the set arithmetic using only
root values of the sets of values involved in the set arithmetic, as specified in 50.2. The extension additions can be
determined by performing the set arithmetic using the root values augmented by the extension additions, for each set of
values involved in the set arithmetic, and then excluding values that were determined to be root values.
50.6      The "Elements" notation is defined as follows:
               Elements ::=
                   SubtypeElements
               |   ObjectSetElements
               |   "(" ElementSetSpec ")"
The elements specified by this notation are:
          a)   As described in clause 51 below if the "SubtypeElements" alternative is used. This notation shall only be
               used when the governor is a type, and the actual type involved will further constrain the notational
               possibilities. In this context, the governor is referred to as the parent type.
          b)   As described in Rec. ITU-T X.681 | ISO/IEC 8824-2, 12.10, if the "ObjectSetElements" notation is used.
               This notation shall only be used when the governor is an information object class.
          c)   Those specified by the "ElementSetSpec" if the third alternative is used.
50.7       When performing set arithmetic within a subtype constraint or a value set when the governing type is not
extensible, only abstract values of the governing type are used in the set arithmetic. In this case, all instances of value
notation (including value references) used in set arithmetic are required to reference an abstract value of the governing
type. The end-points of a range constraint are required to reference values of the governing type, and the range
specification as a whole references all (and only) those values in the range that are abstract values of the governing type.
50.8       When performing set arithmetic within a subtype constraint or a value set when the governing type is
extensible, only abstract values that are in the extension root of the governing type are used in the set arithmetic. In this
case, all instances of value notation (including value references) used in set arithmetic are required to reference an
abstract value of the extension root of the governing type. The end-points of a range constraint are required to reference
values that are present in the extension root of the governing type, and the range specification as a whole references all
(and only) those values in the range that are within the extension root of the governing type.
50.9      When performing set arithmetic involving information object sets, all information objects are used in the set
arithmetic. If any of the information object sets contributing to the set arithmetic are extensible, or if there is an
extension marker at the outermost level of an "ElementSetSpecs", the result of the set arithmetic is extensible.
50.10     If a subtype constraint is applied to a parent type which is not extensible, value notation used within it shall
not reference values that are not abstract values of the parent type.



88         Rec. ITU-T X.680 (02/2021)
                                                                                                   ISO/IEC 8824-1:2021 (E)

50.11     If a subtype constraint is serially applied to a parent type which is extensible through the application of an
extensible constraint, value notation used within it shall not reference values that are not in the extension root of the
parent type. The result of the second (serially applied) constraint is defined to be the same as if the constraint had been
applied to the parent type without its extension marker and possible extension additions.
EXAMPLE
Foo ::= INTEGER ( 1..6, ..., 73..80)
Bar ::= Foo (73) -- illegal
foo Foo ::= 73 -- legal since it is value notation for Foo, not part of a constraint

Bar is illegal since 73 is not in the extension root of Foo. If 73 had been in the extension root of Foo, the example
would have been legal, and Bar would have contained the single value of 73.
     NOTE – This subclause applies only to "SubtypeConstraint". If a "GeneralConstraint" (see Rec. ITU-T X.682 | ISO/IEC 8824-3,
     8.1) is applied to a parent type, then extensibility of that parent type is not affected.



51         Subtype elements

51.1       General
A number of different forms of notation for "SubtypeElements" are provided. They are identified below, and their
syntax and semantics are defined in the following subclauses. Table 11 and Table 12 summarize which notations can be
applied to which parent types. "SubtypeElements" not present in one of the tables means that the corresponding subtype
element cannot be applied to any of the parent types listed in that table.
                 SubtypeElements ::=
                     SingleValue
                 |   ContainedSubtype
                 |   ValueRange
                 |   PermittedAlphabet
                 |   SizeConstraint
                 |   TypeConstraint
                 |   InnerTypeConstraints
                 |   PatternConstraint
                 |   PropertySettings
                 |   DurationRange
                 |   TimePointRange
                 |   RecurrenceRange




                                                                                       Rec. ITU-T X.680 (02/2021)            89
ISO/IEC 8824-1:2021 (E)

                    Table 11 – Applicability of "SubtypeElements" to types other than the Time type

   Type (or derived          Single     Contained      Value         Size       Permitted       Type         Inner        Pattern
 from such a type by         value       subtype       range      constraint    alphabet      constraint   subtyping     constraint
tagging or subtyping)
Bit string                     Yes         Yes          No           Yes            No               No       No             No
Boolean                        Yes         Yes          No           No             No               No       No             No
Choice                         Yes         Yes          No           No             No               No      Yes             No
Embedded-pdv                   Yes          No          No           No             No               No      Yes             No
Enumerated                     Yes         Yes          No           No             No               No       No             No
External                       Yes          No          No           No             No               No      Yes             No
Instance-of                    Yes         Yes          No           No             No               No      Yes             No
Integer                        Yes         Yes          Yes          No             No               No       No             No
Null                           Yes         Yes          No           No             No               No       No             No
Object class field type        Yes         Yes          No           No             No               No       No             No
Object descriptor              Yes         Yes          No           Yes           Yes               No       No             No
Object identifier              Yes         Yes          No           No             No               No       No             No
Octet string                   Yes         Yes          No           Yes            No               No       No             No
OID internationalized          Yes         Yes          No           No             No               No       No             No
resource identifier
open type                      No           No          No           No             No           Yes          No             No
Real                           Yes         Yes          Yes          No             No               No      Yes             No
Relative object               Yesb)       Yesb)         No           No             No               No       No             No
identifier
Relative OID                  Yesb)        Yesb)        No           No             No               No       No             No
internationalized
resource identifier
Restricted character           Yes         Yes         Yesa)         Yes           Yes               No       No             Yes
string types
Sequence                       Yes         Yes          No           No             No               No      Yes             No
Sequence-of                    Yes         Yes          No           Yes            No               No      Yes             No
Set                            Yes         Yes          No           No             No               No      Yes             No
Set-of                         Yes         Yes          No           Yes            No               No      Yes             No
GeneralizedTime and            Yes         Yes          No           No             No               No       No             No
UTCTime types
Unrestricted character         Yes          No          No           Yes            No               No      Yes             No
string type
a)     Allowed only within the "PermittedAlphabet" of BMPString, IA5String, NumericString, PrintableString,
       VisibleString, UTF8String and UniversalString.
b)     The starting node for all relative object identifier and relative OID internationalized resource identifier types or values in
       constraints or valuesets shall be the same as the starting node for the governor.


                              Table 12 – Applicability of "SubtypeElements" to the Time type

        Type (or
      derived from                                                                 Time
                          Single      Contained      Property       Duration                 Recurrence
     such a type by                                                                point                       Inner subtyping
                          value        subtype        settings       range                     range
       tagging or                                                                  range
       subtyping)
     Time type             Yes           Yes            Yes            Yes          Yes              Yes            (Note)
      NOTE – Only allowed if all the abstract values of the parent type have the property settings
      "Basic=Interval Interval-type=D" (see 38.4.4).




90            Rec. ITU-T X.680 (02/2021)
                                                                                                     ISO/IEC 8824-1:2021 (E)

51.2      Single value
51.2.1    The "SingleValue" notation shall be:
               SingleValue ::= Value
where "Value" is the value notation for the parent type.
51.2.2    A "SingleValue" specifies the single value of the parent type specified by "Value".

51.3      Contained subtype
51.3.1    The "ContainedSubtype" notation shall be:
               ContainedSubtype ::= Includes Type
               Includes ::= INCLUDES | empty
The "empty" alternative of the "Includes" production shall not be used when "Type" in "ContainedSubtype" is the
notation for the null type.
51.3.2 A "ContainedSubtype" specifies all of the values in the root of the parent type that are also in the root of
"Type". "Type" is required to be derived from the same built-in type as the parent type.
51.3.3 The set of values referenced by an extensible "Type" used in a contained subtype constraint does not inherit
the extension marker from the "Type". Any values in "Type" that are not in the extension root of that type are ignored,
and do not contribute to the values of the constrained type.
   NOTE – The use of an extensible "Type" does not in itself make the constrained type extensible.


51.4      Value range
51.4.1    The "ValueRange" notation shall be:
               ValueRange ::= LowerEndpoint ".." UpperEndpoint
51.4.2 A "ValueRange" specifies the values in a range of values which are designated by specifying the values of the
endpoints of the range. This notation can only be applied to integer types, the "PermittedAlphabet" of certain restricted
character string types (IA5String, NumericString, PrintableString, VisibleString, BMPString,
UniversalString and UTF8String only) and real types. All values specified in the "ValueRange" are required to be
in the root of the parent type.
   NOTE – For the purpose of subtyping, NOT-A-NUMBER exceeds all real values, PLUS-INFINITY exceeds all real values except
   NOT-A-NUMBER, minus zero exceeds all negative real values and is less than plus zero, and MINUS-INFINITY is less than all real
   values. Otherwise, normal mathematical ordering is applied.

51.4.3 Each endpoint of the range is either closed (in which case that endpoint is specified) or open (in which case
the endpoint is not specified). When open, the specification of the endpoint includes a less-than symbol ("<"):
               LowerEndpoint ::= LowerEndValue | LowerEndValue "<"
               UpperEndpoint ::= UpperEndValue | "<" UpperEndValue
51.4.4 An endpoint may also be unspecified, in which case the range extends in that direction as far as the parent
type allows:
               LowerEndValue ::= Value | MIN
               UpperEndValue ::= Value | MAX
   NOTE – When a "ValueRange" is used as a "PermittedAlphabet" constraint, "LowerEndValue" and "UpperEndValue" shall be of
   size 1.


51.5      Size constraint
51.5.1    The "SizeConstraint" notation shall be:
               SizeConstraint ::= SIZE Constraint
51.5.2 A "SizeConstraint" can only be applied to bit string types, octet string types, character string types, set-of
types or sequence-of types.




                                                                                   Rec. ITU-T X.680 (02/2021)                 91
ISO/IEC 8824-1:2021 (E)

51.5.3 The "Constraint" specifies the permitted integer values for the length of the specified values, and takes the
form of any constraint which can be applied to the following parent type:
            INTEGER (0 .. MAX)

The "Constraint" shall use the "SubtypeConstraint" alternative of "ConstraintSpec".
51.5.4      The unit of measure depends on the parent type, as follows:
            Type                             Unit of measure
            bit string                       bit
            octet string                     octet
            character string                 character
            set-of                           component value
            sequence-of                      component value
     NOTE – The count of the number of characters specified in this subclause for determining the size of a character string value
     shall be clearly distinguished from a count of octets. The count of characters shall be interpreted according to the definition of the
     collection of characters used in the type, in particular, in relation to references to the standards, tables or registration numbers in a
     register which can appear in such a definition.


51.6        Type constraint
51.6.1      The "TypeConstraint" notation shall be:
                   TypeConstraint ::= Type
51.6.2      This notation is only applied to an open type notation and restricts the open type to values of "Type".

51.7        Permitted alphabet
51.7.1      The "PermittedAlphabet" notation shall be:
                   PermittedAlphabet ::= FROM Constraint
51.7.2 A "PermittedAlphabet" specifies all values which can be constructed using a sub-alphabet of the parent string.
This notation can only be applied to restricted character string types.
51.7.3 The "Constraint" shall use the "SubtypeConstraint" alternative of "ConstraintSpec". Each "SubtypeElements"
within that "SubtypeConstraint" shall be one of the four alternatives "SingleValue", "ContainedSubtype",
"ValueRange", and "SizeConstraint". The sub-alphabet includes precisely those characters which appear in one or more
of the values of the parent string type which are allowed by the "Constraint".
51.7.4 If "Constraint" is extensible, then the set of values selected by the permitted alphabet constraint is extensible.
The set of values in the root are those permitted by the root of "Constraint", and the extension additions are those values
permitted by the root together with the extension-additions of "Constraint", excluding those values already in the root.

51.8        Inner subtyping
51.8.1      The "InnerTypeConstraints" notation shall be:
                   InnerTypeConstraints ::=
                       WITH COMPONENT SingleTypeConstraint
                   |   WITH COMPONENTS MultipleTypeConstraints

51.8.2 An "InnerTypeConstraints" specifies only those values which satisfy a collection of constraints on the
presence and/or values of the components of the parent type. A value of the parent type is not specified unless it
satisfies all of the constraints expressed or implied (see 51.8.7). This notation can be applied to the set-of, sequence-of,
set, sequence and choice types.
     NOTE – An "InnerTypeConstraints" applied to a set or sequence type is ignored by the COMPONENTS OF transformation (see
     25.5 and 27.2).

51.8.3 If an "InnerTypeConstraints" contains a "GeneralConstraint" (see 49.6), then it shall only be used (directly or
indirectly) as part of the first alternative of the productions, "ElementSetSpecs" (see clause 50) and/or "ObjectSetSpec"
(see Rec. ITU-T X.681 | ISO/IEC 8824-2, 12.3) and of the first alternative of the productions "ElementSetSpec",
"Unions", "Intersections", and "IntersectionElements" (see clause 50).


92            Rec. ITU-T X.680 (02/2021)
                                                                                                ISO/IEC 8824-1:2021 (E)

51.8.4 For the types which are defined in terms of a single other (inner) type (set-of and sequence-of), a constraint
taking the form of a subtype value specification is provided. The notation for this is "SingleTypeConstraint":
               SingleTypeConstraint ::= Constraint
The "Constraint" defines a subtype of the single other (inner) type. A value of the parent type is specified if and only if
each inner value belongs to the subtype obtained by applying the "Constraint" to the inner type.
51.8.5 For the types which are defined in terms of multiple other (inner) types (choice, set, and sequence), a number
of constraints on these inner types can be provided. The notation for this is "MultipleTypeConstraints":
               MultipleTypeConstraints ::=
                   FullSpecification
               |   PartialSpecification
               FullSpecification ::= "{" TypeConstraints "}"
               PartialSpecification ::= "{" "..."        "," TypeConstraints "}"
               TypeConstraints ::=
                   NamedConstraint
               |   NamedConstraint "," TypeConstraints
               NamedConstraint ::=
                  identifier ComponentConstraint
51.8.6 The "TypeConstraints" contains a list of constraints on the component types of the parent type. For a sequence
type, the constraints must appear in order. The inner type to which the constraint applies is identified by means of its
identifier. For a given component, there shall be at most one "NamedConstraint".
51.8.7 The "MultipleTypeConstraints" comprises either a "FullSpecification" or a "PartialSpecification". When
"FullSpecification" is used, there is an implied presence constraint of ABSENT on all inner types which can be
constrained to be absent (see 51.8.10) and which is not explicitly listed. Where "PartialSpecification" is employed, there
are no implied constraints, and any inner type can be omitted from the list.
51.8.8 A particular inner type may be constrained in terms of its presence (in values of the parent type), its value, or
both. The notation is "ComponentConstraint":
               ComponentConstraint ::= ValueConstraint PresenceConstraint
51.8.9    A constraint on the value of an inner type is expressed by the notation "ValueConstraint":
               ValueConstraint ::= Constraint | empty
The constraint is satisfied by a value of the parent type if and only if the inner value belongs to the subtype specified by
the "Constraint" applied to the inner type.
51.8.10 A constraint on the presence of an inner type shall be expressed by the notation "PresenceConstraint":
               PresenceConstraint ::= PRESENT | ABSENT | OPTIONAL | empty
The meaning of these alternatives, and the situations in which they are permitted are defined in 51.8.10.1 to 51.8.10.3.
51.8.10.1 If the parent type is a sequence or set, a component type marked OPTIONAL may be constrained to be
PRESENT (in which case the constraint is satisfied if and only if the corresponding component value is present) or to be
ABSENT (in which case the constraint is satisfied if and only if the corresponding component value is absent) or to be
OPTIONAL (in which case no constraint is placed upon the presence of the corresponding component value).

51.8.10.2 If the parent type is a choice, a component type can be constrained to be ABSENT (in which case the constraint
is satisfied if and only if the corresponding component type is not used in the value), or PRESENT (in which case the
constraint is satisfied if and only if the corresponding component type is used in the value); there shall be at most one
PRESENT keyword in a "MultipleTypeConstraints".
   NOTE – See G.5.6 for a clarifying example.

51.8.10.3 The meaning of an empty "PresenceConstraint" depends on whether a "FullSpecification" or a
"PartialSpecification" is being employed:
          a)   in a "FullSpecification", this is equivalent to a constraint of PRESENT for a set or sequence component
               marked OPTIONAL and imposes no further constraint otherwise;
          b)   in a "PartialSpecification", no constraint is imposed.



                                                                               Rec. ITU-T X.680 (02/2021)                93
ISO/IEC 8824-1:2021 (E)

51.9       Pattern constraint
51.9.1     The "PatternConstraint" notation shall be:
                 PatternConstraint ::= PATTERN Value
51.9.2 "Value" shall be a "cstring" of type UniversalString (or a reference to such a character string) which
contains an ASN.1 regular expression as defined in Annex A. The "PatternConstraint" selects those values of the parent
type that satisfy the ASN.1 regular expression. The entire value shall satisfy the entire ASN.1 regular expression, i.e.,
the "PatternConstraint" does not select values whose leading characters match the (entire) ASN.1 regular expression but
which contain further trailing characters.
     NOTE – "Value" is formally defined as a value of type UniversalString, but the sets of values of type UniversalString and
     UTF8String are the same (see 41.16). Thus a totally equivalent definition could have been to say that "Value" is a value of type
     UTF8String.


51.10      Property settings
51.10.1 The "PropertySettings" notation shall be:
           PropertySettings ::= SETTINGS simplestring
51.10.2 The contents of the "simplestring" shall be "PropertySettingsList":
           PropertySettingsList ::=
               PropertyAndSettingPair
               |   PropertySettingsList PropertyAndSettingPair
           PropertyAndSettingPair ::= PropertyName "=" SettingName
           PropertyName ::= psname
           SettingName ::= psname
51.10.3 The "PropertyName" shall be one of the time property names listed in column 1 of Table 6, and shall appear
at most once in the "PropertySettingsList".
51.10.4 The "SettingName" of a "PropertyAndSettingPair" shall be one of the property setting names that are listed in
column 2 of Table 6 in the row that contains (in column 1) the "PropertyName" of that "PropertyAndSettingPair".
51.10.5 An abstract value shall be included in the subtype if, and only if, it satisfies the following condition for all of
the "PropertyAndSettingPair"s. Either:
           a)    the abstract value does not have a property setting for the "PropertyName" (see columns 2 and 3 of
                 Table 6 for the abstract values that have a property setting for a given "PropertyName"); or
           b)    the abstract value has a property setting that is the same as the "SettingName".
     NOTE – To assist with human readability, it is recommended, but not required, that the setting of the Basic time property be
     always included as the first "PropertyAndSettingPair".

EXAMPLE: TIME(SETTINGS "Midnight=Start") would produce a subset of the TIME type in which all abstract
values are present (including those that represent dates only) except those that have the property setting
"Midnight=End".

51.10.6 All abstract values of the TIME type have settings for the Basic time property (this is not true for other time
properties). In order to prevent misleading notation in which a "PropertyAndSettingPair" has no effect on the resulting
set of abstract values, some restrictions are placed on the "PropertyName"s that can be used with a specific setting of
the Basic time property. The restrictions are listed in Table 13.
     NOTE – Table 13 is not an exhaustive set of rules for preventing the use of "PropertyAndSetting" pairs, some of which are
     redundant (which is not in general illegal).

                     Table 13 – Restrictions on use of property names with Basic property settings
                 Basic property setting           Prohibited property names with this Basic property setting
                Date                          Time, Local-or-UTC, Midnight, Interval-type,
                                              SE-point, Recurrence
                Time                          Date, Year, Interval-type, SE-point, Recurrence
                Date-Time                     Interval-type, SE-point, Recurrence
                Interval                      Recurrence
                Rec-Interval                  No restriction


94           Rec. ITU-T X.680 (02/2021)
                                                                                                        ISO/IEC 8824-1:2021 (E)

51.11     Duration range
51.11.1 The "DurationRange" subtype notation shall be:
          DurationRange ::= ValueRange
51.11.2 Both the "Value"s in the "ValueRange" shall identify a time abstract value (either by value notation or by a
value reference) that is present in the subtype:
          TIME(SETTINGS "Basic=Interval Interval-type=D")

51.11.3 Both the "Value"s in the "ValueRange" shall specify the duration using either:
          a)   the same single time component to the same accuracy (no fractional part, or the same number of digits in
               the fractional part); or
          b)   multiple time components that have identical values apart from the least significant time component
               (which may have different values, but shall have the same accuracy).
51.11.4 The selected duration abstract values are those that:
          a)   have the same values for the identical time components of the two "Value"s in the "ValueRange"; and
          b)   are within the specified range for the least significant time component of the two "Value"s in the
               "ValueRange"; and
          c)    have the same accuracy as the least significant time component of the two "Value"s in the
               "ValueRange".
   NOTE – This provides an alternative to the use of inner subtyping (see 38.4.4) as a means of specifying a duration that uses only
   a single time component to a specified accuracy.

EXAMPLE: TIME("PT2M0.000S".."PT2M59.000S") defines a TIME subtype that consists only of abstract values
representing durations of 2 minutes and zero to 59 seconds, to an accuracy of one millisecond.

51.12     Time point range
51.12.1 The "TimePointRange" notation shall be:
          TimePointRange ::= ValueRange
51.12.2 Both the "Value"s in the "ValueRange" shall identify a time abstract value (either value notation or a value
reference) that is present in the subtype:
TIME ( (SETTINGS "Basic=Date")
         |(SETTINGS "Basic=Time")
         |(SETTINGS "Basic=Date-Time") )

51.12.3 The two "Value"s in the "ValueRange" shall have identical settings for all time properties except the
Midnight time property.

51.12.4 If the two "Value"s in the "ValueRange" have the property setting "Local-or-UTC=LD" then the time
difference in the two "Value"s shall be the same.
   NOTE – This allows subtyping using, for example:
          TIME ("00:00".."09:00")
    or:
          TIME ("21:00".."24:00").

51.12.5 This subtype notation selects from the parent type those abstract values that have identical settings for all time
properties (except the Midnight time property) to those of the "Value"s in the "ValueRange" (and the same time
difference, if there is a property setting of Local-or-UTC=LD in the "Value"s), and that have values within the
specified "ValueRange" (see 51.4).
   NOTE – The requirement for all relevant abstract values to have identical settings for all time properties (except the Midnight
   time property), and that if they have a time differential it is the same time differential, ensures that they are all using the same
   time scale, and hence that an order relationship exists among them.


51.13     Recurrence range
51.13.1 The "RecurrenceRange" notation shall be:
          RecurrenceRange ::= ValueRange
51.13.2 Both the "Value"s in the "ValueRange" shall be integer values.


                                                                                      Rec. ITU-T X.680 (02/2021)                   95
ISO/IEC 8824-1:2021 (E)

51.13.3 For the purposes of ordering only, a time value with a property setting of "Recurrence=Unlimited" shall
be treated as specifying an infinite number of repetitions (an integer value of MAX).
51.13.4 This subtype notation selects from the parent type those abstract values that are also present in the subtype:
           TIME(SETTINGS "Basic=Rec-interval")

and that have a number of recurrence digits that is within the specified "ValueRange" (see 51.4).


52         The extension marker
     NOTE – Like the constraint notation in general, the extension marker has no effect on some encoding rules of ASN.1, such as the
     Basic Encoding Rules, but does on others, such as the Packed Encoding Rules. Its effect on encodings defined using ECN is
     determined by the ECN specification.

52.1     The extension marker, ellipsis, is an indication that extension additions are expected. It makes no statement as
to how such additions should be handled other than that they shall not be treated as an error during the decoding
process.
52.2       The joint use of the extension marker and an exception identifier (see clause 53) is both an indication that
extension additions are expected and also provides a means for identifying the action to be taken by the application if
there is a constraint violation. It is recommended that this notation be used in those situations where store and forward
or any other form of relaying is in use, so as to indicate (for example) that any unrecognized extension additions are to
be returned to the application for possible re-encoding and relaying.
52.3      The result of set arithmetic involving subtype constraints, value sets or information object sets that are
extensible is specified in clause 50.
52.4     If a type defined with an extensible constraint is referenced in a "ContainedSubtype", the newly defined type
does not inherit the extension marker or any of its extension additions (see 51.3.3). The newly defined type can be
made extensible by including an extension marker at the outermost level in its "ElementSetSpecs" (see also 50.4). For
example:
           A ::= INTEGER (0..10, ..., 12) -- A is extensible.
           B ::= INTEGER (A)               -- B is inextensible and is constrained to 0-10.
           C ::= INTEGER (A, …)            -- C is extensible and is constrained to 0-10.

52.5     If a type defined with an extensible constraint is further constrained with an "ElementSetSpecs", the resulting
type does not inherit the extension marker nor any extension additions that may be present in the former constraint (see
50.11). For example:
           A ::= INTEGER (0..10, ...)   -- A is extensible.
           B ::= A (2..5)           -- B is inextensible.
           C ::= A                  -- C is extensible.

52.6     Components of a set, sequence or choice type that are constrained to be absent shall not be present, regardless
of whether the set, sequence or choice type is an extensible type.
           NOTE – Inner type constraints have no effect on extensibility.

For example:
           A ::= SEQUENCE {
                   a INTEGER
                   b BOOLEAN OPTIONAL,
                   ...
                   }
           B ::= A (WITH COMPONENTS {b ABSENT})
                            -- B is extensible, but 'b' shall not be
                            -- present in any of its values.

52.7      Where this Recommendation | International Standard requires distinct tags (see 25.6 to 25.7, 27.3 and 29.3),
the following transformation shall conceptually be applied before performing the check for tag uniqueness:
52.7.1 A new element or alternative (called the conceptually-added element, see 52.7.2) is conceptually added at the
extension insertion point if:
           a)    there are no extension markers but extensibility is implied in the module header, and then an extension
                 marker is added and the new element is added as the first addition after that extension marker; or




96           Rec. ITU-T X.680 (02/2021)
                                                                                                        ISO/IEC 8824-1:2021 (E)

           b)   there is a single extension marker in a CHOICE or SEQUENCE or SET, and then the new element is added
                at the end of the CHOICE or SEQUENCE or SET immediately prior to the closing brace; or
           c)   there are two extension markers in a CHOICE or SEQUENCE or SET, and then the new element is added
                immediately before the second extension marker.
52.7.2 This conceptually-added element is solely for the purposes of checking legality through the application of
rules requiring distinct tags (see 25.6 to 25.7, 27.3 and 29.3). It is conceptually-added after the application of automatic
tagging (if applicable) and the expansion of COMPONENTS OF.
52.7.3 The conceptually-added element is defined to have a tag which is distinct from the tag of all normal ASN.1
types, but which matches the tag of all such conceptually-added elements and matches the indeterminate tag of the
open type, as specified in Rec. ITU-T X.681 | ISO/IEC 8824-2, 14.2, Note 2.
    NOTE – The rules concerning tag uniqueness relating to the conceptually added element and to the open type, together with the
    rules requiring distinct tags (see 25.6 to 25.7, 27.3 and 29.3) are necessary and sufficient to ensure that:
        a)    any unknown extension addition can be unambiguously attributed to a single insertion point when a BER encoding is
              decoded; and
        b)    unknown extension additions can never be confused with OPTIONAL elements.
    In PER the above rules are sufficient but are not necessary to ensure these properties. They are nonetheless imposed as rules
    of ASN.1 to ensure independence of the notation from encoding rules.

52.7.4 If, with these conceptually-added elements, the rules requiring distinct types are violated, then the
specification has made illegal use of the extensibility notation.
    NOTE – The purpose of the above rules is to make precise restrictions arising from the use of insertion points (particularly those
    which are not at the end of SEQUENCEs or SETs or CHOICEs). The restrictions are designed to ensure that in BER, DER and CER
    it is possible to attribute an unknown element received by a version 1 system unambiguously to a specific insertion point. This
    would be important if the exception handling of such added elements was different for different insertion points.

52.8       Examples
52.8.1     Example 1
           A ::= SET {
           a    A,
           b    CHOICE {
                c   C,
                d   D,
                ...
           }
}

is legal, for there is no ambiguity as any added material must be part of b.
52.8.2     Example 2
           A ::= SET {
           a     A,
           b     CHOICE {
                 c   C,
                 d   D,
                 ...
           },
           ... ,
           d     D
}

is illegal, for added material may be part of b, or may be at the outer level of A, and a version 1 system cannot tell
which.
52.8.3     Example 3
           A ::= SET {
           a    A,
           b    CHOICE {
                c   C,
                ...
           },
           d    CHOICE {
                e   E,
                ...
           }


                                                                                      Rec. ITU-T X.680 (02/2021)                  97
ISO/IEC 8824-1:2021 (E)

}

is also illegal, for added material may be part of b or d.
52.8.4 More complex examples can be constructed, with extensible choices inside extensible choices, or extensible
choices within elements of a sequence marked OPTIONAL or DEFAULT, but the above rules are necessary and sufficient
to ensure that an element not present in version 1 can be unambiguously attributed by a version 1 system to precisely
one insertion point.


53        The exception identifier
53.1      In a complex ASN.1 specification, there are a number of places where it is specifically recognized that
decoders have to handle material that is not completely specified in it. These cases arise in particular from use of a
constraint that is defined using a parameter of the abstract syntax (see Rec. ITU-T X.683 | ISO/IEC 8824-4, clause 10).
53.2      In such cases, the application designer needs to identify the actions to be taken when some implementation-
dependent constraint is violated. The exception identifier is provided as an unambiguous means of referring to parts of
an ASN.1 specification in order to indicate the actions to be taken. The identifier consists of a "!" character, followed
by an optional ASN.1 type and a value of that type. In the absence of the type, INTEGER is assumed as the type of the
value.
53.3      If an "ExceptionSpec" is present, it indicates that there is text in the body of the standard saying how to handle
the constraint violation associated with the "!" character. If it is absent, then the implementers will either need to
identify text that describes the action that they are to take, or will take implementation-dependent action when a
constraint violation occurs.
53.4      The "ExceptionSpec" notation is defined as follows:
               ExceptionSpec ::= "!" ExceptionIdentification | empty
               ExceptionIdentification ::=
                   SignedNumber
               |   DefinedValue
               |   Type ":" Value
The first two alternatives denote exception identifiers of type integer. The third alternative denotes an exception
identifier ("Value") of arbitrary type ("Type").
53.5     Where a type is constrained by multiple constraints, more than one of which has an exception identifier, the
exception identifier in the outermost constraint shall be regarded as the exception identifier for that type.
53.6     Where an exception marker is present on types that are used in set arithmetic, the exception identifier is
ignored and is not inherited by the type being constrained as a result of the set arithmetic.


54        Encoding control sections
54.1      The "EncodingControlSections" is specified by the following productions:
          EncodingControlSections ::=
                  EncodingControlSection EncodingControlSections
                  |empty
          EncodingControlSection ::=
               ENCODING-CONTROL
               encodingreference
               EncodingInstructionAssignmentList
54.2      Each "EncodingControlSection" within an ASN.1 module shall have a different "encodingreference", and
assigns encoding instructions for that encoding reference to one or more types in the module.
54.3      The "encodingreference" shall not be TAG.
54.4     The "EncodingInstructionAssignmentList" production and the associated semantics is specified in the
Recommendation | International Standard identified by the "encodingreference" (see Annex E) and can consist of any
sequence of ASN.1 lexical items (including comment, cstring and white-space) except the lexical items END and
ENCODING-CONTROL, which will not appear in an "EncodingInstructionAssignmentList".




98         Rec. ITU-T X.680 (02/2021)
                                                                                                  ISO/IEC 8824-1:2021 (E)

   NOTE 1 – Future versions of this Recommendation | International Standard may add further encoding references to Annex E. It
   is recommended that ASN.1 tools provide (only) warnings if the "encodingreference" in an "EncodingControlSection" is not one
   of those specified in Annex E and then ignore the "EncodingControlSection" until the next occurrence of END or
   ENCODING-CONTROL, whichever comes first.
   NOTE 2 – The "encodingreference" in an "EncodingControlSection" cannot be omitted. The default encoding reference for the
   module has no effect on an "EncodingControlSection".

54.5       There are interactions and restrictions on the assignment of encoding instructions (with the same encoding
reference) to a type using a type prefix and using an "EncodingControlSection". It is always possible (as a matter of
style) to use only "EncodingControlSection"s, but there are in general some encoding instructions (particularly those
that apply to all types in a module) that can only be assigned in an "EncodingControlSection". There are also
restrictions on the types to which particular instructions or combinations of instructions can be applied. These
interactions and restrictions are specified in the Recommendation | International Standard associated with the encoding
reference (see Annex E), and are not specified in this Recommendation | International Standard.




                                                                                 Rec. ITU-T X.680 (02/2021)                 99
ISO/IEC 8824-1:2021 (E)


                                                          Annex A

                                              ASN.1 regular expressions

                  (This annex forms an integral part of this Recommendation | International Standard.)

A.1       Definition
A.1.1     An ASN.1 regular expression is a pattern that describes a set of strings whose format conforms to this pattern.
A regular expression is itself a string; it is constructed analogously to arithmetic expressions, by using various operators
to combine smaller expressions. The smallest expressions, which are (usually) made of one or two characters, are
placeholders that stand for a set of characters.
The regular expressions presented here are very similar to those of scripting languages like Perl and to those of XML
Schema, where some other examples of use can be found.
A.1.2     Most characters, including all letters and digits, are regular expressions that match themselves.
EXAMPLE
          The regular expression "fred" matches only the string "fred".
A.1.3    Two regular expressions may be concatenated; the resulting regular expression matches any string formed by
concatenating two substrings that respectively match the concatenated subexpressions.

A.2       Metacharacters
A.2.1    A metacharacter sequence (or metacharacter) is a set of one or more contiguous characters that have a special
meaning in the context of a regular expression. The following list contains all of the metacharacter sequences. Their
meaning is explained in the following clauses.
          [ ]                        Match any character in the set where ranges are denoted by "-".
                                     A "^" after the opening bracket complements the set which follows it.
          {g,p,r,c}                  Quadruple which identifies a character of ISO/IEC 10646 (see 41.8)
          \N{name}                   Match the named character (or any character of the named character set) A.2.4
          .                          Match any character (unless it is one of the newline characters defined in 12.1.6)
          \d                         Match any digit (equivalent to "[0-9]")
          \w                         Match any alphanumeric character (equivalent to "[a-zA-Z0-9]")
          \t                         Match the HORIZONTAL TABULATION (9) character (see 12.1.6)
          \n                         Match any one of the newline characters defined in 12.1.6
          \r                         Match the CARRIAGE RETURN (13) character (see 12.1.6)
          \s                         Match any one of the white-space characters (see 12.1.6)
          \b                         Match a word boundary
          \               (prefix)   Quote the next metacharacter and cause it to be interpreted literally
          \\                         Match the REVERSE SOLIDUS (92) character "\"
          ""                         Match the QUOTATION MARK (34) character (")
          |               (infix)    Alternative between two expressions
          ( )                        Grouping of the enclosed expression
          *              (postfix)   Match the previous expression zero, one or several times
          +              (postfix)   Match the previous expression one or several times
          ?              (postfix)   Match the previous expression once or not at all
          #n             (postfix)   Match the previous expression exactly n times (where n is a single digit)
          #(n)           (postfix)   Match the previous expression exactly n times
          #(n,)          (postfix)   Match the previous expression at least n times
          #(n,m)         (postfix)   Match the previous expression at least n but not more than m times
          #(,m)          (postfix)   Match the previous expression not more than m times
   NOTE 1 – The characters CIRCUMFLEX ACCENT (94) "^" and HYPHEN-MINUS (45) "-" are additional metacharacters in
   certain positions of the string defined in A.2.2.
   NOTE 2 – The value in round brackets after a character name in this annex is the decimal value of the character in ISO/IEC
   10646.



100        Rec. ITU-T X.680 (02/2021)
                                                                                                         ISO/IEC 8824-1:2021 (E)

   NOTE 3 – This notation does not provide the metacharacters "^" and "$" to match the beginning and the end of a string
   respectively. Hence a string shall match a regular expression in its entirety except if the latter includes ".*" at its beginning, at
   its end or at both sides.
   NOTE 4 – The following metacharacter sequences cannot contain white-space (see 12.1.6) unless the white-space appears
   immediately prior to or following a newline:
          {g,p,r,c}
          \N{name}
          #n
          #(n)
          #(n,)
          #(n,m)
          #(,m)
   If a regular expression contains a newline, any spacing characters that appear immediately prior to or following the newline have
   no significance and match nothing (see 12.14.1).

A.2.2       A list of characters enclosed by "[" and "]" matches any single character in that list. If the first character of
the list is the caret "^", then it matches any character which is not in the list. A range of characters may be specified by
giving the first and last characters, separated by a hyphen (according to the order relation defined in 43.3). All
metacharacter sequences, except "]" and "\", lose their special meaning inside a list. To include a literal
CIRCUMFLEX ACCENT (94) "^", place it anywhere except in the first position or precede it with a backslash. To
include a literal HYPHEN-MINUS (45) "-", place it first or last in the list, or precede it with a backslash. To include a
literal CLOSING SQUARE BRACKET (93) "]", place it first. If the first character in the list is the caret "^", then the
characters "-" and "]" also match themselves when they immediately follow that caret. The metacharacter sequences
defined in A.2.3, A.2.4, A.2.6 and A.2.7 can be used between the square brackets where they keep their meaning.
EXAMPLES
          The regular expression "[0123456789]", or equivalently "[0-9]", matches any single digit.
          The regular expression "[^0]" matches any single character except 0.
          The regular expression "[\d^.-]" matches any single digit, a caret, a hyphen or a period.
A.2.3    To avoid any ambiguity between two ISO/IEC 10646 characters which have the same glyph, two notations
are provided. A notation of the form "{group,plane,row,cell}" references a (single) character according to the
"Quadruple" production defined in 41.8.
A.2.4     A notation of the form "\N{valuereference}" matches the referenced character if "valuereference" is a
reference to a restricted character string value of size 1 (see clause 41) which is defined or imported in the current
module. A notation of the form "\N{typereference}" matches any character of the referenced character set if
"typereference" is a reference to a subtype of a "RestrictedCharacterStringType" which is defined in the current module,
or is one of the "RestrictedCharacterStringType"s defined in clause 41.                     The regular expressions
"\N{LetterUppercase}" and "\N{Lu}" match any (single) character of the general category "Letter, uppercase"
(abbreviated as "Lu") as defined by The Unicode Standard.
   NOTE – In particular, "valuereference" or "typereference" can be one of the references defined in the module
   ASN1-CHARACTER-MODULE (see 42.1) and imported into the current module (see 41.8).

EXAMPLES
          The regular expression "\N{greekCapitalLetterSigma}" matches GREEK CAPITAL LETTER SIGMA.
          The regular expression "\N{BasicLatin}" matches any (single) character of the BASIC LATIN character
          set.
          "[\N{BasicLatin}\N{Cyrillic}\N{BasicGreek}]+",         or    equivalently    "(\N{BasicLatin} |
          \N{Cyrillic} | \N{BasicGreek})+", are regular expressions that match a string made of any (non null)
          number of characters from the three character sets specified.
A.2.5     The period "." matches any single character, unless it is one of the newline characters defined in 12.1.6.
A.2.6     The symbol "\d" is a synonym for "[0-9]", i.e., it matches any single digit. The symbol "\t" matches the
HORIZONTAL TABULATION (9) character. The symbol "\w" is a synonym for "[a-zA-Z0-9]", i.e., it matches any
single (lower-case or upper-case) character or any single digit.




                                                                                      Rec. ITU-T X.680 (02/2021)                   101
ISO/IEC 8824-1:2021 (E)

EXAMPLE
          The regular expression "\w+(\s\w+)*\." matches a sentence made of at least one (alphanumeric) word.
          The words are separated by one white-space character as defined in 12.1.6. There is no white-space character
          before the ending period.
A.2.7    The symbol "\r" matches the CARRIAGE RETURN (13) character. The symbol "\n" matches any one of
the newline characters defined in 12.1.6. The symbol "\s" matches any one of the white-space characters defined in
12.1.6. The symbol "\b" matches the empty string at the beginning or at the end of a word.
EXAMPLE
          The regular expression ".*\bfred\b.*" matches any string which includes the word "fred" (this word is
          not only a series of four characters; it is delimited). Hence it matches strings like "fred" or "I am fred
          the first", but not strings like "My name is freddy" or "I am afred I don’t know how to
          spell ‘afraid’!".

A.2.8     A character that normally functions as a metacharacter can be interpreted literally by prefixing it with a "\".
If the regular expression includes a QUOTATION MARK (34), this character shall be represented by a pair of
QUOTATION MARK characters.
EXAMPLES
          The regular expression "\." matches the (single) string ".", but not any string of any single character.
          The regular expression """" matches the string which contains a single QUOTATION MARK.
          The regular expression "\)" matches the string ")".
          The regular expression "\a" matches the character "a".
   NOTE – The fourth example shows that the backslash is allowed to precede characters that are not metacharacters, but this use is
   deprecated (because other metacharacters could be allowed in future versions of this Recommendation | International Standard).

A.2.9    Two or more regular expressions may be joined by the infix operator "|". The resulting regular expression
matches any string matching either subexpression.
A.2.10 A regular expression that does not end with a repetition operator may be followed by a repetition operator. If
the operator is "?", the preceding item is optional and matched at most once. If the operator is "*", the preceding item
will be matched zero or more times. If the operator is "+", the preceding item will be matched one or more times. If the
operator is of the form "#(n)", the preceding item is matched exactly n times; in this particular case, the parentheses
can be omitted if n consists of one digit. If it is of the form "#(n,)", the item is matched n or more times. If it is of the
form "#(,m)", the item is optional and is matched at most m times. Finally, if it is of the form " #(n,m)", the item is
matched at least n times, but not more than m times.
   NOTE – It is illegal to use the metacharacters "*", "+", "?" or "#" as the first character of a regular expression or immediately
   after a repetition operator. It is also illegal to use the metacharacters "#" or "|" as the last character of a regular expression.

EXAMPLES
          A phone number like "555-1212" is matched by the regular expression "\d#3-\d#4", or equivalently
          "\d#(3)-\d#(4)".

          A price in dollars like "$12345.90" is matched by the regular expression "$\d#(1,)(\.\d#(1,2))?".
          Note that parentheses are requested after the "#" symbol when it is followed by a range.
          A social security number like "123-45-5678" is matched by the regular expression "\d#3-?\d#2-?\d#4".
A.2.11 Repetition (see A.2.10) takes precedence over concatenation (see A.1.3), which in turn takes precedence over
alternation (see A.2.9). A whole subexpression may be enclosed in parentheses to override these precedence rules.
A.2.12 When a regular expression contains subexpressions in parentheses, each (non-quoted) opening parenthesis is
successively assigned a distinct (strictly positive) integer from the left to the right of the regular expression. Each
subexpression can then be referenced inside a comment with a notation like "\1", "\2" which uses the associated
integer. The empty subexpression "()" is not permitted.




102        Rec. ITU-T X.680 (02/2021)
                                                                                                  ISO/IEC 8824-1:2021 (E)

EXAMPLE
        "((\d#2)(\d#2)(\d#4))" -- \1 is a date in which \2 is the month, \3 the day
                        -- and \4 the year.
  NOTE – There is a requirement for formal reference to subexpressions of a regular expression for many purposes. One such
  instance is the need to write text to document the regular expression within the ASN.1 module. This is a notation which can be
  used to provide such references. This notation is not used elsewhere in this Recommendation | International Standard.




                                                                                 Rec. ITU-T X.680 (02/2021)                103
ISO/IEC 8824-1:2021 (E)


                                                       Annex B

                                              The defined time types

                  (This annex forms an integral part of this Recommendation | International Standard.)

B.1       General
B.1.1     This annex contains an ASN.1 module that specifies the defined time types. These types can be imported into
an ASN.1 specification and used in that specification, or can be used as a model for the definition of additional time
types. They cannot be used without importation.
B.1.2     In some cases, the defined time types are only useful if subtyped with one of the date or time-of-day subsets
(or both) specified in this module. Where this is the case, it is clearly stated in the definition of the type.
EXAMPLE: Use
APPLICATION-DATE-TIME ::= DATE-TIME(YEAR-MONTH-DAY-SUBSET)(SECONDS-SUBSET)

to define a date-time that is a year, month, day, hours, minutes, seconds. To use this, the type and the two subtypes have
to be imported.

B.2       The ASN.1 defined time types module
DefinedTimeTypes {joint-iso-itu-t asn1(1) specification(0) modules(0) defined-types-
module(3)}
DEFINITIONS AUTOMATIC TAGS ::= BEGIN
EXPORTS ALL;
-- Date types
CENTURY ::= TIME((SETTINGS "Basic=Date Date=C Year=Basic")|
              (SETTINGS "Basic=Date Date=C Year=Proleptic"))
ANY-CENTURY ::= TIME((SETTINGS "Basic=Date Date=C Year=Negative")|
                  (SETTINGS "Basic=Date Date=C Year=L5"))
               -- This allows only a 3-digit century if positive.
               -- A type with a greater number of digits can be
               -- defined as an additional time type.
               -- Note that L5 is used for century if the specification
               -- of the year would require 5 digits. See Table 6.
YEAR ::= TIME((SETTINGS "Basic=Date Date=Y Year=Basic")|
            (SETTINGS "Basic=Date Date=Y Year=Proleptic"))
ANY-YEAR ::= TIME((SETTINGS "Basic=Date Date=Y Year=Negative")|
              (SETTINGS "Basic=Date Date=Y Year=L5"))
               -- This allows only a 5-digit year if positive.
               -- A type with a greater number of digits can be
               -- defined as an additional time type.
YEAR-MONTH ::= TIME((SETTINGS "Basic=Date Date=YM Year=Basic")|
                (SETTINGS "Basic=Date Date=YM Year=Proleptic"))
ANY-YEAR-MONTH ::= TIME((SETTINGS "Basic=Date Date=YM Year=Negative")|
                    (SETTINGS "Basic=Date Date=YM Year=L5"))
               -- This allows only a 5-digit year if positive.
               -- A type with a greater number of digits can be
               -- defined as an additional time type.
YEAR-MONTH-DAY ::= TIME((SETTINGS "Basic=Date Date=YMD Year=Basic")|
                  (SETTINGS "Basic=Date Date=YMD Year=Proleptic"))
ANY-YEAR-MONTH-DAY ::= TIME((SETTINGS "Basic=Date Date=YMD Year=Negative")|
                       (SETTINGS "Basic=Date Date=YMD Year=L5"))
               -- This allows only a 5-digit year if positive.
               -- A type with a greater number of digits can be
               -- defined as an additional time type.




104        Rec. ITU-T X.680 (02/2021)
                                                                        ISO/IEC 8824-1:2021 (E)
YEAR-WEEK ::= TIME((SETTINGS "Basic=Date Date=YW Year=Basic")|
                (SETTINGS "Basic=Date Date=YW Year=Proleptic"))
ANY-YEAR-WEEK ::= TIME((SETTINGS "Basic=Date Date=YW Year=Negative")|
                   (SETTINGS "Basic=Date Date=YW Year=L5"))
               -- This allows only a 5-digit year if positive.
               -- A type with a greater number of digits can be
               -- defined as an additional time type.
YEAR-WEEK-DAY ::= TIME((SETTINGS "Basic=Date Date=YWD Year=Basic")|
                 (SETTINGS "Basic=Date Date=YWD Year=Proleptic"))
ANY-YEAR-WEEK-DAY ::= TIME((SETTINGS "Basic=Date Date=YWD Year=Negative")|
                      (SETTINGS "Basic=Date Date=YWD Year=L5"))
               -- This allows only a 5-digit year if positive.
               -- A type with a greater number of digits can be
               -- defined as an additional time type.
-- Types related to time-of-day
HOURS ::= TIME(SETTINGS "Basic=Time Time=H Local-or-UTC=L")
HOURS-UTC ::= TIME(SETTINGS "Basic=Time Time=H Local-or-UTC=Z")
HOURS-AND-DIFF ::= TIME(SETTINGS "Basic=Time Time=H Local-or-UTC=LD")
MINUTES ::= TIME(SETTINGS "Basic=Time Time=HM Local-or-UTC=L")
MINUTES-UTC ::= TIME(SETTINGS "Basic=Time Time=HM Local-or-UTC=Z")
MINUTES-AND-DIFF ::= TIME(SETTINGS "Basic=Time Time=HM Local-or-UTC=LD")
SECONDS ::= TIME(SETTINGS "Basic=Time Time=HMS Local-or-UTC=L")
SECONDS-UTC ::= TIME(SETTINGS "Basic=Time Time=HMS Local-or-UTC=Z")
SECONDS-AND-DIFF ::= TIME(SETTINGS "Basic=Time Time=HMS Local-or-UTC=LD")
HOURS-AND-FRACTION ::= TIME(SETTINGS "Basic=Time Time=HF3 Local-or-UTC=L")
             -- 3 digit fraction
HOURS-UTC-AND-FRACTION ::= TIME(SETTINGS "Basic=Time Time=HF3 Local-or-UTC=Z")
                 -- 3-digit fraction
HOURS-AND-DIFF-AND-FRACTION ::= TIME(SETTINGS "Basic=Time Time=HF3
                   Local-or-UTC=LD")
                   -- 3-digit fraction
MINUTES-AND-FRACTION ::= TIME(SETTINGS "Basic=Time Time=HMF3 Local-or-UTC=L")
                -- 3-digit fraction
MINUTES-UTC-AND-FRACTION ::= TIME(SETTINGS "Basic=Time Time=HMF3 Local-or-UTC=Z")
                 -- 3-digit fraction
MINUTES-AND-DIFF-AND-FRACTION ::= TIME(SETTINGS "Basic=Time Time=HMF3
                    Local-or-UTC=LD")
                   -- 3-digit fraction
SECONDS-AND-FRACTION ::= TIME(SETTINGS "Basic=Time Time=HMSF3 Local-or-UTC=L")
                                       -- 3-digit fraction
SECONDS-UTC-AND-FRACTION ::= TIME(SETTINGS "Basic=Time Time=HMSF3 Local-or-UTC=Z")
                                           -- 3-digit fraction
SECONDS-AND-DIFF-AND-FRACTION ::= TIME(SETTINGS "Basic=Time Time=HMSF3
                    Local-or-UTC=LD")
                    -- 3-digit fraction
-- Interval types (DURATION is not included as this is a useful type).
START-END-DATE-INTERVAL ::= TIME(SETTINGS "Basic=Interval Interval-type=SE
                         SE-point=Date")
     -- This is only useful if subtyped with a DATE subset (see below).
START-END-TIME-INTERVAL ::= TIME(SETTINGS "Basic=Interval Interval-type=SE
                         SE-point=Time")
     -- This is only useful if subtyped with a TIME-OF-DAY subset
     -- (see below).



                                                          Rec. ITU-T X.680 (02/2021)       105
ISO/IEC 8824-1:2021 (E)
START-END-DATE-TIME-INTERVAL ::= TIME(SETTINGS "Basic=Interval Interval-type=SE
                         SE-point=Date-Time")
     -- This is only useful if subtyped with a DATE subset and a
     -- TIME-OF-DAY subset (see below).
START-DATE-DURATION-INTERVAL ::= TIME(SETTINGS "Basic=Interval Interval-type=SD
                         SE-point=Date")
     -- This is only useful if subtyped with a DATE subset (see below).
START-TIME-DURATION-INTERVAL ::= TIME(SETTINGS "Basic=Interval Interval-type=SD
                         SE-point=Time")
     -- This is only useful if subtyped with a TIME-OF-DAY subset
     -- (see below).
START-DATE-TIME-DURATION-INTERVAL ::= TIME(SETTINGS "Basic=Interval
                                  Interval-type=SD
                                  SE-point=Date-Time")
     -- This is only useful if subtyped with a DATE subset and a
     -- TIME-OF-DAY subset (see below).

DURATION-END-DATE-INTERVAL ::= TIME(SETTINGS "Basic=Interval Interval-type=DE
                         SE-point=Date")
     -- This is only useful if subtyped with a DATE subset (see below).
DURATION-END-TIME-INTERVAL ::= TIME(SETTINGS "Basic=Interval Interval-type=DE
                         SE-point=Time")
     -- This is only useful if subtyped with a TIME-OF-DAY subset
     -- (see below).
DURATION-END-DATE-TIME-INTERVAL ::= TIME(SETTINGS "Basic=Interval Interval-type=DE
                         SE-point=Date-Time")
     -- This is only useful if subtyped with a DATE subset and a
     -- TIME-OF-DAY subset (see below).
-- Recurring interval types.
REC-START-END-DATE-INTERVAL ::= TIME(SETTINGS "Basic=Rec-Interval Interval-type=SE
                         SE-point=Date")
     -- This is only useful if subtyped with a DATE subset (see below).
REC-START-END-TIME-INTERVAL ::= TIME(SETTINGS "Basic=Rec-Interval Interval-type=SE
                         SE-point=Time")
     -- This is only useful if subtyped with a TIME-OF-DAY subset
     -- (see below).
REC-START-END-DATE-TIME-INTERVAL ::= TIME(SETTINGS "Basic=Rec-Interval
                                Interval-type=SE
                                SE-point=Date-Time")
     -- This is only useful if subtyped with a DATE subset and a
     -- TIME-OF-DAY subset (see below).
REC-DURATION-INTERVAL ::= TIME(SETTINGS "Basic=Rec-Interval Interval-type=D")
REC-START-DATE-DURATION-INTERVAL ::= TIME(SETTINGS "Basic=Rec-Interval
                                Interval-type=SD
                                SE-point=Date")
     -- This is only useful if subtyped with a DATE subset (see below).
REC-START-TIME-DURATION-INTERVAL ::= TIME(SETTINGS "Basic=Rec-Interval
                                Interval-type=SD
                                SE-point=Time")
     -- This is only useful if subtyped with a TIME-OF-DAY subset
     -- (see below).
REC-START-DATE-TIME-DURATION-INTERVAL ::= TIME(SETTINGS "Basic=Rec-Interval
                                Interval-type=SD
                                SE-point=Date-Time")
     -- This is only useful if subtyped with a DATE subset and a
     -- TIME-OF-DAY subset (see below).

REC-DURATION-END-DATE-INTERVAL ::= TIME(SETTINGS "Basic=Rec-Interval
                                Interval-type=DE
                                SE-point=Date")
     -- This is only useful if subtyped with a DATE subset (see below).


106      Rec. ITU-T X.680 (02/2021)
                                                                        ISO/IEC 8824-1:2021 (E)
REC-DURATION-END-TIME-INTERVAL ::= TIME(SETTINGS "Basic=Rec-Interval
                                Interval-type=DE
                                SE-point=Time")
     -- This is only useful if subtyped with a TIME-OF-DAY subset
     -- (see below).
REC-DURATION-END-DATE-TIME-INTERVAL ::= TIME(SETTINGS "Basic=Rec-Interval
                                Interval-type=DE
                                SE-point=Date-Time")
     -- This is only useful if subtyped with a DATE subset and a
     -- TIME-OF-DAY subset (see below).

-- Date subsets
CENTURY-SUBSET ::= TIME((SETTINGS "Date=C Year=Basic")|
                (SETTINGS "Date=C Year=Proleptic"))
ANY-CENTURY-SUBSET ::= TIME((SETTINGS "Date=C Year=Negative")|
                  (SETTINGS "Date=C Year=L5"))
YEAR-SUBSET ::= TIME((SETTINGS "Date=Y Year=Basic")|
              (SETTINGS "Date=Y Year=Proleptic"))
ANY-YEAR-SUBSET ::= TIME((SETTINGS "Date=Y Year=Negative")|
                (SETTINGS "Date=Y Year=L5"))
YEAR-MONTH-SUBSET ::= TIME((SETTINGS "Date=YM Year=Basic")|
               (SETTINGS "Date=YM Year=Proleptic"))
ANY-YEAR-MONTH-SUBSET ::= TIME((SETTINGS "Date=YM Year=Negative")|
                    (SETTINGS "Date=YM Year=L5"))
YEAR-MONTH-DAY-SUBSET ::= TIME((SETTINGS "Date=YMD Year=Basic")|
                    (SETTINGS "Date=YMD Year=Proleptic"))
ANY-YEAR-MONTH-DAY-SUBSET ::= TIME((SETTINGS "Date=YMD Year=Negative")|
                     (SETTINGS "Date=YMD Year=L5"))
YEAR-WEEK-SUBSET ::= TIME((SETTINGS "Date=YW Year=Basic")|
                  (SETTINGS "Date=YW Year=Proleptic"))
ANY-YEAR-WEEK-SUBSET ::= TIME((SETTINGS "Date=YW Year=Negative")|
                   (SETTINGS "Date=YW Year=L5"))
YEAR-WEEK-DAY-SUBSET ::= TIME((SETTINGS "Date=YWD Year=Basic")|
                   (SETTINGS "Date=YWD Year=Proleptic"))
ANY-YEAR-WEEK-DAY-SUBSET ::= TIME((SETTINGS "Date=YWD Year=Negative")|
                     (SETTINGS "Date=YWD Year=L5"))

-- Time subsets
HOURS-SUBSET ::= TIME(SETTINGS "Time=H Local-or-UTC=L")
HOURS-UTC-SUBSET ::= TIME(SETTINGS "Time=H Local-or-UTC=Z")
HOURS-AND-DIFF-SUBSET ::= TIME(SETTINGS "Time=H Local-or-UTC=LD")
MINUTES-SUBSET ::= TIME(SETTINGS "Time=HM Local-or-UTC=L")
MINUTES-UTC-SUBSET ::= TIME(SETTINGS "Time=HM Local-or-UTC=Z")
MINUTES-AND-DIFF-SUBSET ::= TIME(SETTINGS "Time=HM Local-or-UTC=LD")
SECONDS-SUBSET ::= TIME(SETTINGS "Time=HMS Local-or-UTC=L")
SECONDS-UTC-SUBSET ::= TIME(SETTINGS "Time=HMS Local-or-UTC=Z")
SECONDS-AND-DIFF-SUBSET ::= TIME(SETTINGS "Time=HMS Local-or-UTC=LD")
HOURS-AND-FRACTION-SUBSET ::= TIME(SETTINGS "Time=HF3 Local-or-UTC=L")
HOURS-UTC-AND-FRACTION-SUBSET ::= TIME(SETTINGS "Time=HF3
                                               Local-or-UTC=Z")
HOURS-AND-DIFF-AND-FRACTION-SUBSET ::= TIME(SETTINGS "Time=HF3
                       Local-or-UTC=LD")




                                                          Rec. ITU-T X.680 (02/2021)       107
ISO/IEC 8824-1:2021 (E)
MINUTES-AND-FRACTION-SUBSET ::= TIME(SETTINGS "Time=HMF3
                       Local-or-UTC=L")
MINUTES-UTC-AND-FRACTION-SUBSET ::= TIME(SETTINGS "Time=HMF3
                       Local-or-UTC=Z")
MINUTES-AND-DIFF-AND-FRACTION-SUBSET ::= TIME(SETTINGS "Time=HMF3
                       Local-or-UTC=LD")
SECONDS-AND-FRACTION-SUBSET ::= TIME(SETTINGS "Time=HMSF3
                       Local-or-UTC=L")
SECONDS-UTC-AND-FRACTION-SUBSET ::= TIME(SETTINGS "Time=HMSF3
                       Local-or-UTC=Z")
SECONDS-AND-DIFF-AND-FRACTION-SUBSET ::= TIME(SETTINGS "Time=HMSF3
                       Local-or-UTC=LD")
END




108      Rec. ITU-T X.680 (02/2021)
                                                                                                 ISO/IEC 8824-1:2021 (E)

                                                        Annex C

                                    Rules for type and value Compatibility
                   (This annex forms an integral part of this Recommendation | International Standard.)

This annex is expected to be mainly of use to tool builders to ensure that they interpret the language identically. It is
present in order to clearly specify what is legal ASN.1 and what is not, and to be able to specify the precise value that
any value reference name identifies, and the precise set of values that any type or value set reference name identifies. It
is not intended to provide a definition of valid transformations of ASN.1 notations for any purpose other than those
stated above.

C.1         The need for the value mapping concept (tutorial introduction)
C.1.1       Consider the following ASN.1 definitions:
A ::= INTEGER
B ::= [1] INTEGER
C ::= [2] INTEGER (0..6,...)
D ::= [2] INTEGER (0..6,...,7)
E ::= INTEGER (7..20)
F ::= INTEGER {red(0), white(1), blue(2), green(3), purple(4)}
a A ::= 3
b B ::= 4
c C ::= 5
d D ::= 6
e E ::= 7
f F ::= green

C.1.2     It is clear that the value references a, b, c, d, e, and f can be used in value notation governed by A, B, C, D, E,
and F, respectively. For example:
W ::= SEQUENCE {w1 A DEFAULT a}

and:
x A ::= a

and:
Y ::= A(1..a)

are all valid given the definitions in C.1.1. If, however, A above were replaced by B, or C, or D, or E, or F, would the
resulting statements be illegal? Similarly, if the value reference a above were replaced in each of these cases by b, or c,
or d, or e, or f, are the resulting statements legal?
C.1.3      A more sophisticated question would be to consider in each case replacement of the type reference by the
explicit text to the right of its assignment. Consider for example:
f INTEGER {red(0), white(1), blue(2), green(3), purple(4)} ::= green
W ::= SEQUENCE {
         w1 INTEGER {red(0), white(1), blue(2), green(3), purple(4)}
         DEFAULT f}
x INTEGER {red(0), white(1), blue(2), green(3), purple(4)} ::= f
Y ::= INTEGER {red(0), white(1), blue(2), green(3), purple(4)}(1..f)

Would the above be legal ASN.1?
C.1.4     Some of the above examples are cases which, even if legal (as most of them are – see later text), users would
be ill-advised to write similar text, as they are at the least obscure and at worst confusing. However, there are frequent
uses of a value reference to a value of some type (not necessarily just an INTEGER type) as the default value for that


                                                                                Rec. ITU-T X.680 (02/2021)              109
ISO/IEC 8824-1:2021 (E)

type with tagging or subtyping applied in the governor. The value mapping concept is introduced in order to provide a
clear and precise means of determining which constructs such as the above are legal.
C.1.5        Again, consider:
C ::= [2] INTEGER (0..6,...)
E ::= INTEGER (7..20)
F ::= INTEGER {red(0), white(1), blue(2), green(3), purple(4)}

In each case a new type is being created. For F we can clearly identify a 1-1 correspondence between the values in it
and the values in the universal type INTEGER. In the case of C and E, we can clearly identify a 1-1 correspondence
between the values in them and a subset of the values in the universal type INTEGER. We call this relationship a value
mapping between values in the two types. Moreover, because values in F, C, and E all have (1-1) mappings to values of
INTEGER, we can use these mappings to provide mappings between the values of F, C, and E themselves. This is
illustrated for F and C in Figure C.1.




                                             Figure C.1– Derived mappings


C.1.6        Now when we have a value reference such as:
c C ::= 5

to a value in C which is required in some context to identify a value in F, then, provided a value mapping exists between
that value in C and a (single) value in F, we can (and do) define c to be a legal reference to the value in F. This is
illustrated in Figure C.2, where the value reference c is used to identify a value in F, and can be used in place of a direct
reference f1 where we would otherwise have to define:
f1 F ::= 5




110           Rec. ITU-T X.680 (02/2021)
                                                                                                      ISO/IEC 8824-1:2021 (E)




                                        Figure C.2– Mappings for value references


C.1.7     It should be noted that in some cases there will be values in one type (7 to 20 in A of C.1.1 for example) that
have value mappings to values in another type (7 to 20 in E of C.1.1 for example), but other values (21 upwards of A)
that have no such mapping. A reference to such values in A would not provide a valid reference to a value in E. (In this
example, the whole of E has a value mapping to a subset of A. In the general case, there may be a subset of values in
both types that have mappings, with other values in both types that are unmapped.)
C.1.8     In the body of the ASN.1 standards, normal English text is used to specify legality in the above and similar
cases. Subclause C.6 gives the precise requirements for legality and should be referenced whenever there is doubt about
a complex construction.
   NOTE – The fact that value mappings are defined to exist between two occurrences of the "Type" construct permits the use of
   value references established using one "Type" construct to identify values in another "Type" construct which is sufficiently
   similar. It allows dummy and actual parameters to be typed using two textually separate "Type" constructs without violating the
   rules for compatibility of dummy and actual parameters. It also allows fields of information object classes to be specified using
   one "Type" construct and the corresponding value in an information object to be specified using a distinct "Type" construct
   which is sufficiently similar. (These examples are not intended to be exhaustive.) It is, however, recommended that advantage be
   taken of this freedom only for simple cases such as SEQUENCE OF INTEGER, or CHOICE {int INTEGER, id OBJECT
   IDENTIFIER}, and not for more complex "Type" constructs.


C.2       Value mappings
C.2.1    The underlying model is of types, as non-overlapping containers, that contain values, with every occurrence
of the ASN.1 "Type" construct defining a distinct new type (see Figures C.1 and C.2). This annex specifies when value
mappings exist between such types, enabling a reference to a value in one type to be used where a reference to a value
in some other type is needed.
EXAMPLE: Consider:
X ::= INTEGER
Y ::= INTEGER

X and Y are type reference names (pointers) to two distinct types, but value mappings exist between these types, so any
value reference to a value of X can be used when governed by Y (for example, following DEFAULT).
C.2.2      In the set of all possible ASN.1 values, a value mapping relates a pair of values. The whole set of value
mappings is a mathematical relation. This relation possesses the following properties: it is reflexive (each ASN.1 value
is related to itself), it is symmetric (if a value mapping is defined to exist from a value x1 to a value x2, then there
automatically exists a value mapping from x2 to x1), and it is transitive (if there is a value mapping from a value x1
to x2, and a value mapping from x2 to x3, then there automatically exists a value mapping from x1 to x3).
C.2.3     Furthermore, given any two types X1 and X2, seen as sets of values, the set of value mappings from values
in X1 to values in X2 is a one-to-one relation, that is, for all values x1 in X1, and x2 in X2, if there is a value mapping
from x1 to x2, then:


                                                                                    Rec. ITU-T X.680 (02/2021)                 111
ISO/IEC 8824-1:2021 (E)

          a)   there is no value mapping from x1 to another value in X2 different from x2; and
          b)   there is no value mapping from any value in X1 (other than x1) to x2.
C.2.4    Where a value mapping exists between a value x1 and a value x2, a value reference to either one can
automatically be used to reference the other if so required by some governing type.
   NOTE – The fact that value mappings are defined to exist between values in some "Type" constructs is solely for the purpose of
   providing flexibility in the use of the ASN.1 notation. The existence of such mappings carries no implications whatsoever that the
   two types carry the same application semantics, but it is recommended that ASN.1 constructs which would be illegal without
   value mappings are used only if the corresponding types do indeed carry the same application semantics. Note that value
   mappings will frequently exist in any large specification between two types that are identical ASN.1 constructs, but which carry
   totally different application semantics, and where the existence of these value mappings is never used in determining the legality
   of the total specification.


C.3       Identical type definitions
C.3.1      The concept of identical type definitions is used to enable value mappings to be defined between two
instances of "Type" which are either identical or sufficiently similar that one would normally expect their use to be
interchangeable. In order to give precision to the meaning of "sufficiently similar", this subclause specifies a series of
transformations which are applied to each of the instances of "Type" to produce a normal form for those instances of
"Type". The two instances of "Type" are defined to be identical type definitions if, and only if, their normal forms are
identical ordered lists of the same lexical items (see clause 12).
C.3.2    Each occurrence of "Type" in an ASN.1 specification is an ordered list of the lexical items defined in clause
12. The normal form is obtained by applying the transformations defined in C.3.2.1 to C.3.2.6 in that order.
C.3.2.1 All the comments (see 12.6) are removed.
C.3.2.2 The following transformations are not recursive and hence need only to be applied once, in any order:
          a)   For a type defined by a "ValueSetTypeAssignment", its definition is replaced by a "TypeAssignment"
               using the same "Type" and a subtype constraint which is the contents of the "ValueSet" as specified in
               16.6.
          b)   For each integer type: the "NamedNumberList" (see 19.1), if any, is reordered so that the "identifier"s are
               in alphabetical order ("a" first, "z" last).
          c)   For each enumerated type: numbers are added, as specified in 20.3, to any "EnumerationItem" (see 20.1)
               that is an "identifier" (without a number); then the "RootEnumeration" is reordered so that the
               "identifiers" are in alphabetical order ("a" first, "z" last).
          d)   For each bitstring type: the "NamedBitList" (see 22.1), if any, is reordered so that the "identifiers" are in
               alphabetical order ("a" first, "z" last).
          e)   For each object identifier value: each "ObjIdComponents" is transformed into its corresponding
               "NumberForm" in accordance with the semantics of clause 32 (see the example in 32.13).
          f)   For each relative object identifier value (see 33.3): each "RelativeOIDComponents" is transformed into
               its corresponding "NumberForm" in accordance with the semantics of clause 33.
          g)   For sequence types (see clause 25) and set types (see clause 27): any extension of the form
               "ExtensionAndException", "ExtensionAdditions", is cut and pasted to the end of the
               "ComponentTypeLists"; "OptionalExtensionMarker", if present, is removed.
               If "TagDefault" is IMPLICIT TAGS, the keyword IMPLICIT is added to all instances of "Tag" (see 31.2)
               unless either:
               •     it is already present; or
               •     the reserved word EXPLICIT is present; or
               •     the type being tagged is a CHOICE type or;
               •     it is an open type.
               If "TagDefault" is AUTOMATIC TAGS, the decision on whether to apply automatic tagging is taken
               according to 25.3 (the automatic tagging will be performed later on).
                   NOTE – Subclauses 25.4 and 27.2 specify that the presence of a "Tag" in a "ComponentType" which was
                   inserted as a result of the replacement of "Components of Type" does not in itself prevent the automatic tagging
                   transformation.
               If "ExtensionDefault" is EXTENSIBILITY                 IMPLIED, an ellipsis ("...") is added after the
               "ComponentTypeLists" if it is not present.



112        Rec. ITU-T X.680 (02/2021)
                                                                                                   ISO/IEC 8824-1:2021 (E)

          h)   For choice type (see clause 29): "RootAlternativeTypeList" is reordered so that the identifiers of the
               "NameType"s are in alphabetical order ("a" first, "z" last). "OptionalExtensionMarker", if present, is
               removed. If "TagDefault" is IMPLICIT TAGS, the keyword IMPLICIT is added to all instances of
               "Tags" (see 31.2) unless either:
               •    it is already present; or
               •    the reserved word EXPLICIT is present; or
               •    the type being tagged is a CHOICE type; or
               •    it is an open type.
               If "TagDefault" is AUTOMATIC TAGS, the decision on whether to apply automatic tagging is taken
               according to 29.5. If "ExtensionDefault" is EXTENSIBILITY IMPLIED, an ellipsis ("...") is added after
               the "AlternativeTypeLists" if it is not present.
C.3.2.3 The following transformations shall be applied recursively in the specified order, until a fix-point is reached:
          a)   For each object identifier value (see 32.3): if the value definition begins with a "DefinedValue", the
               "DefinedValue" is replaced by its definition.
          b)   For each relative object identifier value (see 33.3): if the value definition contains "DefinedValue"s, the
               "DefinedValue"s are replaced by their definition.
          c)   For sequence types and set types: all instances of           "COMPONENTS OF Type" (see clause 25) are
               transformed according to clauses 25 and 27.
          d)   For sequence, set and choice types: if it has earlier been decided to tag automatically (see C.3.2.2 g) and
               h)), the automatic tagging is applied according to clauses 25, 27 and 29.
          e)   For selection type: the construction is replaced by the selected alternative according to clause 30.
          f)   All type references are replaced by their definitions according to the following rules:
               •    If the replacing type is a reference to the type being transformed, the type reference is replaced by a
                    special item that matches no other item than itself.
               •    If the replacing type is a sequence-of type or a set-of type, the constraints following the replaced
                    type, if any, are moved in front of the keyword OF.
               •    If the replaced type is a parameterized type or a parameterized value set (see Rec. ITU-T X.683 |
                    ISO/IEC 8824-4, 8.2), every "DummyReference" is replaced by the corresponding
                    "ActualParameter".
          g)   All value references are replaced by their definitions; if the replaced value is a parameterized value (see
               Rec. ITU-T X.683 | ISO/IEC 8824-4, 8.2), every "DummyReference" is replaced by the corresponding
               "ActualParameter".
                   NOTE – Before replacing any value reference, the procedures of this annex shall be applied to ensure that the
                   value reference identifies, through value mappings or directly, a value in its governing type.

C.3.2.4 For set type: the "RootComponentTypeList" is reordered so that the "ComponentType"s are in alphabetical
order ("a" first, "z" last).
C.3.2.5 The following transformations shall be applied to value definitions:
          a)   If an integer value is defined with an identifier, that identifier is replaced by the associated number.
          b)   If a bitstring value is defined using identifiers, it is replaced by the corresponding "bstring" with all
               trailing zero bits removed.
          c)   All white-space immediately before and after each newline (including the newline) in a "cstring" is
               removed.
          d)   All white-space in "bstring" and "hstring" is removed.
          e)   Each real value defined with base 2 is normalized so that the mantissa is odd, and each real value defined
               with base 10 is normalized so that the last digit of the mantissa is not 0.
          f)   Each GeneralizedTime, UTCTime, TIME, TIME-OF-DAY, DATE, DATE-TIME, and DURATION value is
               replaced by a string which conforms to the rules used when encoding in DER and CER (see Rec. ITU-T
               X.690 | ISO/IEC 8825-1, 11.7, 11.8, and 11.9).
          g)   After   applying c), each UTF8String, NumericString, PrintableString, IA5String,
               VisibleString (ISO646String), BMPString and UniversalString value is replaced by the
               equivalent value of type UniversalString written using the "Quadruple" notation (see clause 41.8).



                                                                                  Rec. ITU-T X.680 (02/2021)               113
ISO/IEC 8824-1:2021 (E)

C.3.2.6 Any occurrence of "realnumber" shall be transformed to a "base" 10 associated "SequenceValue". Any
occurrence of the "RealValue" associated with "SequenceValue" shall be transformed to the associated
"SequenceValue" of the same "base", such that the last digit of the mantissa is not zero.
C.3.3     If two instances of "Type", when transformed to their normal form, are identical lists of lexical items (see
clause 12), then the two instances of "Type" are defined to be identical type definitions with the following exception: if
an "objectclassreference" (see Rec. ITU-T X.681 | ISO/IEC 8824-2, 7.1), an "objectreference" (see Rec. ITU-T X.681 |
ISO/IEC 8824-2, 7.2) or an "objectsetreference" (see Rec. ITU-T X.681 | ISO/IEC 8824-2, 7.3) appears within the
normalized form of the "Type", then the two types are not defined to be identical type definitions, and value mappings
(see C.4 below) will not exist between them.
   NOTE – This exception was inserted to avoid the need to provide transformation rules to normal form for elements of syntax
   concerned with information object class, information object, and information object set notation. Similarly, specification for the
   normalization of all value notation and of set arithmetic notation has not been included at this time. Should there prove to be a
   requirement for such specification, this could be provided in a future version of this Recommendation | International Standard.
   The concept of identical type definitions and of value mappings was introduced to ensure that simple ASN.1 constructs could be
   used either by using reference names or by copying text. It was felt unnecessary to provide this functionality for more complex
   instances of "Type" that included information object classes, etc.


C.4       Specification of value mappings
C.4.1    If two occurrences of "Type" are identical type definitions under the rules of C.3, then value mappings exist
between every value of one type and the corresponding value of the other type.
C.4.2     For a type, X1, created from any type, X2, by tagging (see 31.2), value mappings are defined to exist between
all the members of X1 and the corresponding members of X2.
   NOTE – Whilst value mappings are defined to exist between the values of X1 and X2 in C.4.2 above, and between the values
   of X3 and X4 in C.4.3, if such types are embedded in otherwise identical but distinct type definitions (such as SEQUENCE or
   CHOICE type definitions), the resulting type definitions (the SEQUENCE or CHOICE types) will not be identical type definitions,
   and there will be no value mappings between them.

C.4.3    For a type, X3, created by selecting values from any governing type, X4, by the element set construct or by
subtyping, value mappings are defined to exist between the members of the new type and those members of the
governing type that were selected by the element set or subtyping construct. The presence or absence of an extension
marker has no effect on this rule.
C.4.4     Additional value mappings are specified in C.5 between some of the character string types.
C.4.5    A value mapping is defined to exist between all the values of any type defined as an integer type with named
values and any integer type defined without named values, or with different named values, or with different names for
named values, or both.
   NOTE – The existence of the value mapping does not affect any scope rule requirements on the use of the names of named
   values. They can only be used in a scope governed by the type in which they are defined, or by a typereference name to that type.

C.4.6      A value mapping is defined to exist between all the values of any type defined as a bit string type with named
bits and any bit string type defined without named bits, or with different named bits, or with different names for named
bits, or both.
   NOTE – The existence of the value mapping does not affect any scope rule requirements on the use of the names of named bits.
   They can only be used in a scope governed by the type in which they are defined, or by a typereference name to that type.


C.5       Additional value mappings defined for the character string types
C.5.1     There are two groups of restricted character string types, group A (see C.5.2) and group B (see C.5.3). Value
mappings are defined to exist between all types in group A, and value references to values of these types can be used
when governed by one of the other types. For the types in group B, value mappings never exist between these different
types, nor between any type in group A and any type in group B.
C.5.2     Group A consists of:
          UTF8String
          NumericString
          PrintableString
          IA5String
          VisibleString (ISO646String)
          UniversalString
          BMPString




114        Rec. ITU-T X.680 (02/2021)
                                                                                              ISO/IEC 8824-1:2021 (E)

C.5.3        Group B consists of:
             TeletexString (T61String)
             VideotexString
             GraphicString
             GeneralString

C.5.4        The value mappings in group A are specified by mapping the character string values of each type to
UniversalString, then using the transitivity property of value mappings. To map values from one of the group A
types to UniversalString, the string is replaced by a UniversalString of the same length with each character
mapped as specified below.
C.5.5    Formally, the set of abstract values in UTF8String is the same set of abstract values that occur in
UniversalString but with a different tag (see 41.16), and each abstract value in UTF8String is defined to map to the
corresponding abstract value in UniversalString.
C.5.6  The glyphs (printed character shapes) for characters used to form the types NumericString and
PrintableString have recognizable and unambiguous mappings to a subset of the glyphs assigned to the first 128
characters of ISO/IEC 10646. The mapping for these types is defined using this mapping of glyphs.
C.5.7      IA5String and VisibleString are mapped into UniversalString by mapping each character into the
UniversalString character that has the identical (32-bit) value in the BER encoding of UniversalString as the (8-
bit) value of the BER encoding of IA5String and VisibleString.
C.5.8   BMPString is formally a subset of UniversalString, and corresponding abstract values have value
mappings.

C.6          Specific type and value compatibility requirements
This subclause uses the value mapping concept to provide precise text for the legality of certain ASN.1 constructs.
C.6.1     Any "Value" occurrence, x-notation, with a governing type, Y, identifies the value, y-val, in the governing
type Y that has a value mapping to the value x-val specified by x-notation. It is a requirement that such a value exists.
For example, consider the occurrence of x in the last line of the following:
X ::= [0] INTEGER (0..30)
x X ::= 29
Y ::= [1] INTEGER (25..35)
Z1 ::= Y (x | 30)

These ASN.1 constructs are legal, and in the last assignment the x-notation x is referencing the x-val 29 in X and,
through value mapping, identifies the y-val 29 in Y. The x-notation 30 is referencing the y-val 30 in Y, and Z1 is the set
of values 29 and 30. On the other hand, the assignment:
Z2 ::= Y (x | 20)

is illegal because there is no y-val to which the x-notation 20 can refer.
C.6.2     Any "Type" occurrence, t-notation, that has a governing type, V, identifies the complete set of values in the
root of the governing type V that have value mappings to any of the values in the root of the "Type" t-notation. This set
is required to contain at least one value.
For example, consider the occurrence of W in the last line of the following:
V ::= [0] INTEGER (0..30)
W ::= [1] INTEGER (25..35)
Y ::= [2] INTEGER (31..35)
Z1 ::= V (W | 24)

W contributes values 25-30 to the set arithmetic resulting in Z1 having the values 24-30. On the other hand, the
assignment:
Z2 ::= V (Y | 24)

is illegal because there are no values in Y which map to a value in V.



                                                                               Rec. ITU-T X.680 (02/2021)             115
ISO/IEC 8824-1:2021 (E)

C.6.3      The type of any value supplied as an actual parameter is required to have a value mapping from that value to
one of the values in the type governing the dummy parameter, and it is a value of that governing type which is
identified.
C.6.4     If a "Type" is supplied as an actual parameter for a dummy parameter which is a value set dummy parameter,
then all values of that "Type" are required to have value mappings to values in the governor of the value set dummy
parameter. The actual parameter selects the total set of values in the governor which have mappings to the "Type".
C.6.5      In specifying the type, A, of a dummy parameter that is a value or a value set parameter, it is an illegal
specification unless for all values of A, and for every instance of use of A on the right-hand side of the assignment, that
value of A can legally be applied in place of the dummy parameter.

C.7       Examples
C.7.1     This subclause provides examples to illustrate C.3 and C.4.

C.7.2     Example 1
X ::=    SEQUENCE               X1 ::= SEQUENCE
{name VisibleString,     {name VisibleString,
age INTEGER}             -- comment --
                    age INTEGER}
X2 ::= [8] SEQUENCE           X3 ::=    SEQUENCE
{name VisibleString,      {name VisibleString,
age INTEGER}              age AgeType}
                  AgeType ::= INTEGER

X, X1, X2, and X3 are all identical type definitions. Differences of white-space and comment are not visible, nor does the
use of the AgeType type reference in X3 affect the type definition. Note, however, that if any of the identifiers for the
elements of the sequence were changed, the types would cease to be identical definitions, and there would be no value
mappings between them.

C.7.3     Example 2
B ::=    SET                B1 ::= SET
{name VisibleString,        {age INTEGER,
age INTEGER}                name VisibleString}

are identical type definitions provided neither is in a module with AUTOMATIC TAGS in the module header, otherwise
they are not identical type definitions, and value mappings will not exist between them. Similar examples can be written
using CHOICE and ENUMERATED (using the "identifier" form of "EnumerationItem").

C.7.4     Example 3
C ::=    SET                C1 ::= SET
{name [0]VisibleString,      {name VisibleString,
age INTEGER}                age INTEGER (1..64)}

are not identical type definitions, nor are either of them identical type definitions to either of B or B1, and there are no
value mappings between any of the values of C and C1, nor between either of them and either of B or B1.

C.7.5     Example 4
x INTEGER { y (2) } ::= 3
z INTEGER ::= x

is legal, and assigns the value 3 to z through the value mapping defined in C.4.5.

C.7.6     Example 5
b1 BIT STRING ::= '101'B
b2 BIT STRING {version1(0), version2(1), version3(2)} ::= b1

is legal, and assigns the value {version1, version3} to b2.




116        Rec. ITU-T X.680 (02/2021)
                                                                                                 ISO/IEC 8824-1:2021 (E)

C.7.7     Example 6

With the definitions of C.1.1, SEQUENCE elements of the form:
X DEFAULT y

are legal, where X is any of A, B, C, D, E, or F, or any of the text to the right of the type assignments to these names, and
y is any of a, b, c, d, e, or f, with the following exceptions: E DEFAULT y is illegal for all of a, b, c, d, f, and
C DEFAULT e is illegal, because in these cases there are no value mappings available from the defaulting value
reference into the type being defaulted.




                                                                                Rec. ITU-T X.680 (02/2021)              117
ISO/IEC 8824-1:2021 (E)


                                                          Annex D

          Assigned object identifier and OID internationalized resource identifier values
                  (This annex forms an integral part of this Recommendation | International Standard.)


This annex records object identifier, OID internationalized resource identifier and object descriptor values assigned in
the ASN.1 series of Recommendations | International Standards, and provides an ASN.1 module for use in referencing
those values.

D.1       Values assigned in this Recommendation | International Standard
The following values are assigned in this Recommendation | International Standard:
Subclause 41.3
          Object Identifier Value:
          { joint-iso-itu-t asn1(1) specification(0) characterStrings(1) numericString(0) }

          OID internationalized Resource Identifier Value:
          "/Joint-ISO-ITU-T/ASN.1/Specification/Character_Strings/Numeric_String"

          Object Descriptor Value: "NumericString ASN.1 type"
Subclause 41.5
          Object Identifier Value:
          { joint-iso-itu-t asn1(1) specification(0) characterStrings(1) printableString(1) }

          OID Internationalized Resource Identifier Value:
          "/Joint-ISO-ITU-T/ASN.1/Specification/Character_Strings/Printable_String"

          Object Descriptor Value: "PrintableString ASN.1 type"
Subclause 42.1
          Object Identifier Value:
          { joint-iso-itu-t asn1(1)             specification(0)          modules(0)          iso10646(0) }

          OID Internationalized Resource Identifier Value:
          "/Joint-ISO-ITU-T/ASN.1/Specification/Modules/ISO_10646"

          Object Descriptor Value: "ASN.1 Character Module"
Subclause D.2
          Object Identifier Value:
          { joint-iso-itu-t asn1(1)             specification(0)          modules(0)          object-identifiers(1) }

          OID Internationalized Resource Identifier Value:
          "/Joint-ISO-ITU-T/ASN.1/Specification/Modules/Object_Identifiers"

          Object Descriptor Value: "ASN.1 Object Identifier Module"

D.2       Object identifiers in the ASN.1 and encoding rules standards
This clause specifies an ASN.1 module which contains the definition of a value reference name for each object
identifier value defined in the ASN.1 standards (Rec. ITU-T X.680 | ISO/IEC 8824-1 to Rec. ITU-T X.693 | ISO/IEC
8825-4).
   NOTE – These values are available for use in the value notation of the OBJECT IDENTIFIER type and types derived from it. All
   of the value references defined in the module specified in this clause are exported and have to be imported by any module that
   wishes to use them.
ASN1-Object-Identifier-Module { joint-iso-itu-t asn1(1) specification(0) modules(0) object-identifiers(1) }
"/Joint-ISO-ITU-T/ASN.1/Specification/Modules/Object_Identifiers"
DEFINITIONS ::= BEGIN
          -- NumericString ASN.1 type (see 41.3) --
          numericString OBJECT IDENTIFIER ::=
          { joint-iso-itu-t asn1(1) specification(0) characterStrings(1) numericString(0) }


118         Rec. ITU-T X.680 (02/2021)
                                                                                                 ISO/IEC 8824-1:2021 (E)

          -- PrintableString ASN.1 type (see 41.5) --
          printableString OBJECT IDENTIFIER ::=
          { joint-iso-itu-t asn1(1) specification(0) characterStrings(1) printableString(1) }
          -- ASN.1 Character Module (see 42.1) --
          asn1CharacterModule OBJECT IDENTIFIER ::=
          { joint-iso-itu-t asn1(1) specification(0) modules(0) iso10646(0) }
          -- ASN.1 Object Identifier Module (this module) --
          asn1ObjectIdentifierModule OBJECT IDENTIFIER ::=
          { joint-iso-itu-t asn1(1) specification(0) modules(0) object-identifiers(1) }
          -- BER encoding of a single ASN.1 type --
          ber OBJECT IDENTIFIER ::=
          { joint-iso-itu-t asn1(1) basic-encoding(1) }
          -- CER encoding of a single ASN.1 type --
          cer OBJECT IDENTIFIER ::=
          { joint-iso-itu-t asn1(1) ber-derived(2) canonical-encoding(0) }
          -- DER encoding of a single ASN.1 type --
          der OBJECT IDENTIFIER ::=
          { joint-iso-itu-t asn1(1) ber-derived(2) distinguished-encoding(1) }
          -- PER encoding of a single ASN.1 type (basic aligned) --
          perBasicAligned OBJECT IDENTIFIER ::=
          { joint-iso-itu-t asn1(1) packed-encoding(3) basic(0) aligned(0) }
          -- PER encoding of a single ASN.1 type (basic unaligned) --
          perBasicUnaligned OBJECT IDENTIFIER ::=
          { joint-iso-itu-t asn1(1) packed-encoding(3) basic(0) unaligned(1) }
          -- PER encoding of a single ASN.1 type (canonical aligned) --
          perCanonicalAligned OBJECT IDENTIFIER ::=
          { joint-iso-itu-t asn1(1) packed-encoding(3) canonical(1) aligned(0) }
          -- PER encoding of a single ASN.1 type (canonical unaligned) --
          perCanonicalUnaligned OBJECT IDENTIFIER ::=
          { joint-iso-itu-t asn1(1) packed-encoding(3) canonical(1) unaligned(1) }
          -- XER encoding of a single ASN.1 type (basic) --
          xerBasic OBJECT IDENTIFIER ::=
          {joint-iso-itu-t asn1(1) xml-encoding(5) basic(0) }
          -- XER encoding of a single ASN.1 type (canonical) --
          xerCanonical OBJECT IDENTIFIER ::=
          {joint-iso-itu-t asn1(1) xml-encoding(5) canonical(1) }
          -- EXER encoding of a single ASN.1 type (extended) --
          xerExtended OBJECT IDENTIFIER ::=
          {joint-iso-itu-t asn1(1) xml-encoding(5) extended(2) }
END -- ASN1-Object-Identifier-Module --




                                                                                     Rec. ITU-T X.680 (02/2021)     119
ISO/IEC 8824-1:2021 (E)


                                                       Annex E

                                                Encoding references
                 (This annex forms an integral part of this Recommendation | International Standard.)


E.1       This annex specifies the currently defined encoding references and the Recommendation | International
Standard that specifies the syntactic form (and semantics) of encoding instructions with that encoding reference (except
for the TAG encoding reference, which has no associated encoding instructions).
   NOTE – It is recommended that, if an encoding reference that is not specified here appears in an ASN.1 specification, the
   associated encoding instructions be ignored with (only) a warning diagnostic.

E.2       The encoding references in column 1 of Table E.1 are currently defined. The syntax and semantics of the
associated encoding instructions (where applicable) are defined in the Recommendation | International Standard
referenced in column 2 of Table E.1.

             Table E.1 – Standards defining the semantics associated with a given encoding reference

         Encoding reference                                        Refer to standard
                TAG               This Recommendation | International Standard
                XER               Rec. ITU-T X.693 (2021) | ISO/IEC 8825-4 :2021
                PER               Rec. ITU-T X.695 (2021) | ISO/IEC 8825-6 :2021




120        Rec. ITU-T X.680 (02/2021)
                                                                                                   ISO/IEC 8824-1:2021 (E)


                                                          Annex F

                Assignment and use of arcs in the International Object Identifier tree
              (This annex does not form an integral part of this Recommendation | International Standard.)

F.1      General
F.1.1     The International Object Identifier tree is specified in Rec. ITU-T X.660 | ISO/IEC 9834-1 Annex A. It
defines a hierarchy of registration authorities, each of which assigns:
         a)    a primary integer identifier (unambiguous and unique) to each subordinate arc to identify the nodes
               beneath the node it is responsible for;
         b)    (optionally) secondary identifiers to each subordinate arc that can aid human-readability of the
               subordinate arc identification, but are not necessarily unambiguous;
         c)    an integer-valued Unicode label (unambiguous) that is the character encoding of the primary integer
               value of the arc;
         d)    (optionally) further Unicode labels (unambiguous) that provide alternative identifications of subordinate
               arcs.
F.1.2    Unicode labels are (with minor restrictions) any sequence of Unicode characters.
F.1.3    Rec. ITU-T X.660 | ISO/IEC 9834-1, Annex A (and the Recommendations | International Standards and
procedures it references) defines the international object identifier tree.
   NOTE – An informal repository of information about OID allocations is available at http://www.oid-info.com.


F.2      Use of the International Object Identifier tree by the object identifier ( OBJECT IDENTIFIER)
         type
F.2.1      This type (and its value notations and encodings) provides a means of identifying a node of the International
Object Identifier tree using only the primary integer values of each arc (with the optional inclusion of secondary
identifiers in value notation, XML value notation, and XML encodings).
F.2.2      It has been in long-term use, and provides a compact means of identifying a node of the International Object
Identifier tree in binary-encoded computer communication.

F.3      Use of the International Object Identifier tree by the OID internationalized resource identifier
         (OID-IRI) type
F.3.1    This type (and its value notations and encodings) provides a means of identifying a node of the International
Object Identifier tree using only the Unicode labels of each arc.
F.3.2   The same syntax also forms the main body of the "oid" IRI and URI schemes registered with IANA (see
Annex F of Rec. ITU-T X.660 | ISO/IEC 9834-1).




                                                                                  Rec. ITU-T X.680 (02/2021)          121
ISO/IEC 8824-1:2021 (E)


                                                       Annex G

                                                 Examples and hints
              (This annex does not form an integral part of this Recommendation | International Standard.)


This annex contains examples of the use of ASN.1 in the description of (hypothetical) data structures. It also contains
hints, or guidelines, for the use of the various features of ASN.1. Unless otherwise stated, an environment of
AUTOMATIC TAGS is assumed.


G.1       Example of a personnel record
The use of ASN.1 is illustrated by means of a simple, hypothetical personnel record.

G.1.1     Informal description of Personnel Record
The structure of the personnel record and its value for a particular individual are shown below.
          Name:                       John P Smith
          Title:                      Director
          Employee Number:            51
          Date of Hire:               17 September 1971
          Name of Spouse:             Mary T Smith
          Number of Children:         2
          Child Information
               Name:                  Ralph T Smith
               Date of Birth          11 November 1957
          Child Information
               Name:                  Susan B Jones
               Date of Birth          17 July 1959

G.1.2     ASN.1 description of the record structure
The structure of every personnel record is formally described below using the standard notation for data types.
          PersonnelRecord ::= [APPLICATION 0] SET
{         name               Name,
          title         VisibleString,
          number        EmployeeNumber,
          dateOfHire         Date,
          nameOfSpouse Name,
          children      SEQUENCE OF ChildInformation DEFAULT {}
}
          ChildInformation ::= SET
{         name                Name,
          dateOfBirth         Date
}
          Name ::= [APPLICATION 1] SEQUENCE
{         givenName         VisibleString,
          initial      VisibleString,
          familyName        VisibleString
}
          EmployeeNumber ::= [APPLICATION 2] INTEGER
          Date ::= [APPLICATION 3] VisibleString -- YYYY MMDD




122        Rec. ITU-T X.680 (02/2021)
                                                                                               ISO/IEC 8824-1:2021 (E)

This example illustrates an aspect of the parsing of the ASN.1 syntax. The syntactic construct DEFAULT can only be
applied to a component of a SEQUENCE or a SET, it cannot be applied to an element of a SEQUENCE OF. Thus, the
DEFAULT { } in PersonnelRecord applies to children, not to ChildInformation.

G.1.3     ASN.1 description of a record value
The value of John Smith's personnel record is formally described below using the standard notation for data values.
{         name               {givenName "John", initial "P", familyName "Smith"},
title               "Director",
number         51,
dateOfHire          "19710917",
nameOfSpouse {givenName "Mary", initial "T", familyName "Smith"},
children
{ {name {givenName "Ralph", initial "T", familyName "Smith"} ,
   dateOfBirth "19571111"},
  {name {givenName "Susan", initial "B", familyName "Jones"} ,
   dateOfBirth "19590717" }
}
          }

or in XML value notation:
person ::=
<PersonnelRecord>
  <name>
    <givenName>John</givenName>
    <initial>P</initial>
    <familyName>Smith</familyName>
  </name>
  <title>Director</title>
  <number>51</number>
  <dateOfHire>19710917</dateOfHire>
  <nameOfSpouse>
    <givenName>Mary</givenName>
    <initial>T</initial>
    <familyName>Smith</familyName>
  </nameOfSpouse>
  <children>
    <ChildInformation>
      <name>
        <givenName>Ralph</givenName>
        <initial>T</initial>
        <familyName>Smith</familyName>
      </name>
      <dateOfBirth>19571111</dateOfBirth>
    </ChildInformation>
    <ChildInformation>
      <name>
        <givenName>Susan</givenName>
        <initial>B</initial>
        <familyName>Jones</familyName>
      </name>
      <dateOfBirth>19590717</dateOfBirth>
    </ChildInformation>
  </children>
</PersonnelRecord>


G.2       Guidelines for use of the notation
The data types and formal notation defined by this Recommendation | International Standard are flexible, allowing a
wide range of protocols to be designed using them. This flexibility, however, can sometimes lead to confusion,
especially when the notation is approached for the first time. This annex attempts to minimize confusion by giving
guidelines for, and examples of, the use of the notation. For each of the built-in data types, one or more usage guidelines
are offered. The character string types (for example, VisibleString) and the types defined in clauses 46 to 48 are not
dealt with here.




                                                                               Rec. ITU-T X.680 (02/2021)             123
ISO/IEC 8824-1:2021 (E)

G.2.1    Boolean
G.2.1.1 Use a boolean type to model the values of a logical (that is, two-state) variable, for example, the answer to a
yes-or-no question.
         EXAMPLE
         Employed ::= BOOLEAN

G.2.1.2 When assigning a reference name to a boolean type, choose one that describes the true state.
         EXAMPLE
         Married ::= BOOLEAN

         not
         MaritalStatus ::= BOOLEAN

G.2.2    Integer
G.2.2.1 Use an integer type to model the values (for all practical purposes, unlimited in magnitude) of a cardinal or
integer variable.
         EXAMPLE
         CheckingAccountBalance ::= INTEGER -- in cents; negative means overdrawn.
         balance CheckingAccountBalance ::= 0

or using XML value notation:
         balance ::= <CheckingAccountBalance>0</CheckingAccountBalance>

G.2.2.2 Define the minimum and maximum allowed values of an integer type as named numbers.
         EXAMPLE
         DayOfTheMonth ::= INTEGER {first(1), last(31)}
         today DayOfTheMonth ::= first
         unknown DayOfTheMonth ::= 0

or using XML value notation:
         today ::= <DayOfTheMonth><first/></DayOfTheMonth>
         unknown ::= <DayOfTheMonth>0</DayOfTheMonth>

Note that the named numbers first and last were chosen because of their semantic significance to the reader, and
does not exclude the possibility of DayOfTheMonth having other values which may be less than 1, greater than 31 or
between 1 and 31.
To restrict the value of DayOfTheMonth to just first and last, one would write:
         DayOfTheMonth ::= INTEGER {first(1), last(31)} (first | last)

and to restrict the value of the DayOfTheMonth to all values between 1 and 31, inclusive, one would write:
         DayOfTheMonth ::= INTEGER {first(1), last(31)} (first .. last)
         dayOfTheMonth DayOfTheMonth ::= 4

or using XML value notation:
         dayOfTheMonth ::= <DayOfTheMonth>4</DayOfTheMonth>

G.2.3    Enumerated
G.2.3.1 Use an enumerated type to model the values of a variable with three or more states. Assign values starting
with zero if their only constraint is distinctness.
         EXAMPLE
         DayOfTheWeek ::= ENUMERATED {sunday(0), monday(1), tuesday(2),
                    wednesday(3), thursday(4), friday(5), saturday(6)}
         firstDay DayOfTheWeek ::= sunday


124        Rec. ITU-T X.680 (02/2021)
                                                                                           ISO/IEC 8824-1:2021 (E)

or using XML value notation:
          firstDay ::= <DayOfTheWeek><sunday/></DayOfTheWeek>

Note that while the enumerations sunday, monday, etc., were chosen because of their semantic significance to the
reader, DayOfTheWeek is restricted to assuming one of these values and no other. Further, only the name sunday,
monday, etc., can be assigned to a value; the equivalent integer values are not allowed.

G.2.3.2 Use an extensible enumerated type to model the values of a variable that has just two states now, but that may
have additional states in a future version of the protocol.
          EXAMPLE
          MaritalStatus ::= ENUMERATED {single, married}
                      -- First version of MaritalStatus
in anticipation of:
          MaritalStatus ::= ENUMERATED {single, married, …, widowed}
                      -- Second version of MaritalStatus
and later yet:
          MaritalStatus ::= ENUMERATED {single, married, …, widowed, divorced}
                      -- Third version of MaritalStatus

G.2.4     Real
G.2.4.1 Use a real type to model an approximate number.
          EXAMPLE
          AngleInRadians ::= REAL
          pi REAL ::= {mantissa 3141592653589793238462643383279, base 10, exponent −30}

or using the alternate value notation for REAL:
          pi REAL ::= 3.14159265358979323846264338327

or using XML value notation:
          pi ::=
          <REAL>
                3.14159265358979323846264338327
          </REAL>

G.2.4.2 Application designers may wish to ensure full interworking with real values despite differences in floating
point hardware, and in implementation decisions to use (for example) single or double length floating point for an
application. This can be achieved by the following:
          App-X-Real ::= REAL (WITH COMPONENTS {
                        mantissa (−16777215..16777215),
                        base (2),
                        exponent (−125..128) } )
          /*
           Senders shall not transmit values outside these ranges
           and conforming receivers shall be capable of receiving
           and processing all values in these ranges.
          */
          girth App-X-Real ::= {mantissa 16, base 2, exponent 1}

or using XML value notation:
          girth ::=
          <App-X-Real>
            32
          </App-X-Real>

G.2.5     Bit string
G.2.5.1 Use a bit string type to model binary data whose format and length are unspecified, or specified elsewhere,
and whose length in bits is not necessarily a multiple of eight.


                                                                           Rec. ITU-T X.680 (02/2021)            125
ISO/IEC 8824-1:2021 (E)

          EXAMPLE
          G3FacsimilePage ::= BIT STRING
          -- a sequence of bits conforming to Rec. ITU-T T.4.
          image G3FacsimilePage ::= '100110100100001110110'B
          trailer BIT STRING ::= '0123456789ABCDEF'H
          body1 G3FacsimilePage ::= '1101'B
          body2 G3FacsimilePage ::= '1101000'B

or using XML value notation:
          image ::= <G3FacSimile>100110100100001110110</G3FacSimile>
          trailer ::=
                <BIT_STRING>
                      0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011
                      1100 1101 1110 1111
                </BIT_STRING>
          body1 ::= <G3FacSimile>1101</G3FacSimile>
          body2 ::= <G3FacSimile>1101000</G3FacSimile>

Note that body1 and body2 are distinct abstract values because trailing 0 bits are significant (due to there being no
"NamedBitList" in the definition of G3FacsimilePage).
G.2.5.2 Use a bit string type with a size constraint to model the values of a fixed sized bit field.
          EXAMPLE
          BitField ::= BIT STRING (SIZE (12))
          map1 BitField ::= '100110100100'B
          map2 BitField ::= '9A4'H
          map3 BitField ::= '1001101001'B     -- Illegal - violates size constraint.

or using XML value notation:
          map1 ::= <BitField>100110100100</BitField>

Note that map1 and map2 are the same abstract value, for the four trailing bits of map2 are not significant.
G.2.5.3 Use a bit string type to model the values of a bit map, an ordered collection of logical variables indicating
whether a particular condition holds for each of a correspondingly ordered collection of objects.
          DaysOfTheWeek ::= BIT STRING {
              sunday(0), monday (1), tuesday(2),
              wednesday(3), thursday(4), friday(5),
              saturday(6) } (SIZE (0..7))
          sunnyDaysLastWeek1 DaysOfTheWeek ::= {sunday, monday, wednesday}
          sunnyDaysLastWeek2 DaysOfTheWeek ::= '1101'B
          sunnyDaysLastWeek3 DaysOfTheWeek ::= '1101000'B
          sunnyDaysLastWeek4 DaysOfTheWeek ::= '11010000'B -- Illegal

or using XML value notation:
          sunnyDaysLastWeek1 ::=
          <DaysOfTheWeek>
            <sunday/><monday/><wednesday/>
                   </DaysOfTheWeek>
          sunnyDaysLastWeek2 ::= <DaysOfTheWeek>1101</DaysOfTheWeek>
          sunnyDaysLastWeek3 ::= <DaysOfTheWeek>1101000</DaysOfTheWeek>

Note that if the bit string value is less than 7 bits long, then the missing bits indicate a cloudy day for those days, hence
the first three values above have the same abstract value.
G.2.5.4 Use a bit string type to model the values of a bit map, a fixed-size ordered collection of logical variables
indicating whether a particular condition holds for each of a correspondingly ordered collection of objects.


126        Rec. ITU-T X.680 (02/2021)
                                                                                              ISO/IEC 8824-1:2021 (E)

        DaysOfTheWeek ::= BIT STRING {
             sunday(0), monday (1), tuesday(2),
             wednesday(3), thursday(4), friday(5),
             saturday(6) } (SIZE (7))
sunnyDaysLastWeek1 DaysOfTheWeek ::= {sunday, monday, wednesday}
sunnyDaysLastWeek2 DaysOfTheWeek ::= '1101'B -- Illegal
                                  -- violates size constraint.
sunnyDaysLastWeek3 DaysOfTheWeek ::= '1101000'B
          sunnyDaysLastWeek4 DaysOfTheWeek ::= '11010000'B -- Illegal
                                -- violates size constraint.

Note that the first and third values have the same abstract value.
G.2.5.5 Use a bit string type with named bits to model the values of a collection of related logical variables.
          EXAMPLE
          PersonalStatus ::= BIT STRING
               {married(0), employed(1), veteran(2), collegeGraduate(3)}
          billClinton PersonalStatus ::= {married, employed, collegeGraduate}
          hillaryClinton PersonalStatus ::= '110100'B

or using XML value notation:
          billClinton ::=
          <PersonalStatus>
            <married/>
            <employed/>
            <collegeGraduate/>
          </PersonalStatus>
          hillaryClinton ::= <PersonalStatus>110100</PersonalStatus>

Note that billClinton and hillaryClinton have the same abstract values.

G.2.6     Octet string
G.2.6.1 Use an octet string type to model binary data whose format and length are unspecified, or specified elsewhere,
and whose length in bits is a multiple of eight.
          EXAMPLE
          G4FacsimileImage ::= OCTET STRING
          -- a sequence of octets conforming to Rec. ITU-T T.5 and CCITT Rec. T.6
          image G4FacsimileImage ::= '3FE2EBAD471005'H

or using XML value notation:
          image ::= <G4FacSimileImage>3FE2EBAD471005</G4FacSimileImage>

G.2.6.2 Use a restricted character string type in preference to an octet string type, where an appropriate one is
available.
          EXAMPLE
          Surname ::= PrintableString
          president Surname ::= "Clinton"

or using XML value notation:
          president ::= <Surname>Clinton</Surname>

G.2.7     UniversalString, BMPString and UTF8String
Use the BMPString type or the UTF8String type to model any string of information which consists solely of
characters from the ISO/IEC 10646 Basic Multilingual Plane (BMP), and UniversalString or UTF8String to model
any string which consists of ISO/IEC 10646 characters not confined to the BMP.
G.2.7.1 Use Level1 or Level2 to denote that the implementation level places restrictions on the use of combining
characters.



                                                                                Rec. ITU-T X.680 (02/2021)        127
ISO/IEC 8824-1:2021 (E)

          EXAMPLE
          RussianName ::= Cyrillic (Level1)
               -- RussianName uses no combining characters.
          SaudiName ::= BasicArabic (SIZE (1..100) ^ Level2)
               -- SaudiName uses a subset of combining characters.
Representation of letter :
          greekCapitalLetterSigma BMPString ::= {0, 0, 3, 163}

or using XML value notation:
          greekCapitalLetterSigma ::= <BMPString>&#x03a3;</BMPString>

Representation of string "f → ":
          rightwardsArrow UTF8String ::= {0, 0, 33, 146}
          infinity UTF8String ::= {0, 0, 34, 30}
          property UTF8String ::= {"f ", rightwardsArrow, " ", infinity}

or using XML value notation:
          property ::= <UTF8String>f &#x2192; &#x221E;</UTF8String>

G.2.7.2 A collection can be expanded to be a selected subset (i.e., include all characters in the BASIC LATIN
collection) by use of the "UnionMark" (see clause 50).
          EXAMPLE
          KatakanaAndBasicLatin ::= UniversalString (FROM (Katakana | BasicLatin))

G.2.8     CHARACTER STRING
Use the unrestricted character string type to model any string of information which cannot be modelled using one of the
restricted character string types. Be sure to specify the repertoire of characters and their coding into octets.
          EXAMPLE
          PackedBCDString ::= CHARACTER STRING (WITH COMPONENTS {
                                                           identification (WITH COMPONENTS {
                                                                fixed PRESENT })
                    /* The abstract and transfer syntaxes shall be
                      packedBCDString-AbstractSyntaxId and
                 packedBCDString-TransferSyntaxId defined below.
               */
                               })

               /* object identifier value for a character abstract syntax
                 (character set) whose alphabet
                 is the digits 0 through 9.
               */
          packedBCDString-AbstractSyntaxId OBJECT IDENTIFIER ::=
              { joint-iso-itu-t example(999) packedBCD(2) charSet(0) }

               /* object identifier value for a character transfer syntax that
                 packs two digits per octet, each digit encoded as 0000 to
                 1001, 11112 used for padding.
               */
          packedBCDString-TransferSyntaxId OBJECT IDENTIFIER ::=
                      { joint-iso-itu-t example(999) packedBCD(2)
                            characterTransferSyntax(1) }
          /* The encoding of PackedBCDString will contain only the defined
            encoding of the characters, with any necessary length field, and in
            the case of BER with a field carrying the tag. The object
            identifier values are not carried, as "fixed" has been specified.
               */




128        Rec. ITU-T X.680 (02/2021)
                                                                                                ISO/IEC 8824-1:2021 (E)

or using XML value notation:
            packedBCDString-AbstractSyntaxId ::=
            <OBJECT_IDENTIFIER>
                joint-iso-itu-t.example(999).packedBCD(2).charSet(0)
            </OBJECT_IDENTIFIER>


           packedBCDString-TransferSyntaxId ::=
<OBJECT_IDENTIFIER>
joint-iso-itu-t.example(999).packedBCD(2).characterTransferSyntax(1)
                    </OBJECT_IDENTIFIER>

or:
            packedBCDString-AbstractSyntaxId ::=
            <OBJECT_IDENTIFIER>2.999.2.0</OBJECT_IDENTIFIER>
             packedBCDString-TransferSyntaxId ::=
             <OBJECT_IDENTIFIER>2.999.2.1</OBJECT_IDENTIFIER>
      NOTE – Encoding rules do not necessarily encode values of the type CHARACTER STRING in a form that always includes the
      object identifier values, although they do guarantee that the abstract value is preserved in the encoding.

G.2.9       Null
Use a null type to indicate the effective absence of a component of a sequence.
            EXAMPLE
            PatientIdentifier ::= SEQUENCE {
            name                  VisibleString,
            roomNumber            CHOICE {
                 room             INTEGER,
                 outPatient       NULL -- if an out-patient --
            }
}
            lastPatient PatientIdentifier ::= {
            name       "Jane Doe",
            roomNumber outPatient : NULL
}

or using XML value notation:
            lastPatient ::=
            <PatientIdentifier>
              <name>Jane Doe</name>
              <roomNumber><outPatient/></roomNumber>
            </PatientIdentifier>

G.2.10      Sequence and sequence-of
G.2.10.1 Use a sequence-of type to model a collection of variables whose types are the same, whose number is large or
unpredictable, and whose order is significant.
            EXAMPLE
            NamesOfMemberNations ::= SEQUENCE OF VisibleString
            -- in alphabetical order
            firstTwo NamesOfMemberNations ::= {"Australia", "Austria"}

or, using the optional identifier:
            NamesOfMemberNations2 ::= SEQUENCE OF memberNation VisibleString
            -- in alphabetical order
            firstTwo2 NamesOfMemberNations2 ::=
            {memberNation "Australia", memberNation "Austria"}

Using XML value notation, the above two values are as follows:
            firstTwo ::=
            <NamesOfMemberNations>
               <VisibleString>Australia</VisibleString>


                                                                                Rec. ITU-T X.680 (02/2021)             129
ISO/IEC 8824-1:2021 (E)

            <VisibleString>Austria</VisibleString>
          </NamesOfMemberNations>
          firstTwo2 ::=
          <NamesOfMemberNations2>
             <memberNation>Australia</memberNation>
             <memberNation>Austria</memberNation>
          </NamesOfMemberNations2>

G.2.10.2 Use a sequence type to model a collection of variables whose types are the same, whose number is known and
modest, and whose order is significant, provided that the make-up of the collection is unlikely to change from one
version of the protocol to the next.
          EXAMPLE
          NamesOfOfficers ::= SEQUENCE {
             president           VisibleString,
             vicePresident       VisibleString,
             secretary           VisibleString}
          acmeCorp NamesOfOfficers ::= {
              president        "Jane Doe",
              vicePresident    "John Doe",
              secretary        "Joe Doe"}

or using XML value notation:
          acmeCorp ::=
          <NamesOfOfficers>
            <president>Jane Doe</president>
             <vicePresident>John Doe</vicePresident>
             <secretary>Joe Doe</secretary>
          </NamesOfOfficers>

G.2.10.3 Use an inextensible sequence type to model a collection of variables whose types differ, whose number is
known and modest, and whose order is significant, provided that the make-up of the collection is unlikely to change
from one version of the protocol to the next.
          EXAMPLE
          Credentials ::= SEQUENCE {
              userName          VisibleString,
              password          VisibleString,
              accountNumber          INTEGER}
G.2.10.4 Use an extensible sequence type to model a collection of variables whose order is significant, whose number
currently is known and is modest, but which is expected to be increased:
          EXAMPLE
          Record ::= SEQUENCE { -- First version of protocol containing "Record"
          userName              VisibleString,
          password              VisibleString,
          accountNumber               INTEGER,
          ...,
          ...
}

in anticipation of:
          Record ::= SEQUENCE { -- Second version of protocol containing "Record"
          userName                    VisibleString,
          password                    VisibleString,
          accountNumber                    INTEGER,
          ...,
          [[2:             -- Extension addition added in protocol version 2
              lastLoggedIn            GeneralizedTime OPTIONAL,
              minutesLastLoggedIn          INTEGER
          ]],
          ...
}




130         Rec. ITU-T X.680 (02/2021)
                                                                                             ISO/IEC 8824-1:2021 (E)

and later yet (version 3 of the protocol made no additions to Record):
         Record ::= SEQUENCE { -- Third version of protocol containing "Record"
         userName                   VisibleString,
         password                   VisibleString,
         accountNumber                   INTEGER,
         ...,
         [[2:            -- Extension addition added in protocol version 2
            lastLoggedIn            GeneralizedTime OPTIONAL,
            minutesLastLoggedIn          INTEGER
         ]],
         [[4:            -- Extension addition added in protocol version 3
                 certificate           Certificate,
             thumb                 ThumbPrint OPTIONAL
         ]],
         ...
         }

G.2.11   Set and set-of
G.2.11.1 Use a set type to model a collection of variables whose number is known and modest and whose order is
insignificant. If automatic tagging is not in effect, identify each variable by context-specifically tagging it as shown
below. (With automatic tagging, the tags are not needed.)
         EXAMPLE
         UserName ::= SET {
             personalName                          [0] VisibleString,
             organizationName                      [1] VisibleString,
             countryName                           [2] VisibleString}
         user UserName ::= {
              countryName                          "Nigeria",
              personalName                         "Jonas Maruba",
              organizationName                     "Meteorology, Ltd."}

or using XML value notation:
         user ::=
         <UserName>
           <countryName>Nigeria</countryName>
           <personalName>Jonas Maruba</personalName>
           <organizationName>Meteorology, Ltd.</organizationName>
         </UserName>

G.2.11.2 Use a set type with OPTIONAL to model a collection of variables that is a (proper or improper) subset of
another collection of variables whose number is known and reasonably small and whose order is insignificant. If
automatic tagging is not in effect, identify each variable by context-specifically tagging it as shown below. (With
automatic tagging, the tags are not needed.)
         EXAMPLE
         UserName ::= SET {
         personalName                         [0] VisibleString,
         organizationName                     [1] VisibleString OPTIONAL
                    -- defaults to that of the local organization -- ,
         countryName                          [2] VisibleString OPTIONAL
                    -- defaults to that of the local country -- }
G.2.11.3 Use an extensible set type to model a collection of variables whose make-up is likely to change from one
version of the protocol to the next. The following assumes AUTOMATIC TAGS was specified in the module definition.
         EXAMPLE
         UserName ::= SET {
         personalName       VisibleString,          -- First version of "UserName"
         organizationName        VisibleString OPTIONAL ,
         countryName             VisibleString OPTIONAL,
         ...,
         ...
}



                                                                             Rec. ITU-T X.680 (02/2021)            131
ISO/IEC 8824-1:2021 (E)

          user UserName ::= { personalName "Jonas Maruba" }

or using XML value notation:
          user ::=
          <UserName>
            <personalName>Jonas Maruba</personalName>
          </UserName>

in anticipation of:
          UserName ::= SET {         -- Second version of "UserName"
          personalName               VisibleString,
          organizationName                 VisibleString OPTIONAL,
          countryName                      VisibleString OPTIONAL,
          ...,
          [[2:                 -- Extension addition added in protocol version 2
              internetEmailAddress VisibleString,
              faxNumber              VisibleString OPTIONAL
          ]],
          ...
}
          user UserName ::= {
          personalName               "Jonas Maruba",
          internetEmailAddress           "jonas@meteor.ngo.com"
}

or using XML value notation:
           user ::=
<UserName>
  <personalName>Jonas Maruba</personalName>
  <internetEmailAddress>jonas@meteor.ngo.com</internetEmailAddress>
</UserName>

and later yet (versions 3 and 4 of the protocol made no additions to UserName):
          UserName ::= SET { -- Fifth version of protocol containing "UserName"
          personalName             VisibleString,
          organizationName               VisibleString OPTIONAL,
          countryName                    VisibleString OPTIONAL,
          ...,
          [[2:                     -- Extension addition added in version 2
              internetEmailAddress VisibleString,
              faxNumber            VisibleString OPTIONAL
          ]],
          [[5:                     -- Extension addition added in version 5
          phoneNumber                    VisibleString OPTIONAL
          ]],
          ...
}
          user UserName ::= {
          personalName               "Jonas Maruba",
          internetEmailAddress           "jonas@meteor.ngo.com"
}

or using XML value notation:
          user ::=
          <UserName>
            <personalName>Jonas Maruba</personalName>
            <internetEmailAddress>jonas@meteor.ngo.com</internetEmailAddress>
          </UserName>

G.2.11.4 Use a set-of type to model a collection of variables whose types are the same and whose order is insignificant.
          EXAMPLE
          Keywords ::= SET OF VisibleString -- in arbitrary order
          someASN1Keywords Keywords ::= {"INTEGER", "BOOLEAN", "REAL"}




132         Rec. ITU-T X.680 (02/2021)
                                                                                              ISO/IEC 8824-1:2021 (E)

or, using the optional identifier:
          Keywords2 ::= SET OF keyword VisibleString -- in arbitrary order
          someASN1Keywords2 Keywords2 ::= {keyword "INTEGER", keyword "BOOLEAN",
                 keyword "REAL"}

Using XML value notation, the above two values are as follows:
          someASN1Keywords ::=
          <Keywords>
            <VisibleString>INTEGER</VisibleString>
            <VisibleString>BOOLEAN</VisibleString>
            <VisibleString>REAL</VisibleString>
          </Keywords>
          someASN1Keywords2 ::=
          <Keywords2>
            <keyword>INTEGER</keyword>
            <keyword>BOOLEAN</keyword>
            <keyword>REAL</keyword>
                   </Keywords2>

G.2.12    Tagged
Prior to the introduction of the AUTOMATIC TAGS construct, ASN.1 specifications frequently contained tags. The
following subclauses describe the way in which tagging was typically applied. With the introduction of AUTOMATIC
TAGS, new ASN.1 specifications need make no use of the tag notation, although those modifying old notation may have
to concern themselves with tags. New users of the ASN.1 notation are encouraged to use AUTOMATIC TAGS as this
makes the notation more readable.
G.2.12.1 Universal class tags are used only within this Recommendation | International Standard. The notation
[UNIVERSAL 30] (for example) is provided solely to enable precision in the definition of the "UsefulTypes" (see 45.1).
It should not be used elsewhere.
G.2.12.2 A frequently encountered style for the use of tags is to assign an application class tag precisely once in the
entire specification, using it to identify a type that finds wide, scattered, use within the specification. An application
class tag is also frequently used (once only) to tag the types in the outermost CHOICE of an application, providing
identification of individual messages by the application class tag. The following is an example use in the former case:
          EXAMPLE
          FileName ::= [APPLICATION 8] SEQUENCE {
               directoryName             VisibleString,
               directoryRelativeFileName VisibleString}

The above example assumes that the default encoding reference is either "empty" or TAG. Otherwise, the above example
would be written:
          FileName ::= [TAG: APPLICATION 8] SEQUENCE {
               directoryName             VisibleString,
               directoryRelativeFileName VisibleString}

A similar change would be needed in subsequent examples.
G.2.12.3 Context-specific tagging is frequently applied in an algorithmic manner to all components of a SET,
SEQUENCE, or CHOICE. Note, however, that the AUTOMATIC TAGS facility does this easily for you.

          EXAMPLE
          CustomerRecord ::= SET {
              name                           [0] VisibleString,
              mailingAddress                 [1] VisibleString,
              accountNumber                  [2] INTEGER,
              balanceDue                     [3] INTEGER -- in cents --}
          CustomerAttribute ::= CHOICE {
              name                           [0] VisibleString,
              mailingAddress                 [1] VisibleString,
              accountNumber                  [2] INTEGER,
              balanceDue                     [3] INTEGER -- in cents --}




                                                                              Rec. ITU-T X.680 (02/2021)             133
ISO/IEC 8824-1:2021 (E)

G.2.12.4 Private class tagging should normally not be used in internationally standardized specifications (although this
cannot be prohibited). Applications produced by an enterprise will normally use application and context-specific tag
classes. There may be occasional cases, however, where an enterprise-specific specification seeks to extend an
internationally standardized specification, and in this case use of private class tags may give some benefits in partially
protecting the enterprise-specific specification from changes to the internationally standardized specification.
          EXAMPLE
          AcmeBadgeNumber ::= [PRIVATE 2] INTEGER
          badgeNumber AcmeBadgeNumber ::= 2345

or using XML value notation:
          badgeNumber ::= <AcmeBadgeNumber>2345</AcmeBadgeNumber>

G.2.12.5 Textual use of IMPLICIT with every tag is generally found only in older specifications. BER produces a less
compact representation when explicit tagging is used than when implicit tagging is used. PER produces the same
compact encoding in both cases. With BER and explicit tagging, there is more visibility of the underlying type
(INTEGER, REAL, BOOLEAN, etc.) in the encoded data. These guidelines use implicit tagging in the examples whenever it
is legal to do so. This may, depending on the encoding rules, result in a compact representation, which is highly
desirable in some applications. In other applications, compactness may be less important than, for example, the ability
to carry out strong type-checking. In the latter case, explicit tagging can be used.
          EXAMPLE
          CustomerRecord ::= SET {
              name                            [0] IMPLICIT VisibleString,
              mailingAddress                  [1] IMPLICIT VisibleString,
              accountNumber                   [2] IMPLICIT INTEGER,
              balanceDue                      [3] IMPLICIT INTEGER -- in cents --}
          CustomerAttribute ::= CHOICE {
              name                            [0] IMPLICIT VisibleString,
              mailingAddress                  [1] IMPLICIT VisibleString,
              accountNumber                   [2] IMPLICIT INTEGER,
              balanceDue                      [3] IMPLICIT INTEGER -- in cents --}

G.2.12.6 Guidance on use of tags in new ASN.1 specifications referencing this Recommendation | International
Standard is quite simple: DON'T USE TAGS. Put AUTOMATIC TAGS in the module header, then forget about tags. If
you need to add new components to the SET, SEQUENCE or CHOICE in a later version, add them to the end.

G.2.13    Choice
G.2.13.1 Use a CHOICE to model a variable that is selected from a collection of variables whose number are known and
modest.
          EXAMPLE
          FileIdentifier ::= CHOICE {
               relativeName VisibleString,
                    -- name of file (for example, "MarchProgressReport")
               absoluteName VisibleString,
                    -- name of file and containing directory
                    -- (for example, "<Williams>MarchProgressReport")
               serialNumber INTEGER
                    -- system-assigned identifier for file --}
          file FileIdentifier ::= serialNumber : 106448503

or using XML value notation:
fileIdentifier ::=
            <FileIdentifier>
              <serialNumber>106448503</serialNumber>
            </FileIdentifier>

G.2.13.2 Use an extensible CHOICE to model a variable that is selected from a collection of variables whose make-up is
likely to change from one version of the protocol to the next.
          EXAMPLE
          FileIdentifier ::= CHOICE {                                      -- First version of FileIdentifier


134        Rec. ITU-T X.680 (02/2021)
                                                                                                ISO/IEC 8824-1:2021 (E)

                 relativeName VisibleString,

                 absoluteName   VisibleString,

                 ..., ...
}
          fileId1 FileIdentifier ::= relativeName : "MarchProgressReport.doc"

or using XML value notation:
fileId1 ::=
<FileIdentifier>
   <relativeName>MarchProgressReport.doc</relativeName>
</FileIdentifier>

in anticipation of:
          FileIdentifier ::= CHOICE {       -- Second version of FileIdentifier
          relativeName VisibleString,
          absoluteName VisibleString,
          ...,
          serialNumber INTEGER,       -- Extension addition added in version 2
          ...
}

fileId1 FileIdentifier ::= relativeName : "MarchProgressReport.doc"

fileId2 FileIdentifier ::= serialNumber : 214

or using XML value notation:
fileId1 ::=
<FileIdentifier>
   <relativeName>MarchProgressReport.doc</relativeName>
</FileIdentifier>
fileId2 ::=
<FileIdentifier>
   <serialNumber>214</serialNumber>
</FileIdentifier>

and later yet:
          FileIdentifier ::= CHOICE {          -- Third version of FileIdentifier
          relativeName VisibleString,
          absoluteName VisibleString,
          ...,
          serialNumber INTEGER,          -- Extension addition added in version 2
          [[                       -- Extension addition added in version 3
              vendorSpecific   VendorExt,
              unidentified NULL
          ]],
          ...
}
          fileId1 FileIdentifier ::= relativeName : "MarchProgressReport.doc"
          fileId2 FileIdentifier ::= serialNumber : 214
          fileId3 FileIdentifier ::= unidentified : NULL

or using XML value notation:
          fileId1 ::=
          <FileIdentifier>
             <relativeName>MarchProgressReport.doc</relativeName>
          </FileIdentifier>
          fileId2 ::=
          <FileIdentifier>
             <serialNumber>214</serialNumber>
          </FileIdentifier>
          fileId3 ::=


                                                                                    Rec. ITU-T X.680 (02/2021)     135
ISO/IEC 8824-1:2021 (E)

          <FileIdentifier>
            <unidentified/>
          </FileIdentifier>

G.2.13.3 Use an extensible CHOICE of only one type where the possibility is envisaged of more than one type being
permitted in the future.
          EXAMPLE
          Greeting ::= CHOICE {                -- First version of "Greeting"
          postCard      VisibleString,
          ...,
          ...
}

in anticipation of:
          Greeting ::= CHOICE {              -- Second version of "Greeting"
          postCard VisibleString,
          ...,
          [[2:                    -- Extension addition added in version 2
              audio     Audio,
              video     Video
          ]],
          ...
}

G.2.13.4 Multiple colons are required when a choice value is nested within another choice value.
          EXAMPLE
          Greeting ::= [APPLICATION 12] CHOICE {
              postCard       VisibleString,
              recording      Voice }
          Voice ::= CHOICE {
               english      OCTET STRING,
               swahili      OCTET STRING }
          myGreeting Greeting ::= recording : english : '019838547E0'H

or using XML value notation:
myGreeting ::=
<Greeting>
  <recording><english>019838547E0</english></recording>
</Greeting>

G.2.14    Selection type
G.2.14.1 Use a selection type to model a variable whose type is that of some particular alternatives of a previously
defined CHOICE.
G.2.14.2 Consider the definition:
          FileAttribute ::= CHOICE {
               date-last-used INTEGER,
               file-name      VisibleString}

then the following definition is possible:
          AttributeList ::= SEQUENCE {
               first-attribute date-last-used < FileAttribute,
               second-attribute     file-name < FileAttribute }

with a possible value notation of:
          listOfAttributes AttributeList ::= {
               first-attribute 27,
               second-attribute     "PROGRAM" }

or using XML value notation:
listOfAttributes ::=
<AttributeList>
  <first-attribute>27</first-attribute>


136         Rec. ITU-T X.680 (02/2021)
                                                                                                   ISO/IEC 8824-1:2021 (E)

  <second-attribute>PROGRAM</second-attribute>
</AttributeList>

G.2.15   Object class field type
G.2.15.1 Use an object class field type to identify a type defined by means of an information object class (see Rec.
ITU-T X.681 | ISO/IEC 8824-2). For example, fields of the information object class ATTRIBUTE may be used in
defining a type, Attribute.
         EXAMPLE
ATTRIBUTE ::= CLASS {
&AttributeType,
&attributeId    OBJECT IDENTIFIER UNIQUE
   }
Attribute ::= SEQUENCE {
attributeID        ATTRIBUTE.&attributeId,             -- this is normally constrained.
attributeValue ATTRIBUTE.&AttributeType          -- this is normally constrained.
     }

Both ATTRIBUTE.&attributeId and ATTRIBUTE.&AttributeType are object class field types, in that they are types
defined by reference to an information object class (ATTRIBUTE). The type ATTRIBUTE.&attributeId is fixed
because it is explicitly defined in ATTRIBUTE as an OBJECT IDENTIFIER.                            However, the type
ATTRIBUTE.&AttributeType can carry a value of any type defined using ASN.1, since its type is not fixed in the
definition of the information object class ATTRIBUTE. Notations that possess this property of being able to carry a value
of any type are termed "open type notation", hence ATTRIBUTE.&AttributeType is an open type.

G.2.16   Embedded-pdv
G.2.16.1 Use an embedded-pdv type to model a variable whose type is unspecified, or specified elsewhere with no
restriction on the notation used to specify the type.
         EXAMPLE
         FileContents ::= EMBEDDED PDV
         DocumentList ::= SEQUENCE OF document EMBEDDED PDV

G.2.17   External
The external type is similar to the embedded-pdv type, but has fewer identification options. New specifications will
generally prefer to use embedded-pdv because of its greater flexibility and the fact that some encoding rules encode its
values more efficiently.

G.2.18   Instance-of
G.2.18.1 Use an instance-of to specify a type containing an object identifier field and an open type value whose type is
determined by the object identifier. The instance-of type can only be used if the association between the object
identifier value and the type is specified using an information object of a class derived from TYPE-IDENTIFIER (see
Rec. ITU-T X.681 | ISO/IEC 8824-2, Annex A and Annex C).
         EXAMPLE
         ACCESS-CONTROL-CLASS ::= TYPE-IDENTIFIER
         Get-Invoke ::= SEQUENCE {
         objectClass        ObjectClass,
         objectInstance ObjectInstance,
         accessControl INSTANCE OF ACCESS-CONTROL-CLASS,                     -- this is normally
                                  -- constrained.
         attributeID        ATTRIBUTE.&attributeId
         }

Get-Invoke is then equivalent to:
         Get-Invoke ::= SEQUENCE {
         objectClass        ObjectClass,
         objectInstance ObjectInstance,
         accessControl [UNIVERSAL 8] IMPLICIT SEQUENCE {
              type-id ACCESS-CONTROL-CLASS.&id,       -- this is normally
                                  -- constrained.
              value         [0] ACCESS-CONTROL-CLASS.&Type -- this is normally


                                                                                Rec. ITU-T X.680 (02/2021)            137
ISO/IEC 8824-1:2021 (E)

                                   -- constrained.
         },
         attributeID    ATTRIBUTE.&attributeId
}

The true utility of the instance-of type is not seen until it is constrained using an information object set, but such an
example goes beyond the scope of this Recommendation | International Standard. See Rec. ITU-T X.682 |
ISO/IEC 8824-3 for the definition of information object set, and Annex A of Rec. ITU-T X.682 | ISO/IEC 8824-3 for
how to use an information object set to constrain an instance-of type.

G.2.19   Object identifier
Use an OBJECT IDENTIFIER when a compact numerical identification of a node of the OID tree is needed in binary
encodings.

G.2.20   OID internationalized resource identifier
Use an OID-IRI when the use of names that include all most Unicode characters is desired, and where character
encodings are acceptable. OID-IRI values can also be used as an IRI or URI using the "oid" IRI/URI scheme (see
ITU-T Rec X.660 | ISO/IEC 9834-1 Annex F).

G.2.21   Relative object identifier
G.2.21.1 Use a relative object identifier type to transmit object identifier values in a more compact form in contexts
where the early part of the object identifier value is known. There are three situations that can arise:
         a)   The early part of the object identifier value is fixed for a given specification (it is an industry-specific
              standard, and all OIDs are relative to an OID allocated to the standardizing body. In this case, use:
              RELATIVE-OID -- The relative object identifier value is
                     -- relative to {iso identified-organization set(22)}
         b)   The early part of the object identifier value is frequently a value that is known at specification time, but
              may occasionally be a more general value. In this case, use:
              CHOICE
              {a RELATIVE-OID -- The value is relative to {1 3 22}--,
               b OBJECT IDENTIFIER -- Any object identifier value--}
         c)   The early part of the object identifier value is not known until communications time, but will frequently
              be common to many values that need to be sent, and quite often will be a value known at specification
              time. In this case use (for example):
              SEQUENCE
              {oid-root OBJECT IDENTIFIER DEFAULT {1 3 22},
               reloids SEQUENCE OF RELATIVE-OID --relative to oid-root--}


G.3      Value notation and property settings (TIME type and useful time types)
This subclause provides examples of value notation for the time type. The same value notation is used for the useful
time types, but is restricted to denotation of abstract values that are present in those types. Each example gives a time
abstract value in normal human notation, then a value assignment for that value, using a useful time type if there is one
that contains it, otherwise using the TIME type. The following comment gives the settings needed to define a subtype of
the TIME type that contains all similar abstract values.

G.3.1    Date
EXAMPLES
Calendar date – 12 April 1985:
date1 DATE ::= "1985-04-12" -- Basic=Date Date=YMD Year=Basic

Ordinal date – 12 April 1985:
date2 TIME ::= "1985-102" -- Basic=Date Date=YD Year=Basic

Week date – Friday 12 April 1985:
date3 TIME ::= "1985-W15-5" -- Basic=Date Date=YWD Year=Basic

Calendar week – 15th week of 1985:


138        Rec. ITU-T X.680 (02/2021)
                                                                                          ISO/IEC 8824-1:2021 (E)
date4 TIME ::= "1985-W15" -- Basic=Date Date=YW Year=Basic

Calendar month – April 1985:
date5 TIME ::= "1985-04" -- Basic=Date Date=YM Year=Basic

Calendar year – 1985:
date6 TIME ::= "1985" -- Basic=Date Date=Y Year=Basic

Calendar date – 12 April 11985:
date7 TIME ::= "+11985-04-12" -- Basic=Date Date=YMD Year=L5

The 12th April in the 2nd year before the year 0000:
date8 TIME ::= "-0002-04-12" -- Basic=Date Date=YMD Year=Negative

The 20th century:
date9 TIME ::= "19C" -- Basic=Date Date=C Year=Basic


G.3.2     Time of day
EXAMPLES
27 minutes and 46 seconds past 15 hours:
time1 TIME-OF-DAY ::= "15:27:46"
-- Basic=Time Time=HMS Local-or-UTC=L

To the nearest minute:
time2 TIME ::= "15:28"
-- Basic=Time Time=HM Local-or-UTC=L

Local time of day with decimal fractions using comma – 27 minutes and 35 and a half second past 15 hours:
time3 TIME ::= "15:27:35,5"
-- Basic=Time Time=HMSF1 Local-or-UTC=L

UTC – 20 minutes and 30 seconds past 23 hours:
time4 TIME ::= "23:20:30Z"
-- Basic=Time Time=HMS Local-or-UTC=Z

To the nearest hour:
time5 TIME ::= "23Z"
-- Basic=Time Time=H Local-or-UTC=Z

Local time of day and the difference from UTC – 27 minutes 46 seconds past 15 hours locally in Geneva (one hour
ahead of UTC):
time6 TIME ::= "15:27:46+01:00"
-- Basic=Time Time=HMS Local-or-UTC=LD

Alternative value notation for the same abstract value:
time7 TIME ::= "15:27:46+01"
-- Basic=Time Time=HMS Local-or-UTC=LD

27 minutes 46 seconds past 15 hours locally in New York (five hours behind UTC):
time8 TIME ::= "15:27:46-05:00"
-- Basic=Time Time=HMS Local-or-UTC=LD


G.3.3     Date and time of day
EXAMPLES
Combination of calendar date and local time of day:
date-time1 DATE-TIME ::= "1985-04-12T10:15:30"
-- Basic=Date-Time Date=YMD Year=Basic Time=HMS
-- Local-or-UTC=L



                                                                           Rec. ITU-T X.680 (02/2021)        139
ISO/IEC 8824-1:2021 (E)

Combination of calendar date and local time of day with time differential; the local time of day is 01:30 on the 1st of
April 1985; the UTC time at that location is 23:30 on the 31st of March 1985:
date-time2 TIME ::= "1985-04-01T01:30:00+02.00"
-- Basic=Date-Time Date=YMD Time=HMS Local-or-UTC=LD

Combination of ordinal date and UTC:
date-time3 TIME ::= "1985-102T23:50:30Z"
-- Basic=Date-Time Date=YD Year=Basic Time=HMS Local-or-UTC=Z

Combinations of week date and local time of day:
date-time4 TIME ::= "1985-W14-5T23:50:30"
-- Basic=Date-Time Date=YWD Year=Basic Time=HMS
-- Local-or-UTC=L


G.3.4     Time interval
EXAMPLES
A time interval starting at 20 minutes and 50 seconds past 23 hours on 12 April 1985 and ending at 30 minutes past 10
hours on 25 June 1985:
interval1 TIME ::= "1985-04-12T23:20:50/1985-06-25T10:30:00"
-- Basic=Interval Interval-type=SE SE-point=Date-Time
-- Date=YMD Year=Basic Time=HMS Local-or-UTC=L

A time interval starting at local time of day 30 minutes past 12 hours (UTC time 30 minutes past 10 hours) on 12 April
1985 and ending at 30 minutes past 13 hours on 12 April with the same time difference (which is not a requirement):
interval2 TIME ::= "1985-04-12T12:30:00+02:00/1985-04-12T13:30:00+02:00"
-- Basic=Interval Interval-type=SE SE-point=Date-Time
-- Date=YMD Year=Basic Time=HMS Local-or-UTC=L

Alternative value notation for the same abstract value, omitting the second time difference:
interval3 TIME ::= "1985-04-12T12:30:00+02:00/1985-04-12T13:30:00"
-- Basic=Interval Interval-type=SE SE-point=Date-Time
-- Date=YMD Year=Basic Time=HMS Local-or-UTC=L

A time interval starting at 12 April 1985 and ending on 25 June 1985:

interval4 TIME ::= "1985-04-12/1985-06-25"
-- Basic=Interval Interval-type=SE SE-point=Date
-- Date=YMD Year=Basic

A time interval of 2 years, 10 months, 15 days, 10 hours, 20 minutes and 30 seconds:
duration1 DURATION ::= "P2Y10M15DT10H20M30S"
-- Basic=Interval Interval-type=D

A time interval of 1 year and 6 months:
duration2 DURATION ::= "P1Y6M"
-- Basic=Interval Interval-type=D

A time interval of seventy-two hours:
duration3 DURATION ::= "PT72H"
-- Basic=Interval Interval-type=D

A time interval of 1 year, 2 months, 15 days and 12 hours, beginning on 12 April 1985 at 20 minutes past 23 hours:

interval5 TIME ::= "1985-04-12T23:20:00/P1Y2M15DT12H"
-- Basic=Interval Interval-type=SD SE-point=Date-Time
-- Date=YMD Year=Basic Time=HMS Local-or-UTC=L

A time interval of 1 year, 2 months, 15 days and 12 hours, ending on 12 April 1985 at 20 minutes past 23 hours:

interval6 TIME ::= "P1Y2M15DT12H/1985-04-12T23:20:00"
-- Basic=Interval Interval-type=DE SE-point=Date-Time
-- Date=YMD Year=Basic Time=HMS Local-or-UTC=L



140        Rec. ITU-T X.680 (02/2021)
                                                                                                 ISO/IEC 8824-1:2021 (E)

G.3.5     Recurring interval
EXAMPLES
Fifteen recurrences of a time interval of 2 years, 10 months, 15 days, 10 hours, 20 minutes and 30 seconds:
rec-int1 TIME ::= "R15/P2Y10M15DT10H20M30S"
-- Basic=Rec-Interval Recurrence=R2 Interval-type=D

An unbounded number of recurrences of a time interval of 2 years, 15 days, 10 hours, 20 minutes and 30 seconds:
rec-int2 TIME ::= "R/P2Y15DT10H20M30S"
-- Basic=Rec-Interval Recurrence=Unlimited Interval-type=D

Two recurrences of a time interval of 1 year and 6 months:
rec-int3 TIME ::= "R2/P1Y6M"
-- Basic=Rec-Interval Recurrence=R1 Interval-type=D

An unbounded number of occurrences of a time interval of 1 year, 2 months, 15 days and 12 hours of which the last
occurrence ends at 12 April 1985 at 20 minutes and 50 seconds past 23 hours:
rec-int4 TIME ::= "R/P1Y2M15DT12H/1985-04-12T23:20:50"
-- Basic=Rec-Interval Recurrence=Unlimited Interval-type=DE
-- SE-point=Date-Time Date=YMD Year=Basic Time=HMS
-- Local-or-UTC=L


G.4       Identifying abstract syntaxes
G.4.1      It is common for protocols to be defined by associating semantics with each of the values of a single ASN.1
type, typically a choice type. (This ASN.1 type is sometimes referred to informally as "the top-level type for the
application".) This set of abstract values is formally called the abstract syntax for the application. An abstract syntax can
be identified by giving it an abstract syntax name of ASN.1 type object identifier.
G.4.2     The assignment of an object identifier to an abstract syntax can be done using the built-in information object
class ABSTRACT-SYNTAX which is defined in Rec. ITU-T X.681 | ISO/IEC 8824-2. This also serves to clearly identify
the top-level type for the application.
G.4.3     The following is an example of text which might appear in an application specification:
          EXAMPLE
          Application-ASN1 DEFINITIONS ::=
          BEGIN
          EXPORTS Application-PDU;
                Application-PDU ::= CHOICE {
                       connect-pdu ...... ,
                       data-pdu CHOICE {
                             ..... ,
                             .....
                       },
                       .....
                }
                ......
          END
          Abstract-Syntax-Module DEFINITIONS ::=
          BEGIN
          IMPORTS Application-PDU FROM Application-ASN1;

          -- This application defines the following abstract syntax:
                abstract-Syntax ABSTRACT-SYNTAX ::=
                     { Application-PDU IDENTIFIED BY
                           application-abstract-syntax-object-id }
                application-abstract-syntax-object-id OBJECT IDENTIFIER ::=
                     {joint-iso-itu-t asn1(1) examples(123)
                           application-abstract-syntax(3) }
          -- The corresponding object descriptor is:



                                                                                Rec. ITU-T X.680 (02/2021)              141
ISO/IEC 8824-1:2021 (E)

                 application-abstract-syntax-descriptor ObjectDescriptor ::=
                            "Example Application Abstract Syntax"

          -- The ASN.1 object identifier and object descriptor values:
                                     -- encoding rule object identifier
                                     -- encoding rule object descriptor
          -- assigned to encoding rules in Rec. ITU-T X.690 | ISO/IEC 8825-1
          -- and Rec. ITU-T X.691 | ISO/IEC 8825-2 can be used as the transfer
          -- syntax identifier in conjunction with this transfer syntax.
          END

G.4.4    In order to ensure interworking, the standard may additionally identify a mandatory transfer syntax (typically
one of those defined in the encoding rules of Rec. ITU-T X.690 | ISO/IEC 8825-1 or Rec. ITU-T X.691 | ISO/IEC
8825-2 or Rec. ITU-T X.692 | ISO/IEC 8825-3).

G.5       Subtypes
G.5.1     Use subtypes to limit the values of an existing type which are to be permitted in a particular situation.
          EXAMPLES
          AtomicNumber       ::= INTEGER (1..104)
          TouchToneString ::= IA5String
                  (FROM ("0123456789" | "*" | "#")) (SIZE (1..63))
          ParameterList ::= SET SIZE (1..63) OF Parameter
          SmallPrime ::= INTEGER (2|3|5|7|11|13|17|19|23|29)

G.5.2     Use an extensible subtype constraint to model an INTEGER type whose set of permitted values is small and
well defined, but which is expected to increase.
          EXAMPLE
          SmallPrime ::= INTEGER (2 | 3, ...)                     -- First version of SmallPrime

in anticipation of:
          SmallPrime ::= INTEGER (2 | 3, ..., 5 | 7 | 11)
          -- Second version of SmallPrime
and later yet:
          SmallPrime ::= INTEGER (2 | 3, ..., 5 | 7 | 11 | 13 | 17 | 19)
          -- Third version of SmallPrime
   NOTE – For certain types, some encoding rules (e.g., PER) provide a highly optimized encoding for subtype constraint extension
   root values (i.e., values appearing before the "...") and a less optimized encoding for subtype constraint extension addition
   values (i.e., values appearing after the "..."), while in some other encoding rules (e.g., BER) subtype constraints have no effect
   on the encoding.

G.5.3    Where two or more related types have significant commonality, consider explicitly defining their common
parent as a type and use subtyping for the individual types. This approach makes clear the relationship and the
commonality, and encourages (though does not force) this to continue as the types evolve. It thus facilitates the use of
common implementation approaches to the handling of values of these types.
          EXAMPLE
          Envelope     ::= SET {
                           typeA TypeA,
                           typeB TypeB OPTIONAL,
                           typeC TypeC OPTIONAL}
                           -- the common parent
          ABEnvelope ::= Envelope (WITH COMPONENTS
                       {... ,
                              typeB PRESENT, typeC ABSENT})
                           -- where typeB must always appear and typeC must not
          ACEnvelope ::= Envelope (WITH COMPONENTS
                       {... ,
                              typeB ABSENT, typeC PRESENT})


142         Rec. ITU-T X.680 (02/2021)
                                                                                                      ISO/IEC 8824-1:2021 (E)

                         -- where typeC must always appear and typeB must not
The latter definitions could alternatively be expressed as:
          ABEnvelope ::= Envelope (WITH COMPONENTS {typeA, typeB})
          ACEnvelope ::= Envelope (WITH COMPONENTS {typeA, typeC})

The choice between the alternatives would be made upon such factors as the number of components in the parent type,
and the number of those which are optional, the extent of the difference between the individual types, and the likely
evolution strategy.
G.5.4     Use subtyping to partially define a value, for example, a protocol data unit to be tested for in a conformance
test, where the test is concerned only with some components of the PDU.
          EXAMPLE
          Given:
          PDU ::= SET
           {alpha     INTEGER,
            beta      IA5String OPTIONAL,
            gamma     SEQUENCE OF Parameter,
            delta     BOOLEAN}

then in composing a test which requires the Boolean to be false and the integer to be negative, write:
          TestPDU ::= PDU (WITH COMPONENTS
            {... ,
             delta (FALSE),
             alpha (MIN..<0)})

and if, further, the IA5String, beta, is to be present and either 5 or 12 characters in length, write:
          FurtherTestPDU ::= TestPDU (WITH COMPONENTS {... , beta (SIZE (5|12)) PRESENT } )

G.5.5    If a general-purpose data type has been defined as a SEQUENCE OF, use subtyping to define a restricted
subtype of the general type.
          EXAMPLE
          Text-block ::= SEQUENCE OF VisibleString
          Address ::= Text-block (SIZE (1..6)) (WITH COMPONENT (SIZE (1..32)))

G.5.6     If a general-purpose data type had been defined as a CHOICE, use subtyping to define a restricted subtype of
the general type.
          EXAMPLE
          Z ::= CHOICE {
               a       A,
               b       B,
               c       C,
               d       D,
               e       E
          }
          V ::= Z (WITH COMPONENTS { ..., a ABSENT, b ABSENT })
                                                      -- 'a' and 'b' must be absent,
                                                      -- either 'c', 'd' or 'e' may be present in a value.
          W ::= Z (WITH COMPONENTS { ..., a PRESENT })                           -- only 'a' can be present
                              -- (see 51.8.10.2).
          X ::= Z (WITH COMPONENTS { a PRESENT })                                     -- only 'a' can be present
                          -- (see 51.8.10.2).
          Y ::= Z (WITH COMPONENTS { a ABSENT, b, c })
                   -- 'a', 'd' and 'e' must be absent,
                   -- either 'b' or 'c' may be present in a value.
         NOTE – W and X are semantically identical.




                                                                                    Rec. ITU-T X.680 (02/2021)           143
ISO/IEC 8824-1:2021 (E)

G.5.7      Use contained subtypes to form new subtypes from existing subtypes.
           EXAMPLE
           Months     ::= ENUMERATED {
                           january               (1),
                           february              (2),
                           march                 (3),
                           april                 (4),
                           may                   (5),
                           june                  (6),
                           july                  (7),
                           august                (8),
                           september             (9),
                           october               (10),
                           november              (11),
                           december              (12) }
           First-quarter ::= Months ( january | february | march )
           Second-quarter ::= Months ( april | may | june )
           Third-quarter ::= Months ( july | august | september )
           Fourth-quarter ::= Months ( october | november | december )
           First-half ::= Months ( First-quarter | Second-quarter )
           Second-half ::= Months ( Third-quarter | Fourth-quarter )

G.5.8     Examples of subtyping the time type are present in 38.4, and several useful settings are given in the comments
in G.3. Additional examples follow, with comments. Note that all examples of subtyping can also be applied to the
useful time types, but will only select abstract values that are already present in those types. The main use of this
notation is to provide variations on the useful time types.
EXAMPLES
My-Date ::= TIME
(SETTINGS "Basic=Date Year=Basic Date=YD")
-- A date type that uses years and days
My-Date1 ::= TIME
(SETTINGS "Basic=Date Year=Basic Date=YD")
("2000-001" .. < "2011-001")
-- A date type that uses years and days restricted to the
-- period from the 1st Jan. AD 2000 to Dec. 31st AD 2010, inclusive.

My-Date2 ::= TIME
("2000-001" .. < "2011-001")
-- The same date type as My-Date1, but this is probably less
-- clear to a human user. It relies on the property settings
-- being deduced from the value notation (see Annex K).
My-Illegal-Date ::= TIME
("1500-01" .. < "2011-01")
-- The lower bound is a proleptic date, and the upper bound
-- is a basic date, so they do not have the same properties,
-- and this is illegal.
My-time-of-day-1 ::= TIME
(SETTINGS "Basic=Time Time=HMS Local-or-UTC=L
 Midnight=Start")
-- This is the same as TIME-OF-DAY, but midnight at the end of
-- the day is excluded, with the only midnight being represented
-- by the value notation "00:00:00".
My-time-of-day-2 ::= TIME
(SETTINGS "Basic=Time Time=HMS Local-or-UTC=L
 Midnight=End")
-- This is the same as TIME-OF-DAY, but midnight at the start of
-- the day is excluded, with the only midnight being represented
-- by the value notation "24:00:00".
My-time-of-day-3 ::= TIME


144         Rec. ITU-T X.680 (02/2021)
                                                                           ISO/IEC 8824-1:2021 (E)

(SETTINGS "Basic=Time Time=HMS Local-or-UTC=Z")
-- This is the same as TIME-OF-DAY, but the time is UTC, not
-- local time of day.




                                                               Rec. ITU-T X.680 (02/2021)     145
ISO/IEC 8824-1:2021 (E)


                                                      Annex H

                                 Tutorial annex on ASN.1 character strings
              (This annex does not form an integral part of this Recommendation | International Standard.)

H.1      Character string support in ASN.1
H.1.1    There are four groups of character string support in ASN.1. The four groups are:
         a)    Character string types based on ISO International Register of Coded Character Sets to be used with
               Escape Sequences (that is, based on the structure of ISO/IEC 646) and the associated International
               Register of Coded Character Sets, and provided by the types VisibleString, IA5String,
               TeletexString, VideotexString, GraphicString, and GeneralString.
         b)    Character string types based on ISO/IEC 10646, and provided by subsetting the type
               UniversalString, UTF8String or BMPString with subsets defined in ISO/IEC 10646 or by using
               named characters.
         c)    Character string types providing a simple small collection of characters specified in this Recommen
               dation | International Standard, and intended for specialized use; these are the NumericString and
               PrintableString types.
         d)    Use of the type CHARACTER STRING, with negotiation of the character set to be used (or announcement
               of the set being used); this permits an implementation to use any collection of characters and encodings
               for which OBJECT IDENTIFIERs have been assigned, including those of ISO International Register of
               Coded Character Sets to be used with Escape Sequences, ISO/IEC 7350, ISO/IEC 10646, and private
               collections of characters and encodings (profiles may impose requirements or restrictions on the
               character sets – the character abstract syntaxes – to be used).

H.2      The UniversalString, UTF8String and BMPString types
H.2.1     The UniversalString and UTF8String types carry any character from ISO/IEC 10646. The set of
characters in ISO/IEC 10646 is generally too large for meaningful conformance to be required, and should normally be
subsetted to a combination of the standard collections of characters in Annex A of ISO/IEC 10646.
H.2.2    The BMPString type carries any character from the Basic Multilingual Plan of ISO/IEC 10646. The Basic
Multilingual Plane is normally subsetted to a combination of the standard collections of characters in Annex A of
ISO/IEC 10646.
H.2.3   For the collections defined in Annex A of ISO/IEC 10646, there are type references defined in the built-in
ASN.1 module ASN1-CHARACTER-MODULE (see clause 42). The "subtype constraint" mechanism allows new subtypes
of UniversalString that are combinations of existing subtypes to be defined.
H.2.4     Examples of type references defined in ASN1-CHARACTER-MODULE and their corresponding ISO/IEC 10646
collection names are:
               BasicLatin                        BASIC LATIN
               Latin-1Supplement                 LATIN-1 SUPPLEMENT
               LatinExtended-a                   LATIN EXTENDED-A
               LatinExtended-b                   LATIN EXTENDED-B
               IpaExtensions                     IPA EXTENSIONS
               SpacingModifierLetters            SPACING MODIFIER LETTERS
               CombiningDiacriticalMarks COMBINING DIACRITICAL MARKS

H.2.5     ISO/IEC 10646 specifies three "levels of implementation", and requires that all uses of ISO/IEC 10646
specify the implementation level.
The implementation level relates to the extent to which support is given for combining characters in the character
repertoire, and hence, in ASN.1 terms, defines a subset of the UniversalString and BMPString restricted character
string types.
In implementation level 1, combining characters are not allowed, and there is normally a one-to-one correspondence
between abstract characters in ASN.1 character strings and printed characters in a physical rendition of the string.



146       Rec. ITU-T X.680 (02/2021)
                                                                                                       ISO/IEC 8824-1:2021 (E)

In implementation level 2, certain combining characters (listed in ISO/IEC 10646, Annex B) are available for use, but
there are others whose use is prohibited.
In implementation level 3, there are no restrictions on the use of combining characters.
H.2.6     A BMPString or UniversalString can be restricted to exclude all control functions by use of the subtype
notation as follows:
          VanillaBMPString ::= BMPString (FROM (BMPString(SIZE(1)) EXCEPT
                                  ({0,0,0,0}..{0,0,0,31} |
                                      {0,0,0,128}..{0,0,0,159})))

or equivalently:
         C0 ::= BMPString (FROM ({0,0,0,0} .. {0,0,0,31})) -- C0 control functions
C1 ::= BMPString (FROM ({0,0,0,128} .. {0,0,0,159})) -- C1 control functions
VanillaBMPString ::= BMPString (FROM (BMPString(SIZE(1)) EXCEPT (C0 | C1)))


H.3       On ISO/IEC 10646 conformance requirements
Use of UniversalString, BMPString or UTF8String (or subtypes of these) in an ASN.1 type definition requires that
the conformance requirements of ISO/IEC 10646 be addressed.
These conformance requirements demand that implementers of a standard (X say) using such ASN.1 types provide (in
the Protocol Implementation Conformance Statement) a statement of the adopted subset of ISO/IEC 10646 for their
implementation of standard X, and of the level (support for combining characters) of the implementation.
The use of an ASN.1 subtype of UniversalString, UTF8String or BMPString in a specification requires that an
implementation support all the ISO/IEC 10646 characters that are included in that ASN.1 subtype, and hence that (at
least) those characters be present in the adopted subset for the implementation. It is also a requirement that the stated
level be supported for all such ASN.1 subtypes.
   NOTE – An ASN.1 specification (in the absence of parameters of the abstract syntax and exception specifications) determines
   both the (maximum) set of characters that can be transmitted and the (minimum) set of characters that have to be handled on
   receipt. The adopted set of ISO/IEC 10646 requires that characters beyond this set not be transmitted, and that all characters
   within this set be supported on receipt. The adopted set therefore needs to be precisely the set of all characters permitted by the
   ASN.1 specification. The case where a parameter of the abstract syntax is present is discussed below.


H.4       Recommendations for ASN.1 users on ISO/IEC 10646 conformance
Users of ASN.1 should make clear the set of ISO/IEC 10646 characters that will form the adopted subset of
implementations (and the required implementation level) if the requirements of their standard are to be met.
This can conveniently be done by defining an ASN.1 subtype of UniversalString, UTF8String or BMPString that
contains all the characters needed for the standard, and by restricting it to Level1 or Level2 if appropriate. A
convenient name for this type might be ISO-10646-String.
          EXAMPLE
ISO-10646-String ::= BMPString
(FROM (Level2 INTERSECTION (BasicLatin UNION HebrewExtended UNION Hiragana)))
          -- This is the type that defines the minimum set of characters in
          -- the adopted subset for an implementation of this standard. The
          -- implementation level is required to be at least level 2.
In an OSI environment, the OSI Protocol Implementation Conformance Statement would then contain a simple
statement that the adopted subset of ISO/IEC 10646 is the limited subset (and the level) defined by ISO-10646-
String, and ISO-10646-String (possibly subtyped) would be used throughout the standard where ISO/IEC 10646
strings were to be included.
          EXAMPLE CONFORMANCE STATEMENT
          The adopted subset of ISO/IEC 10646 is the limited subset consisting of all the characters in the ASN.1 type
          ISO-10646-String defined in module <your module name goes here>, with an implementation level of 2.
          EXAMPLE USE IN PROTOCOL
          Message ::= SEQUENCE {
          first-field ISO-10646-String,
                                      -- all characters in the adopted
                                      -- subset can appear
          second-field ISO-10646-String
               (FROM (latinSmallLetterA .. latinSmallLetterZ)), -- lower-case


                                                                                     Rec. ITU-T X.680 (02/2021)                  147
ISO/IEC 8824-1:2021 (E)

                              -- latin letters only
          third-field  ISO-10646-String
               (FROM (digitZero .. digitNine))      -- digits only
          }


H.5       Adopted subsets as parameters of the abstract syntax
ISO/IEC 10646 requires that the adopted subset and level of an implementation be explicitly defined. Where an ASN.1
user does not wish to constrain the range of ISO/IEC 10646 characters in some part of the standard being defined, this
can be expressed by defining ISO-10646-String (for example) as a subtype of UniversalString, BMPString or
UTF8String with a subtype constraint consisting of (or including) ImplementorsSubset which is left as a parameter
of the abstract syntax.
Users of ASN.1 are warned that in this case a conforming sender may transmit to a conforming receiver characters that
cannot be handled by the receiver because they fall outside the (implementation-dependent) adopted subset or level of
the receiver, and it is recommended that an exception-handling specification be included in the definition of
ISO-10646-String in this case.
          EXAMPLE
ISO-10646-String {UniversalString : ImplementorsSubset, ImplementationLevel} ::=
         UniversalString (FROM((ImplementorsSubset UNION BasicLatin)
                   INTERSECTION ImplementationLevel) !characterSetProblem)
-- The adopted subset of ISO/IEC 10646 shall include "BasicLatin", but
-- may also include any additional characters specified in
-- "ImplementorsSubset", which is a parameter of the abstract syntax.
-- "ImplementationLevel", which is a parameter of the abstract
-- syntax defines the implementation level. A conforming receiver must be
-- prepared to recieve characters outside of its adopted subset and
-- implementation level. In this case the exception handling specified in
-- clause <add your clause number here> for "characterSetProblem" is
-- invoked. Note that this can never be invoked by a conforming
-- receiver if the actual characters used in an instance of communication
-- are restricted to "BasicLatin".
My-Level2-String ::= ISO-10646-String { { HebrewExtended UNION Hiragana }, Level2 }


H.6       The CHARACTER STRING type
H.6.1     The CHARACTER STRING type gives complete flexibility in the choice of character set and encoding method.
   NOTE – Where a single connection provides end-to-end data transfer (no relaying), and the OSI protocols are in use, then
   negotiation of the character sets to be used and their encoding can be accomplished as part of the definition of the OSI
   presentation contexts for character abstract syntaxes. Otherwise, the abstract and transfer character syntaxes (character repertoire
   and encodings) are announced by a pair of object identifier values.

H.6.2     In formal terms, a character abstract syntax is an ordinary abstract syntax with some restrictions on the
possible values (they are all character strings, and indeed are all the character strings formed from some collection of
characters). Thus allocation of object identifier values for character abstract and transfer syntaxes is performed in the
normal way.
H.6.3      The encoding of CHARACTER STRING announces the abstract and transfer syntax of the character repertoire in
use (that is, character set and encoding). In OSI environments, negotiation of both these syntaxes is possible.
H.6.4      Character abstract syntaxes (and corresponding character transfer syntaxes) have been defined in a number of
ITU-T Recommendations and International Standards, and additional character abstract syntaxes (and/or character
transfer syntaxes) can be defined by any organization able to allocate object identifiers.
H.6.5     In ISO/IEC 10646, there is a character abstract syntax defined (and object identifiers assigned) for the entire
collection of characters, for each of the defined collection of characters for subsets (BASIC LATIN, BASIC
SYMBOLS, etc.), and for every possible combination of the defined collections of characters. There are also two
character transfer syntaxes defined to identify the various options (particularly 16-bit and 32-bit) in ISO/IEC 10646.




148           Rec. ITU-T X.680 (02/2021)
                                                                                                            ISO/IEC 8824-1:2021 (E)


                                                                 Annex I

                                Tutorial annex on the ASN.1 model of type extension
                 (This annex does not form an integral part of this Recommendation | International Standard.)

I.1          Overview
I.1.1    It can happen that an ASN.1 type evolves over time from an extension root type by means of a series of
extensions called extension additions.
I.1.2     An ASN.1 type available to a particular implementation may be the extension root type, or may be the
extension root type plus one or more extension additions. Each such ASN.1 type that contains an extension addition
also contains all previously defined extension additions.
I.1.3     The ASN.1 type definitions in this series are said to be extension-related (see 3.8.38 for a more precise
definition of "extension-related"), and encoding rules are required to encode extension-related types in a such a way that
if two systems are using two different types which are extension-related, transmissions between the two systems will
successfully transfer the information content of those parts of the extension-related types that are common to the two
systems. It is also required that those parts that are not common to both systems can be delimited and retransmitted
(perhaps to a third party) on a subsequent transmission, provided the same transfer syntax is used.
      NOTE – The sender may be using a type that is either earlier or later in the series of extension additions.

I.1.4      The series of types obtained by progressively adding to a root type is called an extension series. In order for
encoding rules to make appropriate provision for transmissions of extension-related types (which may require more bits
on the line), such types (including the extension root type) need to be syntactically flagged. The flag is an ellipsis (...),
and is called an extension marker.
EXAMPLE
Extension root type           1st extension          2nd extension            3rd extension
A ::= SEQUENCE { A ::= SEQUENCE { A ::= SEQUENCE { A ::= SEQUENCE {
a INTEGER,      a INTEGER,               a INTEGER,         a INTEGER,
  ...      ...,        ...,           ...,
}         b BOOLEAN,            b BOOLEAN,              b BOOLEAN,
          c INTEGER           c INTEGER,             c INTEGER,
        }            d SEQUENCE {                d SEQUENCE {
                       e INTEGER,               e INTEGER,
                         ...,           ...,
                         ...,         g BOOLEAN OPTIONAL,
                       f IA5String            h BMPString,
                     }                   ...,
                   }                   f IA5String
                                    }
                                  }

I.1.5     All extension additions in sequence, set, and choice types are inserted between pairs of extension markers. A
single extension marker is allowed if (in the extension root type) it appears as the last item in the type, in which case a
matching extension marker is assumed to exist just before the closing brace of the type; in such cases all extension
additions are inserted at the end of the type.
I.1.6     A type that has an extension marker can be nested inside a type that has none, or it can be nested within a type
in an extension root, or it can be nested in an extension addition type. In such cases the extension series are treated
independently, and the nested type with the extension marker has no impact on the type within which it is nested. Only
one extension insertion point (the end of the type if a single extension marker is used, or just before the second
extension marker if a pair of extension markers is used) can appear in any specific construct.
I.1.7     A new extension addition in the extension series is defined in terms of a single extension addition group
(one or more types nested within "[[" "]]") or a single type added at the extension insertion point. In the following
example the first extension defines an extension addition group where b and c must either be both present or both
absent in a value of type A. The second extension defines a single component type, d, which may be absent in a value of
type A. The third extension defines an extension addition group in which h must be present in a value of type A
whenever the newly added extension addition group is present in a value.
EXAMPLE
Extension root type        1st extension      2nd extension   3rd extension


                                                                                              Rec. ITU-T X.680 (02/2021)       149
ISO/IEC 8824-1:2021 (E)

A ::= SEQUENCE {         A ::= SEQUENCE { A ::= SEQUENCE { A ::= SEQUENCE {
a INTEGER,       a INTEGER,                a INTEGER,       a INTEGER,
  ...      ...,         ...,          ...,
}         [[           [[             [[
            b BOOLEAN,           b BOOLEAN,              b BOOLEAN,
            c INTEGER           c INTEGER             c INTEGER
          ]]          ]],            ]],
        }             d SEQUENCE {               d SEQUENCE {
                        e INTEGER,              e INTEGER,
                          ...,          ...,
                          ...,        [[
                        f IA5String           g BOOLEAN OPTIONAL,
                      }                h BMPString
                    }                  ]],
                                        ...,
                                      f IA5String
                                    }
                                  }

I.1.8    It is also possible to add the version number to version brackets, but only if it is present on all brackets within
a module, and only if all extensions in the module are within version brackets. It is recommended that version numbers
be used. The ability to omit numbers and version brackets is for historical reasons. (Version brackets and version
numbers were not allowed in earlier versions of this Recommendation | International Standard.) (See also I.3.)
I.1.9      While the normal practice will be for extension additions to be added over time, the underlying ASN.1 model
and specification does not involve time. Two types are extension-related if one can be "grown" from the other by
extension additions. That is, one contains all the components of the other. There may be types that have to be "grown"
in the opposite direction (although this is unlikely). It could even be that, over time, a type starts with a lot of extension
additions which were progressively removed! All that ASN.1 and its encoding rules care about is whether a pair of type
specifications are extension-related or not. If they are, then all ASN.1 encoding rules will ensure interworking between
their users.
I.1.10    We start with a type and then decide whether we are going to want interworking with implementations of
earlier versions if we later have to extend it. If so, we include the extension marker now. We can then add later
extension additions to the type with defined handling of the extended values by earlier systems. It is, however,
important to note that adding an extension marker to a type that was previously without one (or removing an extension
marker) may prevent interworking.
      NOTE – When ECN is used, it can be possible to add extensions in version 2 at places that did not have extension markers in
      version 1, and still retain interworking between versions 1 and 2.

I.1.11    Table I.1 shows the ASN.1 types that can form the extension root type of an ASN.1 extension series, and the
nature of the single extension addition that is permitted for that type (multiple extension additions can of course be
made in succession, or together as an extension group).

                                                Table I.1 – Extension additions

   Extension root type                                           Nature of extension addition

ENUMERATED                    Addition of a single further enumeration at the end of the "AdditionalEnumeration"s, with an
                              enumeration value greater than that of any enumeration already added.
SEQUENCE and SET              Addition of a single type or extension addition group to the end of the "ExtensionAdditionList".
                              "ComponentType"s that are extension additions (not contained in an extension addition group) are not
                              required to be marked OPTIONAL or DEFAULT, although this will often be the case.
CHOICE                        Addition of a single "NamedType" to the end of the "ExtensionAdditionAlternativesList".
Constraint notation           Addition of a single "AdditionalElementSetSpec" to the "ElementSetSpecs" notation.


I.2         Meaning of version numbers
I.2.1    Version numbers are not used in BER or PER encodings. Their use (if any) in ECN encodings is determined
by the ECN specification.
I.2.2     Version numbers are most useful when they relate to the means of decoding a complete PDU, not to an
individual type. Where a type which is used as a component of several protocols and hence contributes to different
complete PDUs, an addition to that type will normally require that the version number for all the PDUs to which it
contributes be incremented.



150           Rec. ITU-T X.680 (02/2021)
                                                                                                  ISO/IEC 8824-1:2021 (E)

I.2.3     When used to provide interworking between deployed systems, version numbers should be used on extension
addition groups in such a way that deployed systems have knowledge of the syntax and semantics for all extension
addition groups with a given version number (no matter where they appear within the protocol), and of all extension
addition groups with an earlier version number. ECN specifiers will normally assume that version numbers have been
allocated (to all parts of types to which ECN is applied) in accordance with this principle.

I.3         Requirements on encoding rules
I.3.1     An abstract syntax can be defined as the values of a single ASN.1 type that is an extensible type. It then
contains all the values that can be obtained by the addition or removal of extension-additions. Such an abstract syntax is
called an extension-related abstract syntax.
I.3.2    A set of well-formed encoding rules for an extension-related abstract syntax satisfies the additional
requirements stated in I.3.3 to I.3.5.
      NOTE – All ASN.1 encoding rules satisfy these requirements.

I.3.3     The definition of the procedures for transforming an abstract value into an encoding for transfer, and for
transforming a received encoding into an abstract value shall recognize the possibility that the sender and receiver are
using abstract syntaxes that are not identical, but are extension-related.
I.3.4    In this case, the encoding rules shall ensure that where the sender has a type specification that is earlier in the
extension series than that of the receiver, values of the sender shall be transferred in such a way that the receiver can
determine that extension additions are not present.
I.3.5     The encoding rules shall ensure that where the sender has a type specification that is later in the extension
series than that of the receiver, transfer of values of that type to the receiver shall be possible.

I.4         Combination of (possibly extensible) constraints
I.4.1       Model
I.4.1.1 The basic ASN.1 model for applying constraints is simple: A type is a set of abstract values, and a constraint
applied to it selects a subset of those abstract values. If the unconstrained type was not extensible, then the resulting
type is defined to be extensible if and only if the applied constraint is defined to be extensible.
I.4.1.2 Even in this simple case, there is one feature to clarify: A type may be formally extensible, even though there
can never be any extension additions. Consider:
A ::= INTEGER (MIN .. MAX, ... , 1..10)

As with many examples in this annex, this is something that nobody would ever write, but which tool vendors have to
write code for because the ASN.1 standard has been left simple and general, and this example is therefore legal ASN.1.
In this example, A is formally an extensible INTEGER, with the full range of integer values in the root.
I.4.1.3     Complexities arise from three main sources:
            –    The application of a constraint to a type that has already had an extensible constraint applied to it (serial
                 application of constraints – see I.4.2).
            –    The combination of extensible constraints using UNION and INTERSECTION and EXCEPT (set arithmetic
                 – see I.4.3).
            –    The use of a typereference (a contained subtype) in the set arithmetic of a constraint, when the
                 typereference de-references to an extensible type (perhaps with actual extension additions – see I.4.4).

I.4.2       Serial application of constraints
I.4.2.1 Serial application of constraints occurs when a type is constrained (in an assignment to a typereference) and
the typereference is subsequently used with a further constraint applied to it.
I.4.2.2 It can also, but less commonly, occur when a type has multiple constraints directly applied to it in a serial
fashion. This latter form is used for many of the examples in this annex (for simplicity of exposition), but the case
where a typereference links the two (or more) constraints is the form in which serial application normally occurs in real
specifications.
I.4.2.3     There are two key points in the serial application of constraints:
            –    If a constrained type is extensible (and perhaps extended), the "extensible" flag and all extension
                 additions are discarded if a further constraint is subsequently serially applied. The extensibility of a
                 constrained type (and any extension additions) depends solely on the last constraint that is applied, which


                                                                                 Rec. ITU-T X.680 (02/2021)              151
ISO/IEC 8824-1:2021 (E)

                 can reference only values in the root of the type that is being further constrained (the parent type).
                 Values included in the root or the extension additions of the resulting type can only be values that are in
                 the root of the parent type.
          –      The serial application of constraints is (for complex cases) not the same as a set arithmetic intersection,
                 even when there is no extensibility involved. Firstly, the environment in which MIN and MAX are
                 interpreted, and secondly the abstract values that can be referenced in the second constraint are very
                 different in serial application from the situation where the two constraints are specified as an intersection
                 of values from a common parent.
   NOTE – Use of a range such as 20..28 in a constraint on an integer type is legal if (and only if) both 20 and 28 are in the (root
   of the) parent type, but the values referenced by this range specification are only those in (the root of) the parent. So if the parent
   has already been constrained to exclude the values 24 and 25, the range 20..28 is referencing only 20 to 23 and 26 to 28.

Here are some examples:
A1 ::= INTEGER (1..32, ... , 33..128)
          -- A1 is extensible, and contains values 1 to 128 with 1 to 32
          -- in the root and 33 to 128 as extension additions.
B1 ::= A1 (1..128)
          -- or equivalently
B1 ::= INTEGER (1..32, ... , 33..128) (1..128)
          -- These are illegal, as 128 is not in the parent, which
          -- lost its extension additions when it was further constrained
B2 ::= A1 (1..16)
          -- This is legal. B2 is not extensible, and contains 1 to 16.
A2 ::= INTEGER (1..32) (MIN .. 63)
          -- MIN is 1, and 63 is illegal
A3 ::= INTEGER ( (1..32) INTERSECTION (MIN..63) )
          -- This is legal. MIN is minus infinity and A3 contains 1 to 32

I.4.3     Use of set arithmetic
I.4.3.1 The results are largely intuitive, and obey the normal mathematical rules for intersection, union and set
difference (EXCEPT). In particular, both intersection and union are commutative, that is:
          ( <some set 1 of values> INTERSECTION <some set 2 of values> )

is the same as
( <some set 2 of values> INTERSECTION <some set 1 of values> )

similarly for UNION.
I.4.3.2 The commutativity is true, no matter what sets of values are extensible, and no matter what extension
additions are present.
I.4.3.3 Misunderstandings can arise if an intersection makes it impossible for extension addition values ever to occur.
This is similar to the case of INTEGER (MIN..MAX, ...).
I.4.3.4   For example:
          A ::= INTEGER (1..256, ... , B) (1..256)
          -- A always contains (only) the values 1..256, no matter what values
          -- B contains
I.4.3.5 It is also important to remember that while parents lose their extensibility and extension additions when
further constrained, and contained subtypes lose their extensibility and extension additions, sets of values directly
specified in set arithmetic lose neither their extensibility nor their extension additions.
I.4.3.6 The rules for extensibility of sets of values produced by set arithmetic are clearly stated in 50.4 and 50.5, and
do not depend on whether the set arithmetic makes actual extension additions possible or not.
I.4.3.7 The rules are summarized here for completeness, using E to denote a set of values with the "extensible" flag
set and N to denote a set values which are formally non-extensible. The values in the root of each set are denoted by R,
and the extension additions (if any) by X, and the contents of the result are shown for each case.
   NOTE 1 – For the purposes of this annex and for simplicity of exposition, if a set of values is not extensible, we describe all its
   values as root values.
   NOTE 2 – It is an illegal specification if the root of any resulting set of values used in a serially applied constraint is empty.


152           Rec. ITU-T X.680 (02/2021)
                                                                                                          ISO/IEC 8824-1:2021 (E)

    NOTE     3 – To avoid verbosity below, "Extensions" is used in place of the more correct "Extension additions".

I.4.3.8    The rules are:
           N1 INTERSECTION N2 => N
     Root: R1 INTERSECTION R2
N1 INTERSECTION E2 => E
     Root: R1 INTERSECTION R2, Extensions: R1 INTERSECTION X2
E1 INTERSECTION E2 => E
     Root: R1 INTERSECTION R2, Extensions: ((R1 UNION X1)
                             INTERSECTION
                             (R2 UNION X2))
                             EXCEPT
                             (R1 INTERSECTION R2)
N1 UNION N2 => N
     Root: R1 UNION R2
N1 UNION E2 => E
     Root: R1 UNION R2, Extensions: X2
E1 UNION E2 => E
     Root: R1 UNION R2, Extensions: (R1 UNION X1 UNION R2 UNION X2)
                         EXCEPT
                         (R1 UNION R2)
N1 EXCEPT N2 => N
     Root: R1 EXCEPT R2
N1 EXCEPT E2 => N
     Root: R1 EXCEPT R2
E1 EXCEPT N2 => E
     Root: R1 EXCEPT R2, Extensions: (X1 EXCEPT R2)
                          EXCEPT
                          (R1 EXCEPT R2)
E1 EXCEPT E2 => E
     Root: R1 EXCEPT R2, Extensions: (X1 EXCEPT (R2 UNION X2) )
                          EXCEPT
                          (R1 EXCEPT R2)
N1 ... N2 => E
     Root: R1, Extensions: R2 EXCEPT R1
E1 ... N2 => E
     Root: R1, Extensions: X1 UNION R2
                   EXCEPT
                   R1
N1 ... E2 => E
     Root: R1, Extensions: R2 UNION X2
                   EXCEPT
                   R1
E1 ... E2 => E
     Root: R1, Extensions: X1 UNION R2 UNION E2
                   EXCEPT
                   R1
    NOTE – If the result of set arithmetic on extensible sets of values does not have actual extension additions, or even can never
    have actual extension additions (no matter what extension additions are added to the extensible inputs), the result is still formally
    defined to be extensible for results E above.

I.4.4      Use of the Contained Subtype notation
A contained subtype may or may not be extensible, but when it is used in set arithmetic it is always treated as not
extensible, and all its extension additions are discarded.




                                                                                       Rec. ITU-T X.680 (02/2021)                   153
ISO/IEC 8824-1:2021 (E)



                                                       Annex J

                                       Tutorial annex on the TIME type

             (This annex does not form an integral part of this Recommendation | International Standard.)

J.1      The collections of ASN.1 types for times and dates
J.1.1     Historically, ASN.1 defined its own time type, UTCTime, as a "UsefulType", because it was based on
specifying the contents of a VisibleString type. Later, GeneralizedTime was added, allowing a four-digit year,
and defined by reference to a set of standards that were the predecessors of the first (1988) version of ISO 8601, to
specify the contents of a VisibleString. (The other "UsefulType", defined by specifying the contents of a
GraphicString, was ObjectDescriptor.) Traditionally, the so-called "UsefulType"s have used mixed upper-case
and lower-case letters for their type reference names, with the other built-in ASN.1 types using only upper-case letters.
The useful types have, however, their own UNIVERSAL class tags, and can be referenced independently in Encoding
Rules specifications.
J.1.2     While these types (UTCTime, GeneralizedTime and ObjectDescriptor) are undoubtedly useful, the
separation of them from other types by the term "UsefulType"s (simply because they are defined in terms of other –
character string – types), and the use of mixed upper-case and lower-case in their type reference names has been
increasingly recognized as a historical accident.
J.1.3      With the introduction of time types to support the 2004 version of ISO 8601, it was recognized that a primary
time type (TIME) was needed, but that a number of commonly useful time types (DATE, TIME-OF-DAY, DATE-TIME and
DURATION), defined as subsets of the basic TIME type (using the ASN.1 subtype notation), were needed. A decision was
taken to call these "Useful time types", and to give them names that were all upper-case, in order to minimize
backwards compatibility problems, as they are new reserved words. They all have distinct UNIVERSAL class tags that
are distinct from the tag of the TIME type (to enable optimized BER encodings), and are all listed under the production
"BuiltinType" (see 17.2).

J.2      ISO 8601 key concepts
J.2.1     ISO 8601 provides the definitive reference for identification of instants of time and for their character
representation. It forms the basis for the specification of the ASN.1 TIME type, both in terms of time-related concepts
and in terms of actual representations used in ASN.1 value notation and in the Basic Encoding Rules (BER).
J.2.2      ISO 8601 is based entirely on the Gregorian calendar introduced in 1582, together with the so-called proleptic
Gregorian calendar that extends the Gregorian calendar sequentially backwards in time from 1582, using the normal
rules for the definition of common (non-leap) years and leap years. There is in general no easy way to determine a date
AD or BC using the Julian calendar from a date specified using the proleptic Gregorian calendar, but in particular the
year 1 AD is roughly (but not exactly) in alignment with year 1 proleptic Gregorian, and the year 1 BC (the preceding
year) is roughly (but not exactly) in alignment with year 0 proleptic Gregorian.
J.2.3     Key definitions and concepts in ISO 8601 include the concept of multiple time scales for the time axis. Each
time scale consists of an ordered set of marks on the time axis. Each mark represents a time (an instant of time).
J.2.4    Three main time-scales are defined in ISO 8601.
J.2.4.1 The first is called the calendar date time scale. This has marks corresponding to calendar years, calendar
months, and the ordinal number of a day within its calendar month (days are numbered 01 to 28, 29, 30 or 31,
depending on the month).
J.2.4.2 The second is called the ordinal date time scale. This has marks corresponding to calendar years, and the
ordinal number of a day within its calendar year (days are numbered 001 for Jan. 1st to 365 or 366, depending on the
year).
J.2.4.3 The third is called the week date time scale. This has marks corresponding to calendar years, the ordinal
number of a week within that calendar year, and the ordinal number of a day within that week (with day 1 being
Monday). Weeks are numbered 01 to 52 or 53 (depending on the year), with week 01 being defined as the week
containing Jan. 4th, and the last week of the previous year being defined as the previous week to that (which is why
some years contain 53 weeks).



154        Rec. ITU-T X.680 (02/2021)
                                                                                                          ISO/IEC 8824-1:2021 (E)

J.2.5    Between the day marks on each time scale are hour, minute, and second marks. However, the time axis is a
continuum of instants of time, and all three of the time scales also contain marks that are everywhere dense on the time
axis.
      NOTE – Another way of expressing this is to say that between any two marks there are infinitely more other marks, each
      identifying a decimal fraction of a second to arbitrarily large accuracy.

J.2.6     A variation on the calendar date time scale is a time scale in which seconds are not represented, but between
each minute time are infinitely more other marks representing decimal fractions of that minute to arbitrarily large
accuracy. The same is true for decimal fractions of an hour.
      NOTE – There is no concept in ISO 8601 of specifying a time using decimal fractions of a day or any larger unit of time,
      although decimal fractions of a year, a month, a week or a day can be used in specifying a duration.

J.2.7     Because the rational number 1/60 does not have a terminating decimal representation, there are some times on
the time scale using seconds that cannot be expressed as times on the time scale using fractions of a minute, in any finite
representation.
J.2.8     Similarly, it is not possible to identify which mark for a day on one time scale corresponds to the mark for a
day on a different time scale, without knowledge of which years are leap years. A similar problem arises with leap
seconds with the identification of time intervals using scales based on a start point and an end point, or on a start point
and a duration (in seconds, say), or on a duration and an end point.
J.2.9     ISO 8601 also recognizes the concept of identification of marks with varying accuracy. Thus, on any given
time scale there can be different marks at the same time, one specifying it as (for example) 3.100 seconds and the other
specifying it as 3.1 seconds.
      NOTE – In earlier ASN.1 work on time types (UTCTime and GeneralizedTime), the issue of having separate abstract values for
      the same time expressed with different accuracies was not addressed. In the case of the TIME type, marks on the time axis that
      have different accuracy, but that are placed at the same time, are firmly identified as distinct abstract values. Thus an abstract
      value that might be represented by 3.100 is distinct from one that might be represented by 3.1, and may carry different
      application semantics.

J.2.10 Control of the accuracy used, and of some other aspects of ISO 8601, is stated in ISO 8601 to be "by mutual
agreement". In general, where ISO 8601 identifies areas requiring mutual agreement, notations are provided in ASN.1
for an application designer to specify in the ASN.1 type definition the mutual agreements that are to be assumed. This is
done by selecting subsets of the multiple infinities of abstract values in the TIME type, using time properties associated
with each time abstract value.
J.2.11 ISO 8601 recognizes the concept of time difference. This is the difference between local time of day and UTC
for a particular World Time Zone. There is no international authority for agreement on or recording of time differences
for different World Time Zones. This is a matter for local administrations, although HM Nautical Almanac Office (UK)
attempts to maintain an authoritative record of currently assigned time differences for all parts of the world. As at 2005,
time differences in the range –12 to +14 have been defined by various local administrations. To allow for possible
future changes, ASN.1 supports time differences in the range –15 to +16 (only).

J.3          Abstract values of the TIME type
J.3.1     Each mark on each time scale, with each accuracy, is identified as a distinct abstract value of the TIME type,
and thus has a distinct ASN.1 value notation and distinct encodings in all ASN.1 Encoding Rules.
J.3.2     ISO 8601 is predominantly concerned with the identification of times, but distinguishes between identification
of date only, of time of day only, and of date and time. These different identifications also produce distinct abstract
values in the TIME type.
J.3.3      Within the identification of time of day, local time of day or UTC or both can be used. Again, these different
identifications produce distinct and unrelated abstract values because of the different time scales that are being used
(and will generally carry different application semantics).
J.3.4     Another feature of ISO 8601 is the identification of time intervals using either a start and end point (which
can be identified using any of the various time scales), a duration, or a duration with either a start or an end point.
Again, these provide four main sets of abstract values that are distinct from abstract values representing times, but with
many subsets of those main sets of time intervals, depending on the abstract values used in the specification of the start
and end point of the time interval, or the time components used in specifying a duration.
      NOTE – In ASN.1, it is not possible to use different time scales for the start point and end point of a time interval. This is for
      simplicity of specification, and is not expected to be a problem for application designers.

J.3.5     Finally, ISO 8601 has the concept of specifying a recurring time interval. Recurring time intervals map into
abstract values that are distinct from those representing time intervals and times.



                                                                                        Rec. ITU-T X.680 (02/2021)                 155
ISO/IEC 8824-1:2021 (E)

J.4          Time properties of the time abstract values
J.4.1     It is possible to identify sets of time abstract values that have common time properties. Some time properties
(such as whether it is a time, a time interval, or a recurring time interval) apply to all time abstract values. Other time
properties, such as whether a time interval is expressed as a start point and a duration, or by a duration and an end point
(for example), apply only to time abstract values that are time intervals. Similarly, the time property indicating whether
a time abstract value represents local time of day, UTC or both, applies only to time abstract values with at least one
component related to time-of-day.
J.4.2     Clause 38.2 and Table 6 specify the complete set of time properties that can be associated with a time abstract
value, and the possible settings for each of those time properties. The setting of a time property can be used in the
subtype notation to select subsets of the TIME type, all of whose abstract values have the same setting for a given time
property.
      NOTE – The term "setting of a time property" rather than "value of a time property" is used to avoid confusion with the use of
      "value" in the term "abstract value".

J.4.3     The presence of some time properties on a time abstract value is dependent on the setting of other time
properties, as outlined above.
J.4.4     In the subtype notation, abstract values of the TIME type are specified using a list of time property and setting
pairs. There are restrictions on the combinations of time properties and settings that can be specified (see 51.10.6), but
the order of the property and setting pairs does not matter (but see J.4.5). An abstract value of the TIME type is included
in the subtype if and only if it has the specified setting for all the listed properties that are applicable to it. As usual, it is
an illegal ASN.1 specification if the resulting set of abstract values assigned to a type reference is empty (although
empty sets are not prohibited in set arithmetic).
J.4.5     To provide clarity for human readers, and to avoid errors, it is recommended, but not required, that the order
of specification of property and setting pairs proceeds from major properties (such as "Basic=Date-Time") to more
detailed properties (such as "TIME=HMS"). This would generally mean a specification of time property and setting pairs
in the order of Table 6. This convention is used in all examples in this Recommendation | International Standard (see
38.4, G.3 and G.5.8).
J.4.6      It is important for interval specification, and for subtyping using value ranges, to have an order relationship on
the abstract values of the TIME type. In general, there is an order relationship between abstract values representing times
(based on their position on the time axis) if, and only if, they all have the same time property settings. Similarly, the
number of seconds between two time abstract values can in general only be determined if they have the same property
settings. This means that times used in some of the subtype notations and in interval specification are required to have
the same property settings. An order relationship is defined for durations only if they have the same accuracy and differ
only in a single time componentent (see 51.11).

J.5          Value notation
J.5.1      The value notation (and encoding) for an abstract value depends on its associated time properties and their
settings. The value notation is specified in 38.3.
J.5.2    ISO 8601 in general specifies two separate (character-based) representations, called a basic format and an
extended format, for identifying marks in a time scale.
J.5.3    In general, the basic format is a simple string of digits, with non-digit separators (such as a decimal separator)
only where needed to provide unambiguous representations within commonly useful subsets of the abstract values
implied by ISO 8601. This format is not used by ASN.1 value notation.
      NOTE – For example, in the basic format, the string 2020 represents both the year 2020 and also the time 8:20 pm.

J.5.4     The extended format contains additional non-digit separators designed to make the representation more
readable for human users, and is generally (but with one exception – see Note 1 below) unambiguous over all the
abstract values implied by ISO 8601. The extended format is recommended by ISO 8601 for use in plain text.
      NOTE 1 – The exception is the representation of a date that is four digits representing a century, which can be confused with four
      digits representing a year. In the ASN.1 value notation, a C is added to the century notation, for all century representations,
      including two-digit representations, to resolve the ambiguity.
      NOTE 2 – For example, in the extended format, the year 2020 would be represented by 2020, but the time 8:20 pm would be
      represented by 20:20.

J.5.5     The use of the extended format (with the added upper-case C for centuries) enables the property settings of the
abstract value being represented to be determined from the value notation, and that notation unambiguously identifies
an abstract value, knowing only that its type is the TIME type.




156           Rec. ITU-T X.680 (02/2021)
                                                                                                           ISO/IEC 8824-1:2021 (E)

J.5.6     The basic format requires knowledge of some of the property settings of the abstract value that is being
represented, in order to resolve ambiguity in the representations, and is not used in ASN.1.
J.5.7      The basic ASN.1 value notation and the XML value notation (specified in 38.3), and the XML Encoding
Rules specified in Rec. ITU-T X.693 | ISO/IEC 8825-4, use the ISO 8601 extended format. The Basic Encoding Rules
specified in Rec. ITU-T X.690 | ISO/IEC 8825-1 use the ISO 8601 extended format (but with the removal of some
designators and separators – such as P for duration, colons in time-of-day, and hyphens in dates). Different ASN.1 tags
are assigned to the useful types to enable BER to identify property settings that are needed to resolve what would
otherwise be ambiguity in the encoding of the useful time types. The Packed Encoding Rules specified in Rec. ITU-T
X.691 | ISO/IEC 8825-2 use a binary encoding that is unrelated to (and out of the scope of) ISO 8601. PER encodings
provide very compact representations of date, time and duration (typically 17 bits for a date, 15 bits for a time, 32 bits
(4 octets) for a date-time, and often less than 16 bits for a duration).

J.6          Use of the ASN.1 subtype notation
J.6.1     Six forms of subtype notation (plus inner subtyping in restricted cases – see J.6.8) are permitted for this type
(see clause 51 and Table 12).
      NOTE – Examples of subtype notation for the TIME type and the useful time types can be found in 38.4, G.3 and G.5.8.

J.6.2     A property settings subtype notation allows the selection of all abstract values with a given setting for one or
more listed time properties. This is the normal means of producing additional customized time types for applications,
and is discussed more fully in J.7.
J.6.3        Single value subtypes are permitted, but are not expected to be generally useful.
J.6.4     Contained subtypes are permitted, and are expected to be commonly used in the specification of customized
time types by application designers.
J.6.5     Duration range subtypes (containing an ordered pair of durations) can be applied. They select from the parent
type only those abstract values that are time intervals specified as a duration, and constrain the duration to the specified
range (see 51.11).
J.6.6    Time point range subtypes (containing an ordered pair of times) can be applied. They select from the parent
type only those abstract values that are times with the same property settings as the two ends of the time point range
(which are required to have the same property settings), and constrain the time to be within the specified range.
      NOTE – This subtype constraint restricts the range of values of a time and is totally separate from the direct use of value notation
      to identify a single time abstract value that is a time interval.

J.6.7     Recurrence range subtypes (containing an ordered pair of integers) can be applied. They select from the
parent type only those abstract values that are recurring time intervals and constrain the number of digits that can be
used to specify the number of recurrences.
J.6.8    Inner subtyping can be applied if the time type has already been restricted to a duration (typically by use of
the DURATION useful time type). This enables restrictions to be placed on the form of a duration specification.
J.6.9        No other forms of subtype constraint are permitted.

J.7          The property settings subtype notation
J.7.1      Time abstract values that have the same setting for a given time property form natural subsets of the time
type. The property settings subtype notation enables the selection of abstract values by listing the setting of one or more
time properties. An abstract value is included in the resulting subtype if, and only if, it has the specified setting for all
the listed properties that are applicable to it.
EXAMPLE: The following notation can be used to define a time subtype that contains all abstract values that are a date
only, specified using a four-digit year, week-of-the-year, and day:
             My-time ::= TIME (SETTINGS "Basic=Date Date=YWD Year=Basic")

A more extensive set of examples of the subtype notation is given in 38.4, G.3 and G.5.8.
J.7.2     ASN.1 set arithmetic (or simply application of multiple constraints) can be used in the normal way to define
combinations (using INTERSECTION, UNION and EXCEPT) of time subtypes, to produce types that are appropriate for
use in a particular application.
J.7.3     The time properties, their names, possible settings, and the abstract values that have this setting are specified
in Table 6.



                                                                                         Rec. ITU-T X.680 (02/2021)                  157
ISO/IEC 8824-1:2021 (E)

J.7.4     A small number of useful time subtypes are specified using the property settings subtype notation (see 38.4),
and are given human-friendly names. It is expected that these useful subtypes (DATE, TIME-OF-DAY, DATE-TIME, and
DURATION) will be sufficient for many applications. A more extensive set of defined time types of general utility are
specified in the ASN.1 defined time types module in Annex B. These types can be imported and used, either directly, or
to define application-specific time types. They support the full functionality of ISO 8601. Additionally, where
necessary, designers can define additional types as subtypes of the TIME type or the useful or defined time types using
the property setting subtype notation. These types can be further combined using ASN.1 set arithmetic.
   NOTE – The useful time types have been given ASN.1 UNIVERSAL class tags that are different from the TIME type in order to
   permit efficient encodings in BER. They should be regarded as independent types rather than as subtypes, but can also be used in
   a contained subtype constraint if the parent type is TIME.




158        Rec. ITU-T X.680 (02/2021)
                                                                                                        ISO/IEC 8824-1:2021 (E)



                                                            Annex K

                                         Analyzing TIME type value notation

               (This annex does not form an integral part of this Recommendation | International Standard.)

K.1       General
K.1.1    The body of this Recommendation | International Standard specifies the value notation for abstract values
with given time properties.
K.1.2     Every instance of this value notation unambiguously identifies a single abstract value of the time type, and its
properties.
K.1.3     This informative annex describes one possible algorithm for determining the time property settings of the
abstract value that is represented by an instance of the value notation. There are many alternative (and probably better)
algorithms, and this annex is provided simply as a demonstration that such algorithms exist.
   NOTE – If this algorithm is applied to a random string, it will identify that the string can only represent an abstract value with a
   given set of time property settings. It is then necessary to check that the syntax of the string conforms to that required for an
   abstract value with those property settings before the notation can be accepted and the abstract value identified.

K.1.4      If two abstract values have the same property settings, then their value notation differs only in the values of
the digits present in the notation, with the following exceptions:
          a)    there are several different representations of duration abstract values, depending on which time units are
                being used, and on whether decimal fractions are being used;
          b)    either comma or full stop can be used as decimal separators;
          c)    a time difference component that is an integral number of hours may be expressed with hours only or
                with hours and minutes;
          d)    the end point of an interval expressing UTC may omit the time difference component if the time
                difference is the same as the time difference on the start point;
          e)    abstract values that differ only by having a plus or a minus for the time difference component
                nonetheless have the same time properties.
K.1.5     If two strings differ only in the actual value of the digits present in the strings, then they have the same
property settings with the exceptions that the use of year dates in the range 0000 to 1581 means that the date has the
property setting "Year=Proleptic" and not "Year=Basic" (similarly for century notation).

K.2       Analyzing the full string
K.2.1     If the string commences with an LATIN CAPITAL LETTER R, then it has the property setting "Basic=Rec-
Interval". The "R" will be followed by a number of recurrences (empty string for unbounded), then a SOLIDUS ("/").
If the portion of the string after "R" and before "/" is empty, then it has the property setting
"Recurrence=Unlimited". Otherwise, if the number of digits in the portion of the string after "R" and before "/" is 1,
2, 3, etc., then it has the property setting "Recurrence=R1", "Recurrence=R2", "Recurrence=R3", etc. The
remainder of the string can be analyzed as a string containing an interval (see K.3) to determine additional property
settings.
K.2.2    Otherwise, if the string contains a solidus ("/"), then it has the property setting "Basic=Interval", and can
be analyzed as a string containing an interval (see K.3) to determine additional property settings.
K.2.3     Otherwise, if the string commences with a LATIN CAPITAL LETTER P, then it has the settings
"Basic=Interval" and "Interval-type=D", completing the analysis of properties.

K.2.4     Otherwise, if the string contains a LATIN CAPITAL LETTER T, then it has the property setting
"Basic=Date-Time", and the portion of the string before the "T" can be analyzed as a string containing a date (see
K.4) and the portion following the "T" can be analyzed as a string containing a time (see K.7) to determine further
property settings.
K.2.5     Otherwise, if the string ends in a LATIN CAPITAL LETTER C, then it has the property setting
"Basic=Date" and "Date=C" and can be analyzed as a string containing a century (see K.6) to determine further
property settings.

                                                                                      Rec. ITU-T X.680 (02/2021)                  159
ISO/IEC 8824-1:2021 (E)

K.2.6     Otherwise, if the string contains a COLON (":"), or has less than four characters, or has more than four
characters with the third character being a PLUS ("+") or HYPHEN-MINUS ("-"), then it has the property setting
"Basic=Time" and can be analyzed as a string containing a time (see K.7) to determine further property settings.

K.2.7     Otherwise, it has the property setting "Basic=Date" and can be analyzed as a string containing a date
(see K.4) to determine further property settings.

K.3       Analysis of a string containing an interval
K.3.1     If the string begins with a LATIN CAPITAL LETTER P and does not contain a SOLIDUS ("/"), then it has
the property setting "Interval-type=D", completing the analysis of properties.
K.3.2     If the string contains a SOLIDUS, then either the portion of the string before the solidus or the portion after
the solidus will commence with a LATIN CAPITAL LETTER P, or neither will commence with a "P" (but not both). If:
          a)   the portion before the SOLIDUS begins with a "P" then it has the property setting "Interval-
               type=DE", and may have further properties by analyzing the portion after the SOLIDUS as specified in
               subsequent subclauses of this K.3;
          b)   the portion after the SOLIDUS begins with a "P" then it has the property setting "Interval-type=SD",
               and may have further properties by analyzing the portion before the SOLIDUS as specified in subsequent
               subclauses of this K.3;
          c)   if neither portion begins with a "P" then it has the property setting "Interval-type=SE", and may have
               further properties by analyzing the portion before the SOLIDUS as specified in subsequent subclauses of
               this K.3.
                   NOTE – There is a requirement in ASN.1 (but not in ISO 8601) that the end point have the same time property
                   settings as the start point. This means that the end point portion of the string does not need to be analyzed in the
                   determination of property settings. It should, however, be noted that there are permitted representations of the
                   end point that omit the time difference component if it is the same as the time difference in the start point. This
                   needs to be considered when determining the abstract value of the end point.

K.3.3     If the portion contains a LATIN CAPITAL LETTER T, then it has the property setting
"SE-point=Date-Time", and the part of the portion before the "T" can be analyzed as a string containing a date (see
K.4) and the part following the "T" can be analyzed as a string containing a time (see K.7) to determine further property
settings.
K.3.4   If the portion ends in a LATIN CAPITAL LETTER C, then it has the property settings "SE-point=Date
Date=C" and can be analyzed as a string containing a century (see K.6) to determine further property settings.

K.3.5    Otherwise, if the portion contains a COLON (":"), then it has the property setting "SE-point=Time", and it
can be analyzed as a string containing a time (see K.7) to determine further property settings.
K.3.6     Otherwise, it has the property setting "SE-point=Date", and it can be analyzed as a string containing a date
(see K.4) to determine further property settings.

K.4       Analysis of a string containing a date
K.4.1      If the string ends in a LATIN CAPITAL LETTER C, then it has the property setting "Date=C" and the rest of
the string can be analyzed as a string containing a century (see K.6).
K.4.2    If the string begins with a HYPHEN-MINUS ("-"), this should be ignored for the analysis in the rest of this
subclause K.4.
   NOTE – In this case, the hyphen represents a minus sign, not a separator.

K.4.3    Otherwise, the string will contain zero, one, or two HYPHEN-MINUS ("-") characters, and in the last two
cases may or may not contain a LATIN CAPITAL LETTER W.
K.4.4     If the string does not contain a LATIN CAPITAL LETTER W, then if:
          a)   the string contains no HYPHEN-MINUS characters, it has the property setting "Date=Y" and can be
               analyzed as a string containing a year (see K.5) to determine further property settings;
          b)   the string contains one HYPHEN-MINUS character, it has the property setting "Date=YM"; two digits
               for the month will follow the HYPHEN-MINUS and the portion before the HYPHEN-MINUS can be
               analyzed as a string containing a year (see K.5) to determine further property settings;
          c)   the string contains two HYPHEN-MINUS characters, it has the property setting "Date=YMD"; two digits
               for the month will follow the first HYPHEN-MINUS, two digits for the day will follow the second



160        Rec. ITU-T X.680 (02/2021)
                                                                                                       ISO/IEC 8824-1:2021 (E)

               HYPHEN-MINUS, and the portion of the string before the first HYPHEN-MINUS can be analyzed as a
               string containing a year (see K.5) to determine further property settings.
K.4.5     If the string contains a LATIN CAPITAL LETTER W, then if:
          a)   the string contains one HYPHEN-MINUS character, it has the property setting "Date=YW"; two digits
               for the week will follow the HYPHEN-MINUS and the portion before the HYPHEN-MINUS can be
               analyzed as a string containing a year (see K.5) to determine further property settings.
          b)   If the string contains two HYPHEN-MINUS characters, it has the property setting "Date=YWD"; two
               digits for the week will follow the first HYPHEN-MINUS, one digit for the day will follow the second
               HYPHEN-MINUS, and the portion of the string before the first HYPHEN-MINUS can be analyzed as a
               string containing a year (see K.5) to determine further property settings.

K.5       Analysis of a string containing a year
K.5.1     If the string commences with a HYPHEN-MINUS ("-") character, and is five characters, then it has the
property setting "Year=Negative", completing the analysis of properties.
K.5.2       Otherwise, if the string is more than four characters and does not commence with a HYPHEN-MINUS ("-")
character, it has the property setting "Year=L5", "Year=L6", "Year=L7", etc., for a number of characters equal to 5,
6, 7, etc., respectively.
K.5.3      Otherwise, if the string is more than four characters and commences with a HYPHEN-MINUS ("-") character,
it has the property setting "Year=L5", "Year=L6", "Year=L7", etc., for a number of characters equal to 6, 7, 8, etc.,
respectively.
K.5.4     Otherwise, if the value of the four-digit string is less than 1582, then it has the property setting
"Year=Proleptic", completing the analysis of properties.

K.5.5     Otherwise, it has the property setting "Year=Basic", completing the analysis of properties.

K.6       Analysis of a string containing a century
K.6.1     If the string commences with a HYPHEN-MINUS ("-") character, and is three characters, it has the property
setting "Year=Negative", completing the analysis of properties.
K.6.2       Otherwise, if the string is more than two characters and does not commence with a HYPHEN-MINUS ("-")
character, it has the property setting "Year=L5", "Year=L6", "Year=L7", etc., for a number of characters equal to 3,
4, 5, etc., respectively.
K.6.3      Otherwise, if the string is more than two characters and commences with a HYPHEN-MINUS ("-") character,
it has the property setting "Year=L5", "Year=L6", "Year=L7", etc., for a number of characters equal to 4, 5, 6, etc.,
respectively.
K.6.4    Otherwise, if the value of the two-digit string is less than 15, it has the property setting "Year=Proleptic",
completing the analysis of properties.
K.6.5     Otherwise, it has the property setting "Year=Basic", completing the analysis of properties.

K.7       Analysis of a string containing a time
K.7.1     If the string ends in a LATIN CAPITAL LETTER Z then it has the property setting "Local-or-UTC=Z", and
the portion of the string before the "Z" can be analyzed as a string containing a simple time (see K.8) to determine
further property settings.
K.7.2     Otherwise, if the string contains a plus ("+") or a minus ("-") then it has the property
"Local-or-UTC=LD", and the portion of the string before the plus or minus can be analyzed as a simple time (see K.8)
to determine further property settings.
   NOTE – Analysis of the portion of the string following the plus or minus (a time differential) is not needed for the determination
   of property settings.

K.7.3    Otherwise, it has the property "Local-or-UTC=L" and can be analyzed as a simple time (see K.8) to
determine further property settings.




                                                                                     Rec. ITU-T X.680 (02/2021)                 161
ISO/IEC 8824-1:2021 (E)

K.8      Analysis of a string containing a simple time
K.8.1   The string will contain zero, one or two colons (:) and may contain a decimal sign, which is a full stop (".") or
comma (",").
K.8.2    If the string does not contain a decimal sign, then if:
         a)   the string does not contain a colon, it has the property setting "Time=H", completing the analysis of
              properties;
         b)   the string contains one colon, it has the property setting "Time=HM", completing the analysis of
              properties;
         c)   the string contains two colons, it has the property setting "Time=HMS", completing the analysis of
              properties.
K.8.3    If the string contains a decimal sign, then if:
         a)   the string does not contain a colon, it has the property setting "Time=HF1", "Time=HF2", "Time=HF3",
              etc., if the number of digits after the decimal sign is 1, 2, 3, etc., respectively, completing the analysis of
              properties;
         b)   the string contains one colon, it has the property setting "Time=HMF1", "Time=HMF2", "Time=HMF3",
              etc., if the number of digits after the decimal sign is 1, 2, 3, etc., respectively, completing the analysis of
              properties;
         c)   the string contains two colons, then it has the property setting "Time=HMSF1", "Time=HMSF2",
              "Time=HMSF3", etc., if the number of digits after the decimal sign is 1, 2, 3, etc., respectively,
              completing the analysis of properties.




162        Rec. ITU-T X.680 (02/2021)
                                                                                            ISO/IEC 8824-1:2021 (E)



                                                        Annex L

                                       Summary of the ASN.1 notation
             (This annex does not form an integral part of this Recommendation | International Standard.)


The following lexical items are defined in clause 12:




                                                                           Rec. ITU-T X.680 (02/2021)          163
ISO/IEC 8824-1:2021 (E)

                                      "("                    EXPLICIT
typereference
                                      ")"                    EXPORTS
identifier
                                      "["                    EXTENSIBILITY
valuereference
                                      "]"                    EXTERNAL
modulereference
                                      "-" (HYPHEN-MINUS)     FALSE
comment
                                      ":"                    FROM
empty
                                      "="                    GeneralizedTime
number
                                      """ (QUOTATION MARK)   GeneralString
realnumber
                                                             GraphicString
bstring                               "'" (APOSTROPHE)
                                                             IA5String
xmlbstring                            " " (SPACE)
                                                             IDENTIFIER
hstring                               ";"
                                                             IMPLICIT
xmlhstring                            "@"
                                                             IMPLIED
cstring                               "|"
                                                             IMPORTS
xmlcstring                            "!"
                                                             INCLUDES
simplestring                          "^"
                                                             INSTANCE
tstring                               ABSENT
                                                             INSTRUCTIONS
xmltstring                            ABSTRACT-SYNTAX
                                                             INTEGER
                                      ALL
psname                                                       INTERSECTION
                                      APPLICATION
"::="                                                        ISO646String
                                      AUTOMATIC
".."                                                         MAX
                                      BEGIN
"..."                                                        MIN
                                      BIT
"[["                                                         MINUS-INFINITY
                                      BMPString
"]]"                                                         NOT-A-NUMBER
                                      BOOLEAN
encodingreference                                            NULL
                                      BY
integerUnicodeLabel                                          NumericString
                                      CHARACTER
non-integerUnicodeLabel                                      OBJECT
                                      CHOICE
"</"                                                         ObjectDescriptor
                                      CLASS
"/>"                                                         OCTET
                                      COMPONENT
"true"                                                       OF
                                      COMPONENTS
extended-true                                                OID-IRI
                                      CONSTRAINED
"false"                                                      OPTIONAL
                                      CONTAINING
extended-false                                               PATTERN
                                      DATE
"NaN"                                                        PDV
                                      DATE-TIME
"INF"                                                        PLUS-INFINITY
                                      DEFAULT
xmlasn1typename                                              PRESENT
                                      DEFINITIONS
"{"                                                          PrintableString
                                      DURATION
"}"                                                          PRIVATE
                                      EMBEDDED
"<"                                                          REAL
                                      ENCODED
">"                                                          RELATIVE-OID
                                      ENCODING-CONTROL
","                                                          RELATIVE-OID-IRI
                                      END
"."                                                          SEQUENCE
                                      ENUMERATED
"/"                                                          SET
                                      EXCEPT


164          Rec. ITU-T X.680 (02/2021)
                              ISO/IEC 8824-1:2020 (E)
SETTINGS
SIZE
STRING
SYNTAX
T61String
TAGS
TeletexString
TIME
TIME-OF-DAY
TRUE
TYPE-IDENTIFIER
UNION
UNIQUE
UNIVERSAL
UniversalString
UTCTime
UTF8String
VideotexString
VisibleString
WITH




                  Rec. ITU-T X.680 (02/2021)     165
      ISO/IEC 8824-1:2020 (E)

The following productions are used in this Recommendation | International Standard, with the above lexical items as
terminal symbols:
              ModuleDefinition ::=
                 ModuleIdentifier
                   DEFINITIONS
                   EncodingReferenceDefault
                   TagDefault
                   ExtensionDefault
                   "::="
                   BEGIN
                   ModuleBody
                   EncodingControlSections
                   END

              ModuleIdentifier ::=
                 modulereference
                 DefinitiveIdentification
              DefinitiveIdentification ::=
                  DefinitiveOID
              |   DefinitiveOIDandIRI
              |   empty
              DefinitiveOID ::=
                  "{" DefinitiveObjIdComponentList "}"
              DefinitiveOIDandIRI ::=
                        DefinitiveOID
                  IRIValue
              DefinitiveObjIdComponentList ::=
                  DefinitiveObjIdComponent
              |   DefinitiveObjIdComponent DefinitiveObjIdComponentList
              DefinitiveObjIdComponent ::=
                  NameForm
              |   DefinitiveNumberForm
              |   DefinitiveNameAndNumberForm
              DefinitiveNumberForm           ::= number
              DefinitiveNameAndNumberForm ::= identifier "(" DefinitiveNumberForm ")"
              EncodingReferenceDefault ::=
                      encodingreference INSTRUCTIONS
                  |   empty
              TagDefault ::=
                   EXPLICIT TAGS
              |    IMPLICIT TAGS
              |    AUTOMATIC TAGS
              |    empty
              ExtensionDefault ::=
                   EXTENSIBILITY IMPLIED
              |    empty
              ModuleBody ::=
                 Exports Imports AssignmentList
              |  empty
              Exports ::=
                   EXPORTS SymbolsExported ";"
              |    EXPORTS ALL ";"
              |    empty
              SymbolsExported ::=
                 SymbolList

166        Rec. ITU-T X.680 (02/2021)
                                                                   ISO/IEC 8824-1:2020 (E)

    |   empty
    Imports ::=
        IMPORTS SymbolsImported ";"
    |   empty
    SymbolsImported ::=
       SymbolsFromModuleList
    |  empty
    SymbolsFromModuleList ::=
       SymbolsFromModule
    |  SymbolsFromModuleList SymbolsFromModule
    SymbolsFromModule ::=
       SymbolList FROM GlobalModuleReference SelectionOption
    SelectionOption ::=
         empty
    |    WITH "SUCCESSORS"
    |    WITH "DESCENDANTS"

    GlobalModuleReference ::=
        modulereference AssignedIdentifier
    AssignedIdentifier ::=
        ObjectIdentifierValue
    |   DefinedValue
    |   empty
    SymbolList ::=
       Symbol
    |  SymbolList "," Symbol
    Symbol ::=
       Reference
    |  ParameterizedReference
    Reference ::=
        typereference
    |   valuereference
    |   objectclassreference
    |   objectreference
    |   objectsetreference
    AssignmentList ::=
        Assignment
    |   AssignmentList Assignment
    Assignment ::=
        TypeAssignment
    |   ValueAssignment
    |   XMLValueAssignment
    |   ValueSetTypeAssignment
    |   ObjectClassAssignment
    |   ObjectAssignment
    |   ObjectSetAssignment
    |   ParameterizedAssignment
    DefinedType ::=
        ExternalTypeReference
    |   typereference
    |   ParameterizedType
    |   ParameterizedValueSetType
DefinedValue ::=
        ExternalValueReference
    |   valuereference


                                                       Rec. ITU-T X.680 (02/2021)     167
      ISO/IEC 8824-1:2020 (E)

              |    ParameterizedValue

              NonParameterizedTypeName ::=
                 ExternalTypeReference
              |  typereference
              |  xmlasn1typename
              ExternalTypeReference ::=
                  modulereference
                  "."
                  typereference
              ExternalValueReference ::=
                  modulereference
                  "."
                  valuereference
          AbsoluteReference ::=
                   "@" ModuleIdentifier
                  "."
                  ItemSpec
              ItemSpec ::=
                  typereference
              |   ItemId "." ComponentId
              ItemId ::= ItemSpec
              ComponentId ::=
                 identifier
              |  number
              |  "*"
              TypeAssignment ::=
                  typereference
                  "::="
                  Type
              ValueAssignment ::=
                  valuereference
                  Type
                  "::="
                  Value
              XMLValueAssignment ::=
                valuereference
                "::="
                XMLTypedValue
              XMLTypedValue ::=
                "<" & NonParameterizedTypeName ">"
                XMLValue
                "</" & NonParameterizedTypeName ">"
              | "<" & NonParameterizedTypeName "/>"
              ValueSetTypeAssignment ::=
                  typereference
                  Type
                  "::="
                  ValueSet
              ValueSet ::= "{" ElementSetSpecs "}"
              Type ::= BuiltinType | ReferencedType | ConstrainedType
              BuiltinType ::=
                   BitStringType
              |    BooleanType


168        Rec. ITU-T X.680 (02/2021)
                                            ISO/IEC 8824-1:2020 (E)

|   CharacterStringType
|   ChoiceType
|   DateType
|   DateTimeType
|   DurationType
|   EmbeddedPDVType
|   EnumeratedType
|   ExternalType
|   InstanceOfType
|   IntegerType
|   IRIType
|   NullType
|   ObjectClassFieldType
|   ObjectIdentifierType
|   OctetStringType
|   RealType
|   RelativeIRIType
|   RelativeOIDType
|   SequenceType
|   SequenceOfType
|   SetType
|   SetOfType
|   PrefixedType
|   TimeType
|   TimeOfDayType
ReferencedType ::=
    DefinedType
|   UsefulType
|   SelectionType
|   TypeFromObject
|   ValueSetFromObjects
NamedType ::= identifier Type
Value ::=
    BuiltinValue
|   ReferencedValue
|   ObjectClassFieldValue
XMLValue ::=
  XMLBuiltinValue
| XMLObjectClassFieldValue
BuiltinValue ::=
     BitStringValue
|    BooleanValue
|    CharacterStringValue
|    ChoiceValue
|    EmbeddedPDVValue
|    EnumeratedValue
|    ExternalValue
|    InstanceOfValue
|    IntegerValue
|    IRIValue
|    NullValue
|    ObjectIdentifierValue
|    OctetStringValue
|    RealValue
|    RelativeIRIValue
|    RelativeOIDValue
|    SequenceValue
|    SequenceOfValue
|    SetValue
|    SetOfValue


                                Rec. ITU-T X.680 (02/2021)     169
      ISO/IEC 8824-1:2020 (E)

              |    PrefixedValue
              |    TimeValue
              XMLBuiltinValue ::=
                XMLBitStringValue
              | XMLBooleanValue
              | XMLCharacterStringValue
              | XMLChoiceValue
              | XMLEmbeddedPDVValue
              | XMLEnumeratedValue
              | XMLExternalValue
              | XMLInstanceOfValue
              | XMLIntegerValue
              | XMLIRIValue
              | XMLNullValue
              | XMLObjectIdentifierValue
              | XMLOctetStringValue
              | XMLRealValue
              | XMLRelativeIRIValue
              | XMLRelativeOIDValue
              | XMLSequenceValue
              | XMLSequenceOfValue
              | XMLSetValue
              | XMLSetOfValue
              | XMLPrefixedValue
              | XMLTimeValue
              ReferencedValue ::=
                  DefinedValue
              |   ValueFromObject
              NamedValue ::= identifier Value
              XMLNamedValue ::= "<" & identifier ">" XMLValue "</" & identifier ">"
              BooleanType ::=BOOLEAN
              BooleanValue::=      TRUE | FALSE

              XMLBooleanValue ::=
                EmptyElementBoolean
              | TextBoolean
              EmptyElementBoolean ::=
                 "<" & "true" "/>"
              |  "<" & "false" "/>"
              TextBoolean        ::=
                  extended-true
              |   extended-false
              IntegerType ::=
                   INTEGER
              |    INTEGER "{" NamedNumberList "}"

              NamedNumberList ::=
                 NamedNumber
              |  NamedNumberList "," NamedNumber
              NamedNumber ::=
                 identifier "(" SignedNumber ")"
              |  identifier "(" DefinedValue ")"
              SignedNumber ::=
                  number
              |   "-" number




170        Rec. ITU-T X.680 (02/2021)
                                                                    ISO/IEC 8824-1:2020 (E)

IntegerValue ::=
     SignedNumber
|    identifier
XMLIntegerValue ::=
  XMLSignedNumber
| EmptyElementInteger
| TextInteger
XMLSignedNumber ::=
  number
| "-" & number
EmptyElementInteger ::=
|  "<" & identifier "/>"
TextInteger ::=
    identifier
EnumeratedType ::=
   ENUMERATED "{" Enumerations "}"

Enumerations ::=
   RootEnumeration
|  RootEnumeration "," "..." ExceptionSpec
|  RootEnumeration "," "..." ExceptionSpec "," AdditionalEnumeration
RootEnumeration ::= Enumeration
AdditionalEnumeration ::= Enumeration
Enumeration ::= EnumerationItem | EnumerationItem "," Enumeration
EnumerationItem ::= identifier | NamedNumber
EnumeratedValue ::= identifier
XMLEnumeratedValue ::=
  EmptyElementEnumerated
| TextEnumerated
EmptyElementEnumerated ::= "<" & identifier "/>"
TextEnumerated ::= identifier
RealType ::=        REAL

RealValue ::=
    NumericRealValue
|   SpecialRealValue
NumericRealValue ::=
   realnumber
|  "-" realnumber
|  SequenceValue
SpecialRealValue ::=
    PLUS-INFINITY
|   MINUS-INFINITY
|   NOT-A-NUMBER

XMLRealValue ::=
  XMLNumericRealValue | XMLSpecialRealValue
XMLNumericRealValue ::=
  realnumber
| "-" & realnumber
XMLSpecialRealValue ::=
  EmptyElementReal
| TextReal


                                                    Rec. ITU-T X.680 (02/2021)         171
      ISO/IEC 8824-1:2020 (E)

              EmptyElementReal ::=
                 "<" & PLUS-INFINITY "/>"
              |  "<" & MINUS-INFINITY "/>"
              |  "<" & NOT-A-NUMBER "/>"
              TextReal ::=
                  "INF"
              |   "-" & "INF"
              |   "NaN"
              BitStringType ::=
                   BIT STRING
              |    BIT STRING "{" NamedBitList "}"

              NamedBitList ::=
                 NamedBit
              |  NamedBitList "," NamedBit
              NamedBit ::=
                 identifier "(" number ")"
              |  identifier "(" DefinedValue ")"
              BitStringValue ::=
                  bstring
              |   hstring
              |   "{" IdentifierList "}"
              |   "{" "}"
              |   CONTAINING Value

              IdentifierList ::=
                  identifier
              |   IdentifierList "," identifier
              XMLBitStringValue ::=
                XMLTypedValue
              | xmlbstring
              | XMLIdentifierList
              | empty
              XMLIdentifierList ::=
                EmptyElementList
              | TextList
              EmptyElementList ::=
                 "<" & identifier "/>"
              |  EmptyElementList "<" & identifier "/>"
              TextList ::=
                  identifier
              |   TextList identifier
              OctetStringType ::= OCTET STRING
              OctetStringValue ::=
                  bstring
              |   hstring
              |   CONTAINING Value

              XMLOctetStringValue ::=
                XMLTypedValue
              | xmlhstring
              NullType ::= NULL
              NullValue ::= NULL
              XMLNullValue ::= empty




172        Rec. ITU-T X.680 (02/2021)
                                                               ISO/IEC 8824-1:2020 (E)

SequenceType ::=
    SEQUENCE "{" "}"
|   SEQUENCE "{" ExtensionAndException OptionalExtensionMarker "}"
|   SEQUENCE "{" ComponentTypeLists "}"

ExtensionAndException ::= "..." | "..." ExceptionSpec
OptionalExtensionMarker ::= "," "..." | empty
ComponentTypeLists ::=
   RootComponentTypeList
   |   RootComponentTypeList "," ExtensionAndException ExtensionAdditions
       OptionalExtensionMarker
|  RootComponentTypeList "," ExtensionAndException ExtensionAdditions
       ExtensionEndMarker "," RootComponentTypeList
|  ExtensionAndException ExtensionAdditions ExtensionEndMarker ","
       RootComponentTypeList
|  ExtensionAndException ExtensionAdditions OptionalExtensionMarker
RootComponentTypeList ::= ComponentTypeList
ExtensionEndMarker ::= "," "..."
ExtensionAdditions ::=
    "," ExtensionAdditionList
|   empty
ExtensionAdditionList ::=
    ExtensionAddition
|   ExtensionAdditionList "," ExtensionAddition
ExtensionAddition ::=
    ComponentType
|   ExtensionAdditionGroup
ExtensionAdditionGroup ::= "[[" VersionNumber ComponentTypeList "]]"
VersionNumber ::= empty | number ":"
ComponentTypeList ::=
   ComponentType
|  ComponentTypeList "," ComponentType
ComponentType ::=
   NamedType
|  NamedType OPTIONAL
|  NamedType DEFAULT Value
|  COMPONENTS OF Type

SequenceValue ::=
    "{" ComponentValueList "}"
|   "{" "}"
ComponentValueList ::=
   NamedValue
|  ComponentValueList "," NamedValue
XMLSequenceValue ::=
  XMLComponentValueList
| empty
XMLComponentValueList ::=
  XMLNamedValue
| XMLComponentValueList XMLNamedValue
SequenceOfType ::= SEQUENCE OF Type | SEQUENCE OF NamedType
SequenceOfValue ::=
    "{" ValueList "}"



                                                   Rec. ITU-T X.680 (02/2021)     173
      ISO/IEC 8824-1:2020 (E)

              |    "{" NamedValueList "}"
              |    "{" "}"
              ValueList ::=
                  Value
              |   ValueList "," Value
              NamedValueList ::=
                 NamedValue
              |  NamedValueList "," NamedValue
              XMLSequenceOfValue ::=
                XMLValueList
              | XMLDelimitedItemList
              | empty
              XMLValueList ::=
                XMLValueOrEmpty
              | XMLValueOrEmpty XMLValueList
              XMLValueOrEmpty ::=
                XMLValue
              | "<" & NonParameterizedTypeName "/>"
              XMLDelimitedItemList ::=
                XMLDelimitedItem
              | XMLDelimitedItem XMLDelimitedItemList
              XMLDelimitedItem ::=
                "<" & NonParameterizedTypeName ">" XMLValue
                     "</" & NonParameterizedTypeName ">"
              | "<" & identifier ">" XMLValue "</" & identifier ">"
              SetType ::=
                  SET "{" "}"
              |   SET "{" ExtensionAndException OptionalExtensionMarker "}"
              |   SET "{" ComponentTypeLists "}"

              SetValue ::=
                  "{" ComponentValueList "}"
              |   "{" "}"
              XMLSetValue ::=
                XMLComponentValueList
              | empty
              SetOfType ::=
                  SET OF Type
              |   SET OF NamedType

              SetOfValue ::=
                  "{" ValueList "}"
              |   "{" NamedValueList "}"
              |   "{" "}"
              XMLSetOfValue ::=
                XMLValueList
              | XMLDelimitedItemList
              | empty
              ChoiceType ::= CHOICE "{" AlternativeTypeLists "}"
              AlternativeTypeLists ::=
                  RootAlternativeTypeList
              |   RootAlternativeTypeList ","
                       ExtensionAndException ExtensionAdditionAlternatives
                       OptionalExtensionMarker
              RootAlternativeTypeList ::= AlternativeTypeList


174        Rec. ITU-T X.680 (02/2021)
                                                                    ISO/IEC 8824-1:2020 (E)

ExtensionAdditionAlternatives ::=
    "," ExtensionAdditionAlternativesList
|   empty
ExtensionAdditionAlternativesList ::=
    ExtensionAdditionAlternative
|   ExtensionAdditionAlternativesList "," ExtensionAdditionAlternative
ExtensionAdditionAlternative ::=
    ExtensionAdditionAlternativesGroup
|   NamedType
ExtensionAdditionAlternativesGroup ::=
    "[[" VersionNumber AlternativeTypeList "]]"
AlternativeTypeList ::=
    NamedType
|   AlternativeTypeList "," NamedType
ChoiceValue ::= identifier ":" Value
XMLChoiceValue ::= "<" & identifier ">" XMLValue "</" & identifier ">"
SelectionType ::= identifier "<" Type
PrefixedType ::=
     TaggedType
|    EncodingPrefixedType
PrefixedValue ::= Value
XMLPrefixedValue ::= XMLValue
TaggedType ::=
    Tag Type
|   Tag IMPLICIT Type
|   Tag EXPLICIT Type
Tag ::= "[" EncodingReference Class ClassNumber "]"
EncodingReference ::=
    encodingreference ":"
|   empty
ClassNumber ::=
    number
|   DefinedValue
Class ::=
    UNIVERSAL
|   APPLICATION
|   PRIVATE
|   empty
EncodingPrefixedType ::=
EncodingPrefix Type
EncodingPrefix ::=
"[" EncodingReference EncodingInstruction "]"
ObjectIdentifierType ::=
    OBJECT IDENTIFIER

ObjectIdentifierValue ::=
    "{" ObjIdComponentsList "}"
|   "{" DefinedValue ObjIdComponentsList "}"
ObjIdComponentsList ::=
    ObjIdComponents
|   ObjIdComponents ObjIdComponentsList



                                                      Rec. ITU-T X.680 (02/2021)       175
      ISO/IEC 8824-1:2020 (E)

              ObjIdComponents ::=
                  NameForm
              |   NumberForm
              |   NameAndNumberForm
              |   DefinedValue
              NameForm ::= identifier
              NumberForm ::= number | DefinedValue
              NameAndNumberForm ::=
                 identifier "(" NumberForm ")"
              XMLObjectIdentifierValue ::=
                XMLObjIdComponentList
              XMLObjIdComponentList ::=
                XMLObjIdComponent
              | XMLObjIdComponent & "." & XMLObjIdComponentList
              XMLObjIdComponent ::=
                NameForm
              | XMLNumberForm
              | XMLNameAndNumberForm
              XMLNumberForm ::= number
              XMLNameAndNumberForm ::=
                identifier & "(" & XMLNumberForm & ")"
              RelativeOIDType ::= RELATIVE-OID
              RelativeOIDValue ::=
                  "{" RelativeOIDComponentsList "}"
              RelativeOIDComponentsList ::=
                  RelativeOIDComponents
              |   RelativeOIDComponents RelativeOIDComponentsList
              RelativeOIDComponents ::=
                  NumberForm
              |   NameAndNumberForm
              |   DefinedValue
              XMLRelativeOIDValue ::=
                XMLRelativeOIDComponentList
              XMLRelativeOIDComponentList ::=
                XMLRelativeOIDComponent
              | XMLRelativeOIDComponent & "." & XMLRelativeOIDComponentList
              XMLRelativeOIDComponent ::=
                XMLNumberForm
              | XMLNameAndNumberForm
              IRIType ::= OID-IRI
              IRIValue ::=
                  """
                  FirstArcIdentifier
                  SubsequentArcIdentifier
                  """
              FirstArcIdentifier ::=
                   "/" ArcIdentifier
              SubsequentArcIdentifier ::=
                  "/" ArcIdentifier SubsequentArcIdentifier
              |   empty



176        Rec. ITU-T X.680 (02/2021)
                                                       ISO/IEC 8824-1:2020 (E)

ArcIdentifier ::=
    integerUnicodeLabel
|   non-integerUnicodeLabel
XMLIRIValue ::=
  FirstArcIdentifier
  SubsequentArcIdentifier
RelativeIRIType ::= RELATIVE-OID-IRI
RelativeIRIValue ::=
    """
    FirstRelativeArcIdentifier
    SubsequentArcIdentifier
    """
FirstRelativeArcIdentifier ::=
     ArcIdentifier
XMLRelativeIRIValue ::=
  FirstRelativeArcIdentifier
  SubsequentArcIdentifier
EmbeddedPDVType ::= EMBEDDED PDV
EmbeddedPDVValue ::= SequenceValue
XMLEmbeddedPDVValue ::= XMLSequenceValue
ExternalType ::= EXTERNAL
ExternalValue ::= SequenceValue
XMLExternalValue ::= XMLSequenceValue
TimeType ::= TIME
TimeValue ::= tstring
XMLTimeValue ::= xmltstring
DateType ::= DATE
TimeOfDayType ::= TIME-OF-DAY
DateTimeType ::= DATE-TIME
DurationType ::= DURATION
CharacterStringType ::=
   RestrictedCharacterStringType
|  UnrestrictedCharacterStringType
CharacterStringValue ::=
   RestrictedCharacterStringValue
|  UnrestrictedCharacterStringValue
XMLCharacterStringValue ::=
  XMLRestrictedCharacterStringValue
| XMLUnrestrictedCharacterStringValue
RestrictedCharacterStringType ::=
    BMPString
|   GeneralString
|   GraphicString
|   IA5String
|   ISO646String
|   NumericString
|   PrintableString
|   TeletexString
|   T61String


                                           Rec. ITU-T X.680 (02/2021)     177
      ISO/IEC 8824-1:2020 (E)

               |      UniversalString
               |      UTF8String
               |      VideotexString
               |      VisibleString

               RestrictedCharacterStringValue ::=
                   cstring
               |   CharacterStringList
               |   Quadruple
               |   Tuple
               CharacterStringList ::= "{" CharSyms "}"
               CharSyms ::=
                  CharsDefn
               |  CharSyms "," CharsDefn
               CharsDefn ::=
                  cstring
               |  Quadruple
               |  Tuple
               |  DefinedValue
               Quadruple ::= "{" Group "," Plane "," Row "," Cell "}"
               Group     ::= number
               Plane     ::= number
               Row       ::= number
               Cell      ::= number
               Tuple     ::= "{" TableColumn "," TableRow "}"
               TableColumn ::= number
               TableRow ::= number
               XMLRestrictedCharacterStringValue ::= xmlcstring
               UnrestrictedCharacterStringType ::= CHARACTER STRING
               UnrestrictedCharacterStringValue ::= SequenceValue
               XMLUnrestrictedCharacterStringValue ::= XMLSequenceValue
               UsefulType ::= typereference
The following character string types are defined in 41.1:
                   UTF8String                         GraphicString
                   NumericString                      VisibleString
                   PrintableString              ISO646String
                   TeletexString                      GeneralString
                   T61String                                  UniversalString
                   VideotexString                     BMPString
                   IA5String

The following useful types are defined in clauses 46 to 48:
                   GeneralizedTime
                   UTCTime
                   ObjectDescriptor




178        Rec. ITU-T X.680 (02/2021)
                                                                                 ISO/IEC 8824-1:2020 (E)

The following productions are used in clauses 49 to 51:
              ConstrainedType ::=
                  Type Constraint
              |   TypeWithConstraint
              TypeWithConstraint ::=
                  SET Constraint OF Type
              |   SET SizeConstraint OF Type
              |   SEQUENCE Constraint OF Type
              |   SEQUENCE SizeConstraint OF Type
              |   SET Constraint OF NamedType
              |   SET SizeConstraint OF NamedType
              |   SEQUENCE Constraint OF NamedType
              |   SEQUENCE SizeConstraint OF NamedType

              Constraint ::= "(" ConstraintSpec ExceptionSpec ")"
              ConstraintSpec ::= SubtypeConstraint
              |                  GeneralConstraint
              SubtypeConstraint ::= ElementSetSpecs
              ElementSetSpecs ::=
                  RootElementSetSpec
              |   RootElementSetSpec "," "..."
              |   RootElementSetSpec "," "..." "," AdditionalElementSetSpec
              RootElementSetSpec ::= ElementSetSpec
              AdditionalElementSetSpec ::= ElementSetSpec
              ElementSetSpec ::= Unions
              |   ALL Exclusions

              Unions ::= Intersections
              |   UElems UnionMark Intersections
              UElems ::= Unions
              Intersections ::= IntersectionElements
              |    IElems IntersectionMark IntersectionElements
              IElems ::= Intersections
              IntersectionElements ::= Elements | Elems Exclusions
              Elems ::= Elements
              Exclusions ::= EXCEPT Elements
              UnionMark ::= "|"             |        UNION

              IntersectionMark ::= "^" |             INTERSECTION

              Elements ::=
                  SubtypeElements
              |   ObjectSetElements
              |   "(" ElementSetSpec ")"
              SubtypeElements ::=
                  SingleValue
              |   ContainedSubtype
              |   ValueRange
              |   PermittedAlphabet
              |   SizeConstraint
              |   TypeConstraint
              |   InnerTypeConstraints
              |   PatternConstraint
              |   PropertySettings


                                                                     Rec. ITU-T X.680 (02/2021)     179
      ISO/IEC 8824-1:2020 (E)

              |    DurationRange
              |    TimePointRange
              |    RecurrenceRange
              SingleValue ::= Value
              ContainedSubtype ::= Includes Type
              Includes ::= INCLUDES | empty
              ValueRange ::= LowerEndpoint ".." UpperEndpoint
              LowerEndpoint ::= LowerEndValue | LowerEndValue "<"
              UpperEndpoint ::= UpperEndValue | "<" UpperEndValue
              LowerEndValue ::= Value | MIN
              UpperEndValue ::= Value | MAX
              SizeConstraint ::= SIZE Constraint
              TypeConstraint ::= Type
              PermittedAlphabet ::= FROM Constraint
              InnerTypeConstraints ::=
                  WITH COMPONENT SingleTypeConstraint
              |   WITH COMPONENTS MultipleTypeConstraints

              SingleTypeConstraint::= Constraint
              MultipleTypeConstraints ::=
                  FullSpecification
              |   PartialSpecification
              FullSpecification ::= "{" TypeConstraints "}"
              PartialSpecification ::= "{" "..." "," TypeConstraints "}"
              TypeConstraints ::=
                  NamedConstraint
              |   NamedConstraint "," TypeConstraints
              NamedConstraint ::=
                 identifier ComponentConstraint
              ComponentConstraint ::= ValueConstraint PresenceConstraint
              ValueConstraint ::= Constraint | empty
              PresenceConstraint ::= PRESENT | ABSENT | OPTIONAL | empty
              PatternConstraint ::= PATTERN Value
              PropertySettings ::= SETTINGS simplestring
              PropertySettingsList ::=
                  PropertyAndSettingPair
              |   PropertySettingsList PropertyAndSettingPair
              PropertyAndSettingPair ::= PropertyName "=" SettingName
              PropertyName ::= psname
              SettingName ::= psname
              DurationRange ::= ValueRange
              TimePointRange ::= ValueRange
              RecurrenceRange ::= ValueRange




180        Rec. ITU-T X.680 (02/2021)
                                                                    ISO/IEC 8824-1:2020 (E)

ExceptionSpec ::= "!" ExceptionIdentification | empty
ExceptionIdentification ::=
    SignedNumber
|   DefinedValue
|   Type ":" Value




                                                        Rec. ITU-T X.680 (02/2021)     181
                     SERIES OF ITU-T RECOMMENDATIONS

Series A   Organization of the work of ITU-T

Series D   Tariff and accounting principles and international telecommunication/ICT economic and policy
           issues

Series E   Overall network operation, telephone service, service operation and human factors

Series F   Non-telephone telecommunication services

Series G   Transmission systems and media, digital systems and networks

Series H   Audiovisual and multimedia systems

Series I   Integrated services digital network

Series J   Cable networks and transmission of television, sound programme and other multimedia signals

Series K   Protection against interference

Series L   Environment and ICTs, climate change, e-waste, energy efficiency; construction, installation
           and protection of cables and other elements of outside plant

Series M   Telecommunication management, including TMN and network maintenance

Series N   Maintenance: international sound programme and television transmission circuits

Series O   Specifications of measuring equipment

Series P   Telephone transmission quality, telephone installations, local line networks

Series Q   Switching and signalling, and associated measurements and tests

Series R   Telegraph transmission

Series S   Telegraph services terminal equipment

Series T   Terminals for telematic services

Series U   Telegraph switching

Series V   Data communication over the telephone network

Series X   Data networks, open system communications and security

Series Y   Global information infrastructure, Internet protocol aspects, next-generation networks, Internet
           of Things and smart cities

Series Z   Languages and general software aspects for telecommunication systems




                                                                                    Printed in Switzerland
                                                                                            Geneva, 2021
